====================================================================
Some rough notes about the Oz threading model and dataflow variables
====================================================================

(almost verbatim from CTM)

Threads
=======

Scheduling
----------

Fair scheduling through round-robin.

Needs not be deterministic.

With priority levels : three queues exist, which manage high, medium,
low priority threads. The time slice ratio for these is
100:10:1. Threads inherit the priority of their parent.

Mozart uses an external timer approach to implement thread preemption.

Thread ops
----------

All these ops are defined in a Thread namespace/module.

this()               -> current thread's name (*not* another thread's name)
state(t)             -> return state of t in {runnable, blocked, terminated}
suspend(t)            : suspend t
resume(t)             : resume execution of t
preempt(t)            : preempt t
terminate(t)          : terminate t immediately
injectException(t, e) : raise exception e in t
setPriority(t, p)     : set t's priority to p

Interestingly, coroutines can be build upon this thread
API. Coroutines have two ops : spawn and resume.

spawn(p)             -> creates a coroutine with procedure p, returns pid
resume(c)             : transfers control from current coroutine to c

The implementation of these ops in terms of the threads API is as
follows :

def spawn(p):
    in_thread:
        pid = Thread.this()
        Thread.suspend(pid)
        p()

def resume(cid):
    Thread.resume cid
    Thread.suspend(Thread.this())


Thread communication
--------------------

No shared state is allowed (in the model we are interested in
anyway). Threads communicate through dataflow variables, which
alleviates the need for explicit locking/monitoring.

While this restricts somewhat what can be done, it is the most
expressive way of using threads without shooting oneself in the
foot. Concurrent constraint programming uses and abuses of this kind
of concurrency.

Dataflow variable allow streams to be created. "A stream is a
potentially unbounded list of messages, i.e a list whose tail is an
unbound dataflow variable. Receiving a message is reading a stream
element. Each variable is bound by only one thread".

If you practice UNIX pipes, you have some basis to understand
this. Also see http://www.jpaulmorrison.com/fbp/.


Synchronization
---------------

The combination of threads and dataflow variables leads to implicit
synchronization : that means synchronization is not textually visible
in the source code but follow from the semantics of dataflow
variables; using such a variable implies synchronization on the
variable being bound to a value.

Eager execution (the mere fact of executing statements as they present
themselves to the interpreter, withou delay) plus dataflow vars also
implies "supply-driven synchronization" ; operations wait
(synchronize) on the availability of their arguments. 

One important benefit is that the dependencies between parts of a
program are implicitly and dynamically computed (it depends on the
availability of the data instead of decision of the programmer).

Doing computations with only partial information is possible ("partial
values can be seen as complete values that are only partially known").

Dataflow variables
==================

(see http://www.sics.se/~frej/flow_java/ for an implementation of
dataflow variables in Java).

Dataflow variables were originally discovered by people working on
logic programming and were called logic variables. They have
well-defined logic semantics.

"A dataflow variable is stateful, because it can change state
(transition from unbound to bound to a value) -- but it can be bound
to only one value in its lifetime (single-assignement variable is a
term used sometimes to describe them).

A dataflow variable is stateless, because binding is monotonic. That
means we can only add information to the binding, but not remove or
alter information".

Difference with single-assignment variables
-------------------------------------------

A single-assignment variable is a mutable variable that can be
assigned only once. This differ form a dataflow variable in that the
latter can be assigned (perhaps multiple times) to many partial
values, provided the partial values are compatible (unifiable) with
each other.

Futures
=======

Dataflow variables are but one technique to implement dataflow
execution. Another, quite popular technique is based on a slightly
different concept, the single-assignment variable. Two of the
best-known instances of the single-assignment variable are futures and
I-structures. The purpose of futures and I-structures is to increase
the potential parallelism of a program by removing inessential
dependencies between calculations. They allow concurrency between a
computation that calculates a value and one that uses the value. This
concurrency can be exploited on a parallel machine. We define futures
and I-structures and compare them with dataflow variables.

Futures were first introduced in Multilisp, a language intended for
writting parallel programs. Multilisp introduces the function call
(future E) where E is any expression. This does two things: it
immediately returns a placeholder for the result of E and it initiates
a concurrent evaluation of E. When the value of E is needed, i.e., a
computation tries to access the placeholder, then the computation
blocks until the value is available. We model this as follows in the
declarative concurrent model (where E is a zero-argument function) :

fun {Future E}
X in
  thread X={E} end
  !!X
end

A future can only be bound by the concurrent computation that is
created along with it. This is enforced by returning a read-only
variable. Multilisp also has a delay construct that does not initiate
any evaluation but uses by-need execution. It causes evaluation of its
argument only when the result is needed.  An I-structure (for
"incomplete structure") is an array of single-assignment
variables. Individual elements can be accessed before the elements are
computed. I-structures were introduced as a language construct for
writing parallel programs in dataflow machines, e.g., in the dataflow
language Id. I-structures are also used in pH ("parallel Haskell"), a
recent language design that extends Haskell for implicit
parallelism. An I-structure permits concurrency between a computation
that calculates the array elements and a computation that uses their
values. When the value of an element is needed, then the computatio
blocks until it is available. Like a future and a read-only variable,
an element of an I-structure can only be bound by the computation that
calculates it.  There is a fundamental difference between dataflow
variables on one side and futures and I-structures on the other
side. The latter can be bound only once, whereas dataflow variables
can be bound more than once, as long as the bindings are consistent
with each other. Two partial values are consistent if they are
unifiable. A dataflow variable can be bound many times to different
partial values as long as the partial values are unifiable.


