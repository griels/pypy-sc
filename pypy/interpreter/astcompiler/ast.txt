# This file describes the nodes of the AST in ast.py.  The module is
# generated by astgen.py.  
# The descriptions use the following special notation to describe
# properties of the children:

#    *   this child is not a node

#    *int   this child is not a node
#    *str   this child is not a node
#    *[int]   this child is not a node
#    *[str]   this child is not a node

#    %   this child is a wrapped object
#    !   this child is a sequence that contains nodes in it
#    &   this child may be set to None
#    (type) where type is int, str
#    [type]
#  = ... a default value for the node constructor (optional args)
Module: w_doc%, node
Stmt: nodes!
Decorators: nodes!
AbstractFunction:
Function(AbstractFunction): decorators&, name*str, argnames!, defaults!, flags*int, w_doc%, code
Lambda(AbstractFunction): argnames!, defaults!, flags*int, code
Class: name*str, bases!, w_doc%, code
Pass: 
Break: 
Continue: 
For: assign, list, body, else_&
While: test, body, else_&
If: tests!, else_&
Exec: expr, locals&, globals&
From: modname*str, names*
Import: names*
Raise: expr1&, expr2&, expr3&
TryFinally: body, final
TryExcept: body, handlers!, else_&
Return: value&
Yield: value
Const: value%
NoneConst:
#StringConst: string_value*
#NumberConst: number_value*
Print: nodes!, dest&
Printnl: nodes!, dest&
Discard: expr
AugAssign: node, op*str, expr
Assign: nodes!, expr
AssSeq:
AssTuple(AssSeq): nodes!
AssList(AssSeq): nodes!
AssName: name*str, flags*int
AssAttr: expr, attrname*str, flags*int
ListComp: expr, quals!
ListCompFor: assign, list, ifs!
ListCompIf: test
GenExpr(AbstractFunction): code 
GenExprInner: expr, quals!
GenExprFor: assign, iter, ifs!
GenExprIf: test
List: nodes!
Dict: items!
UnaryOp:
Not(UnaryOp): expr
Compare: expr, ops!
Name: varname*str
Global: names*[str]
Backquote(UnaryOp): expr
Getattr: expr, attrname*str
CallFunc: node, args!, star_args& = None, dstar_args& = None
Keyword: name*str, expr
Subscript: expr, flags*int, subs!
Ellipsis: 
Sliceobj: nodes!
Slice: expr, flags*int, lower&, upper&
Assert: test, fail&
Tuple: nodes!
AbstractTest:
Or(AbstractTest): nodes!
And(AbstractTest): nodes!
BitOp:
Bitor(BitOp): nodes!
Bitxor(BitOp): nodes!
Bitand(BitOp): nodes!
BinaryOp:
LeftShift(BinaryOp): left, right
RightShift(BinaryOp): left, right
Add(BinaryOp): left, right
Sub(BinaryOp): left, right
Mul(BinaryOp): left, right
Div(BinaryOp): left, right
Mod(BinaryOp): left, right
Power(BinaryOp): left, right
FloorDiv(BinaryOp): left, right
UnaryAdd(UnaryOp): expr
UnarySub(UnaryOp): expr
Invert(UnaryOp): expr

== OVERRIDES ==

init(Function):
    self.varargs = self.kwargs = 0
    if flags & CO_VARARGS:
        self.varargs = 1
    if flags & CO_VARKEYWORDS:
        self.kwargs = 1

init(Lambda):
    self.varargs = self.kwargs = 0
    if flags & CO_VARARGS:
        self.varargs = 1
    if flags & CO_VARKEYWORDS:
        self.kwargs = 1

init(GenExpr):
    self.argnames = [AssName('[outmost-iterable]', OP_ASSIGN)]
    self.varargs = self.kwargs = 0

init(GenExprFor):
    self.is_outmost = False

flatten_nodes(Compare.ops):
    # ops is a list of couples (op_name, node)
    for op_name, node in self.ops:
        nodelist.append(node)

flatten_nodes(TryExcept.handlers):
    # handlers is a list of triplets (expr1, expr2, body)
    for expr1, expr2, body in self.handlers:
        if expr1 is not None:
            nodelist.append(expr1)
        if expr2 is not None:
            nodelist.append(expr2)
        if body is not None:
            nodelist.append(body)

flatten_nodes(Dict.items):
    # items is a list of couples (node (key), node (value))
    for key, value in self.items:
        nodelist.append(key)
        nodelist.append(value)

flatten_nodes(If.tests):
    # tests is a list of couples (node (test), node (suite))
    for test, suite in self.tests:
        nodelist.append(test)
        nodelist.append(suite)

AssTuple.getArgNames(self):
    argnames = []
    for node in self.nodes:
        if isinstance(node, AssTuple):
            argnames.extend(node.getArgNames())
        elif isinstance(node, AssName):
            name = node.name
            assert isinstance(name, str)
            argnames.append(name)
        else:
            assert False, "should only have AssName and AssTuple as children"
    return argnames

Compare.fget_ops( space, self ):
    lst = []
    for op_name, node in self.ops:
        lst.append( space.newtuple( [ space.wrap(op_name), space.wrap(node) ] ) )
    return space.newlist( lst )

Compare.fset_ops( space, self, w_arg ):
    del self.ops[:]
    for w_obj in space.unpackiterable( w_arg ):
        w_opname = space.getitem( w_obj, space.wrap(0) )
        w_node = space.getitem( w_obj, space.wrap(1) )
        ops = space.str_w(w_opname)
        node = space.interpclass_w( w_node )
        if not isinstance(node, Node):
           raise OperationError(space.w_TypeError, space.wrap("ops must be a list of (name,node)"))
        self.ops.append( (ops,node) )

Dict.fget_items( space, self ):
    return space.newlist( [ space.newtuple( [ space.wrap(key), space.wrap(value) ] )
                            for key, value in self.items ] )

Dict.fset_items( space, self, w_arg ):
    del self.items[:]
    for w_tup in space.unpackiterable( w_arg ):
        w_key = space.getitem( w_tup, space.wrap(0) )
        w_value = space.getitem( w_tup, space.wrap(1) )
        key = space.interpclass_w( w_key )
        value = space.interpclass_w( w_value )
        if not isinstance( key, Node ) or not isinstance( value, Node ):
            raise OperationError(space.w_TypeError, space.wrap("Need a list of (key node, value node)"))
        self.items.append( (key,value) )

flatten_nodes(TryExcept.handlers):
    # handlers is a list of triplets (expr1, expr2, body)
    for expr1, expr2, body in self.handlers:
        if expr1 is not None:
            nodelist.append(expr1)
        if expr2 is not None:
            nodelist.append(expr2)
        if body is not None:
            nodelist.append(body)

flatten_nodes(If.tests):
    # tests is a list of couples (node (test), node (suite))
    for test, suite in self.tests:
        nodelist.append(test)
        nodelist.append(suite)


If.fget_tests( space, self ):
    return space.newlist( [ space.newtuple( [ space.wrap(test),
                                              space.wrap(suite) ] )
                            for test, suite in self.tests ] )

If.fset_tests( space, self, w_arg ):
    del self.tests[:]
    for w_tup in space.unpackiterable( w_arg ):
        w_test = space.getitem( w_tup, space.wrap(0) )
        w_suite = space.getitem( w_tup, space.wrap(1) )
        test = space.interpclass_w( w_test )
        suite = space.interpclass_w( w_suite )
        if not isinstance( test, Node ) or not isinstance( suite, Node ):
            raise OperationError(space.w_TypeError, space.wrap("Need a list of (test,suite) nodes") )
        self.tests.append( (test,suite) )



TryExcept.fget_handlers( space, self ):
    return space.newlist( [ space.newtuple( [ space.wrap(expr1),
                                              space.wrap(expr2),
                                              space.wrap(body) ] )
                            for expr1, expr2, body in self.handlers ] )

TryExcept.fset_handlers( space, self, w_arg ):
    del self.handlers[:]
    for w_tup in space.unpackiterable( w_arg ):
        w_expr1 = space.getitem( w_tup, space.wrap(0) )
        w_expr2 = space.getitem( w_tup, space.wrap(1) )
        w_body = space.getitem( w_tup, space.wrap(2) )
        expr1 = space.interpclass_w( w_expr1 )
        expr2 = space.interpclass_w( w_expr2 )
        body = space.interpclass_w( w_body )
        if not isinstance( expr1, Node ) or not isinstance( expr2, Node ) or not isinstance( body, Node ):
            raise OperationError(space.w_TypeError, space.wrap("Need a list of (expr1,expr2,body) nodes") )
        self.handlers.append( (expr1,expr2,body) )

Import.fget_names( space, self ):
    return space.newlist( [ space.newtuple( [ space.wrap(name), space.wrap(as_name) ] )
                            for name, as_name in self.names ] )

Import.fset_names( space, self, w_arg ):
    del self.names[:]
    for w_tup in space.unpackiterable( w_arg ):
        w_name = space.getitem( w_tup, space.wrap(0) ) 
        w_as_name = space.getitem( w_tup, space.wrap(1) )
        name = space.str_w( w_name )
        as_name = None
        if not space.is_w( w_as_name, space.w_None ):
            as_name = space.str_w( w_as_name )
        self.names.append( (name, as_name) )

From.fget_names( space, self ):
    return space.newlist( [ space.newtuple( [ space.wrap(name), space.wrap(as_name) ] )
                            for name, as_name in self.names ] )

From.fset_names( space, self, w_arg ):
    del self.names[:]
    for w_tup in space.unpackiterable( w_arg ):
        w_name = space.getitem( w_tup, space.wrap(0) ) 
        w_as_name = space.getitem( w_tup, space.wrap(1) )
        name = space.str_w( w_name )
        as_name = None
        if not space.is_w( w_as_name, space.w_None ):
            as_name = space.str_w( w_as_name )
        self.names.append( (name, as_name) )

