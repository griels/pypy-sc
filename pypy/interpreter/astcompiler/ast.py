
"""Python abstract syntax node definitions

This file is automatically generated by Tools/compiler/astgen.py
"""
from consts import CO_VARARGS, CO_VARKEYWORDS, OP_ASSIGN
from pypy.interpreter.baseobjspace import Wrappable
from pypy.interpreter.typedef import TypeDef, GetSetProperty
from pypy.interpreter.gateway import interp2app, W_Root, ObjSpace
from pypy.interpreter.argument import Arguments
from pypy.interpreter.error import OperationError

def flatten(list):
    l = []
    for elt in list:
        t = type(elt)
        if t is tuple or t is list:
            for elt2 in flatten(elt):
                l.append(elt2)
        else:
            l.append(elt)
    return l

#def flatten_nodes(list):
#    return [n for n in flatten(list) if isinstance(n, Node)]

nodes = {}

class Node(Wrappable):
    """Abstract base class for ast nodes."""
    def __init__(self, lineno = -1):
        self.lineno = lineno
        self.filename = ""
        #self.scope = None
        
    def getChildren(self):
        pass # implemented by subclasses
    def __iter__(self):
        for n in self.getChildren():
            yield n
    def asList(self): # for backwards compatibility
        return self.getChildren()
    def getChildNodes(self):
        return [] # implemented by subclasses
    def accept(self, visitor):
        raise NotImplementedError
    def flatten(self):
        res = []
        nodes = self.getChildNodes()
        if nodes:
            for n in nodes:
                res.extend( n.flatten() )
        else:
            res.append( self )
        return res

    def __repr__(self):
	return "Node()"

    def descr_repr( self, space ):
	return space.wrap( self.__repr__() )
    
    def descr_getChildNodes( self, space ):
        lst = self.getChildNodes()
        return space.newlist( [ space.wrap( it ) for it in lst ] )

def descr_node_accept( space, w_self, w_visitor ):
    w_callable = space.getattr(w_visitor, space.wrap('visitNode'))
    args = Arguments(space, [ w_self ])
    return space.call_args( w_callable, args )

Node.typedef = TypeDef('ASTNode',
		       #__repr__ = interp2app(descr_node_repr, unwrap_spec=['self', ObjSpace] ),
		       getChildNodes = interp2app(Node.descr_getChildNodes, unwrap_spec=[ 'self', ObjSpace ] ),
		       accept = interp2app(descr_node_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
		       )

        
class EmptyNode(Node):
    def accept(self, visitor):
        return visitor.visitEmptyNode(self)

class Expression(Node):
    # Expression is an artificial node class to support "eval"
    nodes["expression"] = "Expression"
    def __init__(self, node):
        Node.__init__(self)
        self.node = node

    def getChildren(self):
        return [self.node,]

    def getChildNodes(self):
        return [self.node,]

    def __repr__(self):
        return "Expression(%s)" % (repr(self.node))

    def accept(self, visitor):
        return visitor.visitExpression(self)



class AbstractFunction(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AbstractFunction()"

    def accept(self, visitor):
        return visitor.visitAbstractFunction(self)


def descr_AbstractFunction_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAbstractFunction'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AbstractFunction.typedef = TypeDef('AbstractFunction', Node.typedef, 
                     accept=interp2app(descr_AbstractFunction_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class AbstractTest(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AbstractTest()"

    def accept(self, visitor):
        return visitor.visitAbstractTest(self)


def descr_AbstractTest_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAbstractTest'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AbstractTest.typedef = TypeDef('AbstractTest', Node.typedef, 
                     accept=interp2app(descr_AbstractTest_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class BinaryOp(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "BinaryOp()"

    def accept(self, visitor):
        return visitor.visitBinaryOp(self)


def descr_BinaryOp_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBinaryOp'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

BinaryOp.typedef = TypeDef('BinaryOp', Node.typedef, 
                     accept=interp2app(descr_BinaryOp_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class Add(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Add(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitAdd(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_Add_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAdd'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Add.typedef = TypeDef('Add', BinaryOp.typedef, 
                     accept=interp2app(descr_Add_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(Add.fget_left, Add.fset_left ),
                    right=GetSetProperty(Add.fget_right, Add.fset_right ),
                    )

class And(AbstractTest):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "And(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitAnd(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_And_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAnd'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

And.typedef = TypeDef('And', AbstractTest.typedef, 
                     accept=interp2app(descr_And_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(And.fget_nodes, And.fset_nodes ),
                    )

class AssAttr(Node):
    def __init__(self, expr, attrname, flags, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.attrname = attrname
        self.flags = flags

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr, self.attrname, self.flags

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "AssAttr(%s, %s, %s)" % (self.expr.__repr__(), self.attrname.__repr__(), self.flags.__repr__())

    def accept(self, visitor):
        return visitor.visitAssAttr(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj
    def fget_attrname( space, self):
        return space.wrap(self.attrname)
    def fset_attrname( space, self, w_arg):
        self.attrname = space.str_w(w_arg)
    def fget_flags( space, self):
        return space.wrap(self.flags)
    def fset_flags( space, self, w_arg):
        self.flags = space.int_w(w_arg)

def descr_AssAttr_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssAttr'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssAttr.typedef = TypeDef('AssAttr', Node.typedef, 
                     accept=interp2app(descr_AssAttr_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(AssAttr.fget_expr, AssAttr.fset_expr ),
                    attrname=GetSetProperty(AssAttr.fget_attrname, AssAttr.fset_attrname ),
                    flags=GetSetProperty(AssAttr.fget_flags, AssAttr.fset_flags ),
                    )

class AssSeq(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AssSeq()"

    def accept(self, visitor):
        return visitor.visitAssSeq(self)


def descr_AssSeq_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssSeq'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssSeq.typedef = TypeDef('AssSeq', Node.typedef, 
                     accept=interp2app(descr_AssSeq_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class AssList(AssSeq):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "AssList(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitAssList(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_AssList_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssList'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssList.typedef = TypeDef('AssList', AssSeq.typedef, 
                     accept=interp2app(descr_AssList_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(AssList.fget_nodes, AssList.fset_nodes ),
                    )

class AssName(Node):
    def __init__(self, name, flags, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.flags = flags

    def getChildren(self):
        "NOT_RPYTHON"
        return self.name, self.flags

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AssName(%s, %s)" % (self.name.__repr__(), self.flags.__repr__())

    def accept(self, visitor):
        return visitor.visitAssName(self)

    def fget_name( space, self):
        return space.wrap(self.name)
    def fset_name( space, self, w_arg):
        self.name = space.str_w(w_arg)
    def fget_flags( space, self):
        return space.wrap(self.flags)
    def fset_flags( space, self, w_arg):
        self.flags = space.int_w(w_arg)

def descr_AssName_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssName'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssName.typedef = TypeDef('AssName', Node.typedef, 
                     accept=interp2app(descr_AssName_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    name=GetSetProperty(AssName.fget_name, AssName.fset_name ),
                    flags=GetSetProperty(AssName.fget_flags, AssName.fset_flags ),
                    )

class AssTuple(AssSeq):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def getArgNames(self):
        argnames = []
        for node in self.nodes:
            if isinstance(node, AssTuple):
                argnames.extend(node.getArgNames())
            elif isinstance(node, AssName):
                name = node.name
                assert isinstance(name, str)
                argnames.append(name)
            else:
                assert False, "should only have AssName and AssTuple as children"
        return argnames
    

    def __repr__(self):
        return "AssTuple(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitAssTuple(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_AssTuple_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssTuple'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssTuple.typedef = TypeDef('AssTuple', AssSeq.typedef, 
                     accept=interp2app(descr_AssTuple_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(AssTuple.fget_nodes, AssTuple.fset_nodes ),
                    )

class Assert(Node):
    def __init__(self, test, fail, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test
        self.fail = fail

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.test)
        children.append(self.fail)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        if self.fail is not None:
            nodelist.append(self.fail)
        return nodelist

    def __repr__(self):
        return "Assert(%s, %s)" % (self.test.__repr__(), self.fail.__repr__())

    def accept(self, visitor):
        return visitor.visitAssert(self)

    def fget_test( space, self):
        return space.wrap(self.test)
    def fset_test( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.test = obj
    def fget_fail( space, self):
        if self.fail is None:
            return space.w_None
        else:
            return space.wrap(self.fail)
    def fset_fail( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.fail = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.fail = obj

def descr_Assert_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssert'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Assert.typedef = TypeDef('Assert', Node.typedef, 
                     accept=interp2app(descr_Assert_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    test=GetSetProperty(Assert.fget_test, Assert.fset_test ),
                    fail=GetSetProperty(Assert.fget_fail, Assert.fset_fail ),
                    )

class Assign(Node):
    def __init__(self, nodes, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.expr)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        nodelist.append(self.expr)
        return nodelist

    def __repr__(self):
        return "Assign(%s, %s)" % (self.nodes.__repr__(), self.expr.__repr__())

    def accept(self, visitor):
        return visitor.visitAssign(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )
    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_Assign_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssign'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Assign.typedef = TypeDef('Assign', Node.typedef, 
                     accept=interp2app(descr_Assign_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Assign.fget_nodes, Assign.fset_nodes ),
                    expr=GetSetProperty(Assign.fget_expr, Assign.fset_expr ),
                    )

class AugAssign(Node):
    def __init__(self, node, op, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.node = node
        self.op = op
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.node, self.op, self.expr

    def getChildNodes(self):
        return [self.node, self.expr]

    def __repr__(self):
        return "AugAssign(%s, %s, %s)" % (self.node.__repr__(), self.op.__repr__(), self.expr.__repr__())

    def accept(self, visitor):
        return visitor.visitAugAssign(self)

    def fget_node( space, self):
        return space.wrap(self.node)
    def fset_node( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.node = obj
    def fget_op( space, self):
        return space.wrap(self.op)
    def fset_op( space, self, w_arg):
        self.op = space.str_w(w_arg)
    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_AugAssign_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAugAssign'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AugAssign.typedef = TypeDef('AugAssign', Node.typedef, 
                     accept=interp2app(descr_AugAssign_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    node=GetSetProperty(AugAssign.fget_node, AugAssign.fset_node ),
                    op=GetSetProperty(AugAssign.fget_op, AugAssign.fset_op ),
                    expr=GetSetProperty(AugAssign.fget_expr, AugAssign.fset_expr ),
                    )

class UnaryOp(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "UnaryOp()"

    def accept(self, visitor):
        return visitor.visitUnaryOp(self)


def descr_UnaryOp_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitUnaryOp'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

UnaryOp.typedef = TypeDef('UnaryOp', Node.typedef, 
                     accept=interp2app(descr_UnaryOp_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class Backquote(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Backquote(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitBackquote(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_Backquote_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBackquote'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Backquote.typedef = TypeDef('Backquote', UnaryOp.typedef, 
                     accept=interp2app(descr_Backquote_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Backquote.fget_expr, Backquote.fset_expr ),
                    )

class BitOp(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "BitOp()"

    def accept(self, visitor):
        return visitor.visitBitOp(self)


def descr_BitOp_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBitOp'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

BitOp.typedef = TypeDef('BitOp', Node.typedef, 
                     accept=interp2app(descr_BitOp_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class Bitand(BitOp):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Bitand(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitBitand(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_Bitand_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBitand'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Bitand.typedef = TypeDef('Bitand', BitOp.typedef, 
                     accept=interp2app(descr_Bitand_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Bitand.fget_nodes, Bitand.fset_nodes ),
                    )

class Bitor(BitOp):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Bitor(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitBitor(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_Bitor_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBitor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Bitor.typedef = TypeDef('Bitor', BitOp.typedef, 
                     accept=interp2app(descr_Bitor_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Bitor.fget_nodes, Bitor.fset_nodes ),
                    )

class Bitxor(BitOp):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Bitxor(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitBitxor(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_Bitxor_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBitxor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Bitxor.typedef = TypeDef('Bitxor', BitOp.typedef, 
                     accept=interp2app(descr_Bitxor_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Bitxor.fget_nodes, Bitxor.fset_nodes ),
                    )

class Break(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Break()"

    def accept(self, visitor):
        return visitor.visitBreak(self)


def descr_Break_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBreak'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Break.typedef = TypeDef('Break', Node.typedef, 
                     accept=interp2app(descr_Break_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class CallFunc(Node):
    def __init__(self, node, args, star_args = None, dstar_args = None, lineno=-1):
        Node.__init__(self, lineno)
        self.node = node
        self.args = args
        self.star_args = star_args
        self.dstar_args = dstar_args

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.node)
        children.extend(flatten(self.args))
        children.append(self.star_args)
        children.append(self.dstar_args)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.node)
        nodelist.extend(self.args)
        if self.star_args is not None:
            nodelist.append(self.star_args)
        if self.dstar_args is not None:
            nodelist.append(self.dstar_args)
        return nodelist

    def __repr__(self):
        return "CallFunc(%s, %s, %s, %s)" % (self.node.__repr__(), self.args.__repr__(), self.star_args.__repr__(), self.dstar_args.__repr__())

    def accept(self, visitor):
        return visitor.visitCallFunc(self)

    def fget_node( space, self):
        return space.wrap(self.node)
    def fset_node( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.node = obj
    def fget_args( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.args] )
    def fset_args( space, self, w_arg):
        del self.args[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.args.append( space.interpclass_w( w_arg ) )
    def fget_star_args( space, self):
        if self.star_args is None:
            return space.w_None
        else:
            return space.wrap(self.star_args)
    def fset_star_args( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.star_args = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.star_args = obj
    def fget_dstar_args( space, self):
        if self.dstar_args is None:
            return space.w_None
        else:
            return space.wrap(self.dstar_args)
    def fset_dstar_args( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.dstar_args = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.dstar_args = obj

def descr_CallFunc_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitCallFunc'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

CallFunc.typedef = TypeDef('CallFunc', Node.typedef, 
                     accept=interp2app(descr_CallFunc_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    node=GetSetProperty(CallFunc.fget_node, CallFunc.fset_node ),
                    args=GetSetProperty(CallFunc.fget_args, CallFunc.fset_args ),
                    star_args=GetSetProperty(CallFunc.fget_star_args, CallFunc.fset_star_args ),
                    dstar_args=GetSetProperty(CallFunc.fget_dstar_args, CallFunc.fset_dstar_args ),
                    )

class Class(Node):
    def __init__(self, name, bases, w_doc, code, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.bases = bases
        self.w_doc = w_doc
        self.code = code

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.name)
        children.extend(flatten(self.bases))
        children.append(self.w_doc)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.bases)
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Class(%s, %s, %s, %s)" % (self.name.__repr__(), self.bases.__repr__(), self.w_doc.__repr__(), self.code.__repr__())

    def accept(self, visitor):
        return visitor.visitClass(self)

    def fget_name( space, self):
        return space.wrap(self.name)
    def fset_name( space, self, w_arg):
        self.name = space.str_w(w_arg)
    def fget_bases( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.bases] )
    def fset_bases( space, self, w_arg):
        del self.bases[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.bases.append( space.interpclass_w( w_arg ) )
    def fget_w_doc( space, self):
        return self.w_doc
    def fset_w_doc( space, self, w_arg):
        self.w_doc = w_arg
    def fget_code( space, self):
        return space.wrap(self.code)
    def fset_code( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.code = obj

def descr_Class_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitClass'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Class.typedef = TypeDef('Class', Node.typedef, 
                     accept=interp2app(descr_Class_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    name=GetSetProperty(Class.fget_name, Class.fset_name ),
                    bases=GetSetProperty(Class.fget_bases, Class.fset_bases ),
                    w_doc=GetSetProperty(Class.fget_w_doc, Class.fset_w_doc ),
                    code=GetSetProperty(Class.fget_code, Class.fset_code ),
                    )

class Compare(Node):
    def __init__(self, expr, ops, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        # ops is a list of couples (op_name, node)
        self.ops = ops

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.extend(flatten(self.ops))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        # ops is a list of couples (op_name, node)
        for op_name, node in self.ops:
            nodelist.append(node)
        return nodelist

    def fset_ops( space, self, w_arg ):
        del self.ops[:]
        for w_obj in space.unpackiterable( w_arg ):
            w_opname = space.getitem( w_obj, space.wrap(0) )
            w_node = space.getitem( w_obj, space.wrap(1) )
            ops = space.str_w(w_opname)
            node = space.interpclass_w( w_node )
            if not isinstance(node, Node):
               raise OperationError(space.w_TypeError, space.wrap("ops must be a list of (name,node)"))
            self.ops.append( (ops,node) )
    

    def fget_ops( space, self ):
        lst = []
        for op_name, node in self.ops:
            lst.append( space.newtuple( [ space.wrap(op_name), space.wrap(node) ] ) )
        return space.newlist( lst )
    

    def __repr__(self):
        return "Compare(%s, %s)" % (self.expr.__repr__(), self.ops.__repr__())

    def accept(self, visitor):
        return visitor.visitCompare(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_Compare_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitCompare'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Compare.typedef = TypeDef('Compare', Node.typedef, 
                     accept=interp2app(descr_Compare_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Compare.fget_expr, Compare.fset_expr ),
                    ops=GetSetProperty(Compare.fget_ops, Compare.fset_ops ),
                    )

class Const(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        "NOT_RPYTHON"
        return self.value,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Const(%s)" % (self.value.__repr__(),)

    def accept(self, visitor):
        return visitor.visitConst(self)

    def fget_value( space, self):
        return self.value
    def fset_value( space, self, w_arg):
        self.value = w_arg

def descr_Const_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitConst'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Const.typedef = TypeDef('Const', Node.typedef, 
                     accept=interp2app(descr_Const_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    value=GetSetProperty(Const.fget_value, Const.fset_value ),
                    )

class Continue(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Continue()"

    def accept(self, visitor):
        return visitor.visitContinue(self)


def descr_Continue_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitContinue'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Continue.typedef = TypeDef('Continue', Node.typedef, 
                     accept=interp2app(descr_Continue_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class Decorators(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Decorators(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitDecorators(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_Decorators_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitDecorators'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Decorators.typedef = TypeDef('Decorators', Node.typedef, 
                     accept=interp2app(descr_Decorators_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Decorators.fget_nodes, Decorators.fset_nodes ),
                    )

class Dict(Node):
    def __init__(self, items, lineno=-1):
        Node.__init__(self, lineno)
        # items is a list of couples (node (key), node (value))
        self.items = items

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.items))

    def getChildNodes(self):
        nodelist = []
        # items is a list of couples (node (key), node (value))
        for key, value in self.items:
            nodelist.append(key)
            nodelist.append(value)
        return nodelist

    def fset_items( space, self, w_arg ):
        del self.items[:]
        for w_tup in space.unpackiterable( w_arg ):
            w_key = space.getitem( w_tup, space.wrap(0) )
            w_value = space.getitem( w_tup, space.wrap(1) )
            key = space.interpclass_w( w_key )
            value = space.interpclass_w( w_value )
            if not isinstance( key, Node ) or not isinstance( value, Node ):
                raise OperationError(space.w_TypeError, space.wrap("Need a list of (key node, value node)"))
            self.items.append( (key,value) )
    

    def fget_items( space, self ):
        return space.newlist( [ space.newtuple( [ space.wrap(key), space.wrap(value) ] )
                                for key, value in self.items ] )
    

    def __repr__(self):
        return "Dict(%s)" % (self.items.__repr__(),)

    def accept(self, visitor):
        return visitor.visitDict(self)


def descr_Dict_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitDict'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Dict.typedef = TypeDef('Dict', Node.typedef, 
                     accept=interp2app(descr_Dict_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    items=GetSetProperty(Dict.fget_items, Dict.fset_items ),
                    )

class Discard(Node):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Discard(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitDiscard(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_Discard_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitDiscard'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Discard.typedef = TypeDef('Discard', Node.typedef, 
                     accept=interp2app(descr_Discard_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Discard.fget_expr, Discard.fset_expr ),
                    )

class Div(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Div(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitDiv(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_Div_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitDiv'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Div.typedef = TypeDef('Div', BinaryOp.typedef, 
                     accept=interp2app(descr_Div_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(Div.fget_left, Div.fset_left ),
                    right=GetSetProperty(Div.fget_right, Div.fset_right ),
                    )

class Ellipsis(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Ellipsis()"

    def accept(self, visitor):
        return visitor.visitEllipsis(self)


def descr_Ellipsis_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitEllipsis'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Ellipsis.typedef = TypeDef('Ellipsis', Node.typedef, 
                     accept=interp2app(descr_Ellipsis_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class Exec(Node):
    def __init__(self, expr, locals, globals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.locals = locals
        self.globals = globals

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.append(self.locals)
        children.append(self.globals)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.locals is not None:
            nodelist.append(self.locals)
        if self.globals is not None:
            nodelist.append(self.globals)
        return nodelist

    def __repr__(self):
        return "Exec(%s, %s, %s)" % (self.expr.__repr__(), self.locals.__repr__(), self.globals.__repr__())

    def accept(self, visitor):
        return visitor.visitExec(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj
    def fget_locals( space, self):
        if self.locals is None:
            return space.w_None
        else:
            return space.wrap(self.locals)
    def fset_locals( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.locals = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.locals = obj
    def fget_globals( space, self):
        if self.globals is None:
            return space.w_None
        else:
            return space.wrap(self.globals)
    def fset_globals( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.globals = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.globals = obj

def descr_Exec_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitExec'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Exec.typedef = TypeDef('Exec', Node.typedef, 
                     accept=interp2app(descr_Exec_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Exec.fget_expr, Exec.fset_expr ),
                    locals=GetSetProperty(Exec.fget_locals, Exec.fset_locals ),
                    globals=GetSetProperty(Exec.fget_globals, Exec.fset_globals ),
                    )

class FloorDiv(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "FloorDiv(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitFloorDiv(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_FloorDiv_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitFloorDiv'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

FloorDiv.typedef = TypeDef('FloorDiv', BinaryOp.typedef, 
                     accept=interp2app(descr_FloorDiv_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(FloorDiv.fget_left, FloorDiv.fset_left ),
                    right=GetSetProperty(FloorDiv.fget_right, FloorDiv.fset_right ),
                    )

class For(Node):
    def __init__(self, assign, list, body, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.list = list
        self.body = body
        self.else_ = else_

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "For(%s, %s, %s, %s)" % (self.assign.__repr__(), self.list.__repr__(), self.body.__repr__(), self.else_.__repr__())

    def accept(self, visitor):
        return visitor.visitFor(self)

    def fget_assign( space, self):
        return space.wrap(self.assign)
    def fset_assign( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.assign = obj
    def fget_list( space, self):
        return space.wrap(self.list)
    def fset_list( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.list = obj
    def fget_body( space, self):
        return space.wrap(self.body)
    def fset_body( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.body = obj
    def fget_else_( space, self):
        if self.else_ is None:
            return space.w_None
        else:
            return space.wrap(self.else_)
    def fset_else_( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.else_ = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.else_ = obj

def descr_For_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitFor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

For.typedef = TypeDef('For', Node.typedef, 
                     accept=interp2app(descr_For_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    assign=GetSetProperty(For.fget_assign, For.fset_assign ),
                    list=GetSetProperty(For.fget_list, For.fset_list ),
                    body=GetSetProperty(For.fget_body, For.fset_body ),
                    else_=GetSetProperty(For.fget_else_, For.fset_else_ ),
                    )

class From(Node):
    def __init__(self, modname, names, lineno=-1):
        Node.__init__(self, lineno)
        self.modname = modname
        self.names = names

    def getChildren(self):
        "NOT_RPYTHON"
        return self.modname, self.names

    def getChildNodes(self):
        return []

    def fget_names( space, self ):
        return space.newlist( [ space.newtuple( [ space.wrap(name), space.wrap(as_name) ] )
                                for name, as_name in self.names ] )
    

    def fset_names( space, self, w_arg ):
        del self.names[:]
        for w_tup in space.unpackiterable( w_arg ):
            w_name = space.getitem( w_tup, space.wrap(0) ) 
            w_as_name = space.getitem( w_tup, space.wrap(1) )
            name = space.str_w( w_name )
            as_name = None
            if not space.is_w( w_as_name, space.w_None ):
                as_name = space.str_w( w_as_name )
            self.names.append( (name, as_name) )
    

    def __repr__(self):
        return "From(%s, %s)" % (self.modname.__repr__(), self.names.__repr__())

    def accept(self, visitor):
        return visitor.visitFrom(self)

    def fget_modname( space, self):
        return space.wrap(self.modname)
    def fset_modname( space, self, w_arg):
        self.modname = space.str_w(w_arg)

def descr_From_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitFrom'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

From.typedef = TypeDef('From', Node.typedef, 
                     accept=interp2app(descr_From_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    modname=GetSetProperty(From.fget_modname, From.fset_modname ),
                    names=GetSetProperty(From.fget_names, From.fset_names ),
                    )

class Function(AbstractFunction):
    def __init__(self, decorators, name, argnames, defaults, flags, w_doc, code, lineno=-1):
        Node.__init__(self, lineno)
        self.decorators = decorators
        self.name = name
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.w_doc = w_doc
        self.code = code
        self.varargs = self.kwargs = 0
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1
    


    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.decorators)
        children.append(self.name)
        children.extend(flatten(self.argnames))
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.w_doc)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.decorators is not None:
            nodelist.append(self.decorators)
        nodelist.extend(self.argnames)
        nodelist.extend(self.defaults)
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Function(%s, %s, %s, %s, %s, %s, %s)" % (self.decorators.__repr__(), self.name.__repr__(), self.argnames.__repr__(), self.defaults.__repr__(), self.flags.__repr__(), self.w_doc.__repr__(), self.code.__repr__())

    def accept(self, visitor):
        return visitor.visitFunction(self)

    def fget_decorators( space, self):
        if self.decorators is None:
            return space.w_None
        else:
            return space.wrap(self.decorators)
    def fset_decorators( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.decorators = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.decorators = obj
    def fget_name( space, self):
        return space.wrap(self.name)
    def fset_name( space, self, w_arg):
        self.name = space.str_w(w_arg)
    def fget_argnames( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.argnames] )
    def fset_argnames( space, self, w_arg):
        del self.argnames[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.argnames.append( space.interpclass_w( w_arg ) )
    def fget_defaults( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.defaults] )
    def fset_defaults( space, self, w_arg):
        del self.defaults[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.defaults.append( space.interpclass_w( w_arg ) )
    def fget_flags( space, self):
        return space.wrap(self.flags)
    def fset_flags( space, self, w_arg):
        self.flags = space.int_w(w_arg)
    def fget_w_doc( space, self):
        return self.w_doc
    def fset_w_doc( space, self, w_arg):
        self.w_doc = w_arg
    def fget_code( space, self):
        return space.wrap(self.code)
    def fset_code( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.code = obj

def descr_Function_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitFunction'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Function.typedef = TypeDef('Function', AbstractFunction.typedef, 
                     accept=interp2app(descr_Function_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    decorators=GetSetProperty(Function.fget_decorators, Function.fset_decorators ),
                    name=GetSetProperty(Function.fget_name, Function.fset_name ),
                    argnames=GetSetProperty(Function.fget_argnames, Function.fset_argnames ),
                    defaults=GetSetProperty(Function.fget_defaults, Function.fset_defaults ),
                    flags=GetSetProperty(Function.fget_flags, Function.fset_flags ),
                    w_doc=GetSetProperty(Function.fget_w_doc, Function.fset_w_doc ),
                    code=GetSetProperty(Function.fget_code, Function.fset_code ),
                    )

class GenExpr(AbstractFunction):
    def __init__(self, code, lineno=-1):
        Node.__init__(self, lineno)
        self.code = code
        self.argnames = [AssName('[outmost-iterable]', OP_ASSIGN)]
        self.varargs = self.kwargs = 0
    


    def getChildren(self):
        "NOT_RPYTHON"
        return self.code,

    def getChildNodes(self):
        return [self.code,]

    def __repr__(self):
        return "GenExpr(%s)" % (self.code.__repr__(),)

    def accept(self, visitor):
        return visitor.visitGenExpr(self)

    def fget_code( space, self):
        return space.wrap(self.code)
    def fset_code( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.code = obj

def descr_GenExpr_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGenExpr'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

GenExpr.typedef = TypeDef('GenExpr', AbstractFunction.typedef, 
                     accept=interp2app(descr_GenExpr_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    code=GetSetProperty(GenExpr.fget_code, GenExpr.fset_code ),
                    )

class GenExprFor(Node):
    def __init__(self, assign, iter, ifs, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.iter = iter
        self.ifs = ifs
        self.is_outmost = False
    


    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.assign)
        children.append(self.iter)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.iter)
        nodelist.extend(self.ifs)
        return nodelist

    def __repr__(self):
        return "GenExprFor(%s, %s, %s)" % (self.assign.__repr__(), self.iter.__repr__(), self.ifs.__repr__())

    def accept(self, visitor):
        return visitor.visitGenExprFor(self)

    def fget_assign( space, self):
        return space.wrap(self.assign)
    def fset_assign( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.assign = obj
    def fget_iter( space, self):
        return space.wrap(self.iter)
    def fset_iter( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.iter = obj
    def fget_ifs( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.ifs] )
    def fset_ifs( space, self, w_arg):
        del self.ifs[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.ifs.append( space.interpclass_w( w_arg ) )

def descr_GenExprFor_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGenExprFor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

GenExprFor.typedef = TypeDef('GenExprFor', Node.typedef, 
                     accept=interp2app(descr_GenExprFor_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    assign=GetSetProperty(GenExprFor.fget_assign, GenExprFor.fset_assign ),
                    iter=GetSetProperty(GenExprFor.fget_iter, GenExprFor.fset_iter ),
                    ifs=GetSetProperty(GenExprFor.fget_ifs, GenExprFor.fset_ifs ),
                    )

class GenExprIf(Node):
    def __init__(self, test, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test

    def getChildren(self):
        "NOT_RPYTHON"
        return self.test,

    def getChildNodes(self):
        return [self.test,]

    def __repr__(self):
        return "GenExprIf(%s)" % (self.test.__repr__(),)

    def accept(self, visitor):
        return visitor.visitGenExprIf(self)

    def fget_test( space, self):
        return space.wrap(self.test)
    def fset_test( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.test = obj

def descr_GenExprIf_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGenExprIf'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

GenExprIf.typedef = TypeDef('GenExprIf', Node.typedef, 
                     accept=interp2app(descr_GenExprIf_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    test=GetSetProperty(GenExprIf.fget_test, GenExprIf.fset_test ),
                    )

class GenExprInner(Node):
    def __init__(self, expr, quals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.quals = quals

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(self.quals)
        return nodelist

    def __repr__(self):
        return "GenExprInner(%s, %s)" % (self.expr.__repr__(), self.quals.__repr__())

    def accept(self, visitor):
        return visitor.visitGenExprInner(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj
    def fget_quals( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.quals] )
    def fset_quals( space, self, w_arg):
        del self.quals[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.quals.append( space.interpclass_w( w_arg ) )

def descr_GenExprInner_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGenExprInner'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

GenExprInner.typedef = TypeDef('GenExprInner', Node.typedef, 
                     accept=interp2app(descr_GenExprInner_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(GenExprInner.fget_expr, GenExprInner.fset_expr ),
                    quals=GetSetProperty(GenExprInner.fget_quals, GenExprInner.fset_quals ),
                    )

class Getattr(Node):
    def __init__(self, expr, attrname, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.attrname = attrname

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr, self.attrname

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Getattr(%s, %s)" % (self.expr.__repr__(), self.attrname.__repr__())

    def accept(self, visitor):
        return visitor.visitGetattr(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj
    def fget_attrname( space, self):
        return space.wrap(self.attrname)
    def fset_attrname( space, self, w_arg):
        self.attrname = space.str_w(w_arg)

def descr_Getattr_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGetattr'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Getattr.typedef = TypeDef('Getattr', Node.typedef, 
                     accept=interp2app(descr_Getattr_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Getattr.fget_expr, Getattr.fset_expr ),
                    attrname=GetSetProperty(Getattr.fget_attrname, Getattr.fset_attrname ),
                    )

class Global(Node):
    def __init__(self, names, lineno=-1):
        Node.__init__(self, lineno)
        self.names = names

    def getChildren(self):
        "NOT_RPYTHON"
        return self.names,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Global(%s)" % (self.names.__repr__(),)

    def accept(self, visitor):
        return visitor.visitGlobal(self)

    def fget_names( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.names] )
    def fset_names( space, self, w_arg):
        del self.names[:]
        for itm in space.unpackiterable(w_arg):
            self.names.append( space.str_w(itm) )

def descr_Global_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGlobal'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Global.typedef = TypeDef('Global', Node.typedef, 
                     accept=interp2app(descr_Global_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    names=GetSetProperty(Global.fget_names, Global.fset_names ),
                    )

class If(Node):
    def __init__(self, tests, else_, lineno=-1):
        Node.__init__(self, lineno)
        # tests is a list of couples (node (test), node (suite))
        self.tests = tests
        self.else_ = else_

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.tests))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        # tests is a list of couples (node (test), node (suite))
        for test, suite in self.tests:
            nodelist.append(test)
            nodelist.append(suite)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def fset_tests( space, self, w_arg ):
        del self.tests[:]
        for w_tup in space.unpackiterable( w_arg ):
            w_test = space.getitem( w_tup, space.wrap(0) )
            w_suite = space.getitem( w_tup, space.wrap(1) )
            test = space.interpclass_w( w_test )
            suite = space.interpclass_w( w_suite )
            if not isinstance( test, Node ) or not isinstance( suite, Node ):
                raise OperationError(space.w_TypeError, space.wrap("Need a list of (test,suite) nodes") )
            self.tests.append( (test,suite) )
    
    
    

    def fget_tests( space, self ):
        return space.newlist( [ space.newtuple( [ space.wrap(test),
                                                  space.wrap(suite) ] )
                                for test, suite in self.tests ] )
    

    def __repr__(self):
        return "If(%s, %s)" % (self.tests.__repr__(), self.else_.__repr__())

    def accept(self, visitor):
        return visitor.visitIf(self)

    def fget_else_( space, self):
        if self.else_ is None:
            return space.w_None
        else:
            return space.wrap(self.else_)
    def fset_else_( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.else_ = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.else_ = obj

def descr_If_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitIf'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

If.typedef = TypeDef('If', Node.typedef, 
                     accept=interp2app(descr_If_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    tests=GetSetProperty(If.fget_tests, If.fset_tests ),
                    else_=GetSetProperty(If.fget_else_, If.fset_else_ ),
                    )

class Import(Node):
    def __init__(self, names, lineno=-1):
        Node.__init__(self, lineno)
        self.names = names

    def getChildren(self):
        "NOT_RPYTHON"
        return self.names,

    def getChildNodes(self):
        return []

    def fget_names( space, self ):
        return space.newlist( [ space.newtuple( [ space.wrap(name), space.wrap(as_name) ] )
                                for name, as_name in self.names ] )
    

    def fset_names( space, self, w_arg ):
        del self.names[:]
        for w_tup in space.unpackiterable( w_arg ):
            w_name = space.getitem( w_tup, space.wrap(0) ) 
            w_as_name = space.getitem( w_tup, space.wrap(1) )
            name = space.str_w( w_name )
            as_name = None
            if not space.is_w( w_as_name, space.w_None ):
                as_name = space.str_w( w_as_name )
            self.names.append( (name, as_name) )
    

    def __repr__(self):
        return "Import(%s)" % (self.names.__repr__(),)

    def accept(self, visitor):
        return visitor.visitImport(self)


def descr_Import_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitImport'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Import.typedef = TypeDef('Import', Node.typedef, 
                     accept=interp2app(descr_Import_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    names=GetSetProperty(Import.fget_names, Import.fset_names ),
                    )

class Invert(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Invert(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitInvert(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_Invert_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitInvert'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Invert.typedef = TypeDef('Invert', UnaryOp.typedef, 
                     accept=interp2app(descr_Invert_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Invert.fget_expr, Invert.fset_expr ),
                    )

class Keyword(Node):
    def __init__(self, name, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.name, self.expr

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Keyword(%s, %s)" % (self.name.__repr__(), self.expr.__repr__())

    def accept(self, visitor):
        return visitor.visitKeyword(self)

    def fget_name( space, self):
        return space.wrap(self.name)
    def fset_name( space, self, w_arg):
        self.name = space.str_w(w_arg)
    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_Keyword_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitKeyword'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Keyword.typedef = TypeDef('Keyword', Node.typedef, 
                     accept=interp2app(descr_Keyword_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    name=GetSetProperty(Keyword.fget_name, Keyword.fset_name ),
                    expr=GetSetProperty(Keyword.fget_expr, Keyword.fset_expr ),
                    )

class Lambda(AbstractFunction):
    def __init__(self, argnames, defaults, flags, code, lineno=-1):
        Node.__init__(self, lineno)
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.code = code
        self.varargs = self.kwargs = 0
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1
    


    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.argnames))
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.argnames)
        nodelist.extend(self.defaults)
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Lambda(%s, %s, %s, %s)" % (self.argnames.__repr__(), self.defaults.__repr__(), self.flags.__repr__(), self.code.__repr__())

    def accept(self, visitor):
        return visitor.visitLambda(self)

    def fget_argnames( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.argnames] )
    def fset_argnames( space, self, w_arg):
        del self.argnames[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.argnames.append( space.interpclass_w( w_arg ) )
    def fget_defaults( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.defaults] )
    def fset_defaults( space, self, w_arg):
        del self.defaults[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.defaults.append( space.interpclass_w( w_arg ) )
    def fget_flags( space, self):
        return space.wrap(self.flags)
    def fset_flags( space, self, w_arg):
        self.flags = space.int_w(w_arg)
    def fget_code( space, self):
        return space.wrap(self.code)
    def fset_code( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.code = obj

def descr_Lambda_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitLambda'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Lambda.typedef = TypeDef('Lambda', AbstractFunction.typedef, 
                     accept=interp2app(descr_Lambda_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    argnames=GetSetProperty(Lambda.fget_argnames, Lambda.fset_argnames ),
                    defaults=GetSetProperty(Lambda.fget_defaults, Lambda.fset_defaults ),
                    flags=GetSetProperty(Lambda.fget_flags, Lambda.fset_flags ),
                    code=GetSetProperty(Lambda.fget_code, Lambda.fset_code ),
                    )

class LeftShift(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "LeftShift(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitLeftShift(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_LeftShift_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitLeftShift'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

LeftShift.typedef = TypeDef('LeftShift', BinaryOp.typedef, 
                     accept=interp2app(descr_LeftShift_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(LeftShift.fget_left, LeftShift.fset_left ),
                    right=GetSetProperty(LeftShift.fget_right, LeftShift.fset_right ),
                    )

class List(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "List(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitList(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_List_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitList'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

List.typedef = TypeDef('List', Node.typedef, 
                     accept=interp2app(descr_List_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(List.fget_nodes, List.fset_nodes ),
                    )

class ListComp(Node):
    def __init__(self, expr, quals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.quals = quals

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(self.quals)
        return nodelist

    def __repr__(self):
        return "ListComp(%s, %s)" % (self.expr.__repr__(), self.quals.__repr__())

    def accept(self, visitor):
        return visitor.visitListComp(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj
    def fget_quals( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.quals] )
    def fset_quals( space, self, w_arg):
        del self.quals[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.quals.append( space.interpclass_w( w_arg ) )

def descr_ListComp_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitListComp'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

ListComp.typedef = TypeDef('ListComp', Node.typedef, 
                     accept=interp2app(descr_ListComp_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(ListComp.fget_expr, ListComp.fset_expr ),
                    quals=GetSetProperty(ListComp.fget_quals, ListComp.fset_quals ),
                    )

class ListCompFor(Node):
    def __init__(self, assign, list, ifs, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.list = list
        self.ifs = ifs

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.extend(self.ifs)
        return nodelist

    def __repr__(self):
        return "ListCompFor(%s, %s, %s)" % (self.assign.__repr__(), self.list.__repr__(), self.ifs.__repr__())

    def accept(self, visitor):
        return visitor.visitListCompFor(self)

    def fget_assign( space, self):
        return space.wrap(self.assign)
    def fset_assign( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.assign = obj
    def fget_list( space, self):
        return space.wrap(self.list)
    def fset_list( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.list = obj
    def fget_ifs( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.ifs] )
    def fset_ifs( space, self, w_arg):
        del self.ifs[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.ifs.append( space.interpclass_w( w_arg ) )

def descr_ListCompFor_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitListCompFor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

ListCompFor.typedef = TypeDef('ListCompFor', Node.typedef, 
                     accept=interp2app(descr_ListCompFor_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    assign=GetSetProperty(ListCompFor.fget_assign, ListCompFor.fset_assign ),
                    list=GetSetProperty(ListCompFor.fget_list, ListCompFor.fset_list ),
                    ifs=GetSetProperty(ListCompFor.fget_ifs, ListCompFor.fset_ifs ),
                    )

class ListCompIf(Node):
    def __init__(self, test, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test

    def getChildren(self):
        "NOT_RPYTHON"
        return self.test,

    def getChildNodes(self):
        return [self.test,]

    def __repr__(self):
        return "ListCompIf(%s)" % (self.test.__repr__(),)

    def accept(self, visitor):
        return visitor.visitListCompIf(self)

    def fget_test( space, self):
        return space.wrap(self.test)
    def fset_test( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.test = obj

def descr_ListCompIf_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitListCompIf'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

ListCompIf.typedef = TypeDef('ListCompIf', Node.typedef, 
                     accept=interp2app(descr_ListCompIf_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    test=GetSetProperty(ListCompIf.fget_test, ListCompIf.fset_test ),
                    )

class Mod(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Mod(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitMod(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_Mod_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitMod'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Mod.typedef = TypeDef('Mod', BinaryOp.typedef, 
                     accept=interp2app(descr_Mod_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(Mod.fget_left, Mod.fset_left ),
                    right=GetSetProperty(Mod.fget_right, Mod.fset_right ),
                    )

class Module(Node):
    def __init__(self, w_doc, node, lineno=-1):
        Node.__init__(self, lineno)
        self.w_doc = w_doc
        self.node = node

    def getChildren(self):
        "NOT_RPYTHON"
        return self.w_doc, self.node

    def getChildNodes(self):
        return [self.node,]

    def __repr__(self):
        return "Module(%s, %s)" % (self.w_doc.__repr__(), self.node.__repr__())

    def accept(self, visitor):
        return visitor.visitModule(self)

    def fget_w_doc( space, self):
        return self.w_doc
    def fset_w_doc( space, self, w_arg):
        self.w_doc = w_arg
    def fget_node( space, self):
        return space.wrap(self.node)
    def fset_node( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.node = obj

def descr_Module_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitModule'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Module.typedef = TypeDef('Module', Node.typedef, 
                     accept=interp2app(descr_Module_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    w_doc=GetSetProperty(Module.fget_w_doc, Module.fset_w_doc ),
                    node=GetSetProperty(Module.fget_node, Module.fset_node ),
                    )

class Mul(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Mul(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitMul(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_Mul_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitMul'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Mul.typedef = TypeDef('Mul', BinaryOp.typedef, 
                     accept=interp2app(descr_Mul_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(Mul.fget_left, Mul.fset_left ),
                    right=GetSetProperty(Mul.fget_right, Mul.fset_right ),
                    )

class Name(Node):
    def __init__(self, varname, lineno=-1):
        Node.__init__(self, lineno)
        self.varname = varname

    def getChildren(self):
        "NOT_RPYTHON"
        return self.varname,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Name(%s)" % (self.varname.__repr__(),)

    def accept(self, visitor):
        return visitor.visitName(self)

    def fget_varname( space, self):
        return space.wrap(self.varname)
    def fset_varname( space, self, w_arg):
        self.varname = space.str_w(w_arg)

def descr_Name_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitName'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Name.typedef = TypeDef('Name', Node.typedef, 
                     accept=interp2app(descr_Name_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    varname=GetSetProperty(Name.fget_varname, Name.fset_varname ),
                    )

class NoneConst(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "NoneConst()"

    def accept(self, visitor):
        return visitor.visitNoneConst(self)


def descr_NoneConst_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitNoneConst'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

NoneConst.typedef = TypeDef('NoneConst', Node.typedef, 
                     accept=interp2app(descr_NoneConst_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class Not(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Not(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitNot(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_Not_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitNot'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Not.typedef = TypeDef('Not', UnaryOp.typedef, 
                     accept=interp2app(descr_Not_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Not.fget_expr, Not.fset_expr ),
                    )

class Or(AbstractTest):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Or(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitOr(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_Or_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitOr'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Or.typedef = TypeDef('Or', AbstractTest.typedef, 
                     accept=interp2app(descr_Or_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Or.fget_nodes, Or.fset_nodes ),
                    )

class Pass(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Pass()"

    def accept(self, visitor):
        return visitor.visitPass(self)


def descr_Pass_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitPass'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Pass.typedef = TypeDef('Pass', Node.typedef, 
                     accept=interp2app(descr_Pass_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    )

class Power(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Power(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitPower(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_Power_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitPower'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Power.typedef = TypeDef('Power', BinaryOp.typedef, 
                     accept=interp2app(descr_Power_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(Power.fget_left, Power.fset_left ),
                    right=GetSetProperty(Power.fget_right, Power.fset_right ),
                    )

class Print(Node):
    def __init__(self, nodes, dest, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.dest = dest

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        if self.dest is not None:
            nodelist.append(self.dest)
        return nodelist

    def __repr__(self):
        return "Print(%s, %s)" % (self.nodes.__repr__(), self.dest.__repr__())

    def accept(self, visitor):
        return visitor.visitPrint(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )
    def fget_dest( space, self):
        if self.dest is None:
            return space.w_None
        else:
            return space.wrap(self.dest)
    def fset_dest( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.dest = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.dest = obj

def descr_Print_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitPrint'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Print.typedef = TypeDef('Print', Node.typedef, 
                     accept=interp2app(descr_Print_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Print.fget_nodes, Print.fset_nodes ),
                    dest=GetSetProperty(Print.fget_dest, Print.fset_dest ),
                    )

class Printnl(Node):
    def __init__(self, nodes, dest, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.dest = dest

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        if self.dest is not None:
            nodelist.append(self.dest)
        return nodelist

    def __repr__(self):
        return "Printnl(%s, %s)" % (self.nodes.__repr__(), self.dest.__repr__())

    def accept(self, visitor):
        return visitor.visitPrintnl(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )
    def fget_dest( space, self):
        if self.dest is None:
            return space.w_None
        else:
            return space.wrap(self.dest)
    def fset_dest( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.dest = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.dest = obj

def descr_Printnl_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitPrintnl'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Printnl.typedef = TypeDef('Printnl', Node.typedef, 
                     accept=interp2app(descr_Printnl_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Printnl.fget_nodes, Printnl.fset_nodes ),
                    dest=GetSetProperty(Printnl.fget_dest, Printnl.fset_dest ),
                    )

class Raise(Node):
    def __init__(self, expr1, expr2, expr3, lineno=-1):
        Node.__init__(self, lineno)
        self.expr1 = expr1
        self.expr2 = expr2
        self.expr3 = expr3

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr1)
        children.append(self.expr2)
        children.append(self.expr3)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.expr1 is not None:
            nodelist.append(self.expr1)
        if self.expr2 is not None:
            nodelist.append(self.expr2)
        if self.expr3 is not None:
            nodelist.append(self.expr3)
        return nodelist

    def __repr__(self):
        return "Raise(%s, %s, %s)" % (self.expr1.__repr__(), self.expr2.__repr__(), self.expr3.__repr__())

    def accept(self, visitor):
        return visitor.visitRaise(self)

    def fget_expr1( space, self):
        if self.expr1 is None:
            return space.w_None
        else:
            return space.wrap(self.expr1)
    def fset_expr1( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.expr1 = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.expr1 = obj
    def fget_expr2( space, self):
        if self.expr2 is None:
            return space.w_None
        else:
            return space.wrap(self.expr2)
    def fset_expr2( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.expr2 = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.expr2 = obj
    def fget_expr3( space, self):
        if self.expr3 is None:
            return space.w_None
        else:
            return space.wrap(self.expr3)
    def fset_expr3( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.expr3 = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.expr3 = obj

def descr_Raise_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitRaise'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Raise.typedef = TypeDef('Raise', Node.typedef, 
                     accept=interp2app(descr_Raise_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr1=GetSetProperty(Raise.fget_expr1, Raise.fset_expr1 ),
                    expr2=GetSetProperty(Raise.fget_expr2, Raise.fset_expr2 ),
                    expr3=GetSetProperty(Raise.fget_expr3, Raise.fset_expr3 ),
                    )

class Return(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        "NOT_RPYTHON"
        return (self.value,)

    def getChildNodes(self):
        nodelist = []
        if self.value is not None:
            nodelist.append(self.value)
        return nodelist

    def __repr__(self):
        return "Return(%s)" % (self.value.__repr__(),)

    def accept(self, visitor):
        return visitor.visitReturn(self)

    def fget_value( space, self):
        if self.value is None:
            return space.w_None
        else:
            return space.wrap(self.value)
    def fset_value( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.value = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.value = obj

def descr_Return_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitReturn'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Return.typedef = TypeDef('Return', Node.typedef, 
                     accept=interp2app(descr_Return_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    value=GetSetProperty(Return.fget_value, Return.fset_value ),
                    )

class RightShift(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "RightShift(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitRightShift(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_RightShift_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitRightShift'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

RightShift.typedef = TypeDef('RightShift', BinaryOp.typedef, 
                     accept=interp2app(descr_RightShift_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(RightShift.fget_left, RightShift.fset_left ),
                    right=GetSetProperty(RightShift.fget_right, RightShift.fset_right ),
                    )

class Slice(Node):
    def __init__(self, expr, flags, lower, upper, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.flags = flags
        self.lower = lower
        self.upper = upper

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.append(self.lower)
        children.append(self.upper)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.lower is not None:
            nodelist.append(self.lower)
        if self.upper is not None:
            nodelist.append(self.upper)
        return nodelist

    def __repr__(self):
        return "Slice(%s, %s, %s, %s)" % (self.expr.__repr__(), self.flags.__repr__(), self.lower.__repr__(), self.upper.__repr__())

    def accept(self, visitor):
        return visitor.visitSlice(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj
    def fget_flags( space, self):
        return space.wrap(self.flags)
    def fset_flags( space, self, w_arg):
        self.flags = space.int_w(w_arg)
    def fget_lower( space, self):
        if self.lower is None:
            return space.w_None
        else:
            return space.wrap(self.lower)
    def fset_lower( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.lower = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.lower = obj
    def fget_upper( space, self):
        if self.upper is None:
            return space.w_None
        else:
            return space.wrap(self.upper)
    def fset_upper( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.upper = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.upper = obj

def descr_Slice_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitSlice'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Slice.typedef = TypeDef('Slice', Node.typedef, 
                     accept=interp2app(descr_Slice_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Slice.fget_expr, Slice.fset_expr ),
                    flags=GetSetProperty(Slice.fget_flags, Slice.fset_flags ),
                    lower=GetSetProperty(Slice.fget_lower, Slice.fset_lower ),
                    upper=GetSetProperty(Slice.fget_upper, Slice.fset_upper ),
                    )

class Sliceobj(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Sliceobj(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitSliceobj(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_Sliceobj_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitSliceobj'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Sliceobj.typedef = TypeDef('Sliceobj', Node.typedef, 
                     accept=interp2app(descr_Sliceobj_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Sliceobj.fget_nodes, Sliceobj.fset_nodes ),
                    )

class Stmt(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Stmt(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitStmt(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_Stmt_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitStmt'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Stmt.typedef = TypeDef('Stmt', Node.typedef, 
                     accept=interp2app(descr_Stmt_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Stmt.fget_nodes, Stmt.fset_nodes ),
                    )

class Sub(BinaryOp):
    def __init__(self, left, right, lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Sub(%s, %s)" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitSub(self)

    def fget_left( space, self):
        return space.wrap(self.left)
    def fset_left( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.left = obj
    def fget_right( space, self):
        return space.wrap(self.right)
    def fset_right( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.right = obj

def descr_Sub_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitSub'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Sub.typedef = TypeDef('Sub', BinaryOp.typedef, 
                     accept=interp2app(descr_Sub_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    left=GetSetProperty(Sub.fget_left, Sub.fset_left ),
                    right=GetSetProperty(Sub.fget_right, Sub.fset_right ),
                    )

class Subscript(Node):
    def __init__(self, expr, flags, subs, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.flags = flags
        self.subs = subs

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.extend(flatten(self.subs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(self.subs)
        return nodelist

    def __repr__(self):
        return "Subscript(%s, %s, %s)" % (self.expr.__repr__(), self.flags.__repr__(), self.subs.__repr__())

    def accept(self, visitor):
        return visitor.visitSubscript(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj
    def fget_flags( space, self):
        return space.wrap(self.flags)
    def fset_flags( space, self, w_arg):
        self.flags = space.int_w(w_arg)
    def fget_subs( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.subs] )
    def fset_subs( space, self, w_arg):
        del self.subs[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.subs.append( space.interpclass_w( w_arg ) )

def descr_Subscript_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitSubscript'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Subscript.typedef = TypeDef('Subscript', Node.typedef, 
                     accept=interp2app(descr_Subscript_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(Subscript.fget_expr, Subscript.fset_expr ),
                    flags=GetSetProperty(Subscript.fget_flags, Subscript.fset_flags ),
                    subs=GetSetProperty(Subscript.fget_subs, Subscript.fset_subs ),
                    )

class TryExcept(Node):
    def __init__(self, body, handlers, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.body = body
        # handlers is a list of triplets (expr1, expr2, body)
        self.handlers = handlers
        self.else_ = else_

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.body)
        children.extend(flatten(self.handlers))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.body)
        # handlers is a list of triplets (expr1, expr2, body)
        for expr1, expr2, body in self.handlers:
            if expr1 is not None:
                nodelist.append(expr1)
            if expr2 is not None:
                nodelist.append(expr2)
            if body is not None:
                nodelist.append(body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def fget_handlers( space, self ):
        return space.newlist( [ space.newtuple( [ space.wrap(expr1),
                                                  space.wrap(expr2),
                                                  space.wrap(body) ] )
                                for expr1, expr2, body in self.handlers ] )
    

    def fset_handlers( space, self, w_arg ):
        del self.handlers[:]
        for w_tup in space.unpackiterable( w_arg ):
            w_expr1 = space.getitem( w_tup, space.wrap(0) )
            w_expr2 = space.getitem( w_tup, space.wrap(1) )
            w_body = space.getitem( w_tup, space.wrap(2) )
            expr1 = space.interpclass_w( w_expr1 )
            expr2 = space.interpclass_w( w_expr2 )
            body = space.interpclass_w( w_body )
            if not isinstance( expr1, Node ) or not isinstance( expr2, Node ) or not isinstance( body, Node ):
                raise OperationError(space.w_TypeError, space.wrap("Need a list of (expr1,expr2,body) nodes") )
            self.handlers.append( (expr1,expr2,body) )
    

    def __repr__(self):
        return "TryExcept(%s, %s, %s)" % (self.body.__repr__(), self.handlers.__repr__(), self.else_.__repr__())

    def accept(self, visitor):
        return visitor.visitTryExcept(self)

    def fget_body( space, self):
        return space.wrap(self.body)
    def fset_body( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.body = obj
    def fget_else_( space, self):
        if self.else_ is None:
            return space.w_None
        else:
            return space.wrap(self.else_)
    def fset_else_( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.else_ = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.else_ = obj

def descr_TryExcept_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitTryExcept'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

TryExcept.typedef = TypeDef('TryExcept', Node.typedef, 
                     accept=interp2app(descr_TryExcept_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    body=GetSetProperty(TryExcept.fget_body, TryExcept.fset_body ),
                    handlers=GetSetProperty(TryExcept.fget_handlers, TryExcept.fset_handlers ),
                    else_=GetSetProperty(TryExcept.fget_else_, TryExcept.fset_else_ ),
                    )

class TryFinally(Node):
    def __init__(self, body, final, lineno=-1):
        Node.__init__(self, lineno)
        self.body = body
        self.final = final

    def getChildren(self):
        "NOT_RPYTHON"
        return self.body, self.final

    def getChildNodes(self):
        return [self.body, self.final]

    def __repr__(self):
        return "TryFinally(%s, %s)" % (self.body.__repr__(), self.final.__repr__())

    def accept(self, visitor):
        return visitor.visitTryFinally(self)

    def fget_body( space, self):
        return space.wrap(self.body)
    def fset_body( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.body = obj
    def fget_final( space, self):
        return space.wrap(self.final)
    def fset_final( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.final = obj

def descr_TryFinally_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitTryFinally'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

TryFinally.typedef = TypeDef('TryFinally', Node.typedef, 
                     accept=interp2app(descr_TryFinally_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    body=GetSetProperty(TryFinally.fget_body, TryFinally.fset_body ),
                    final=GetSetProperty(TryFinally.fget_final, TryFinally.fset_final ),
                    )

class Tuple(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Tuple(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitTuple(self)

    def fget_nodes( space, self):
        return space.newlist( [space.wrap(itm) for itm in self.nodes] )
    def fset_nodes( space, self, w_arg):
        del self.nodes[:]
        for w_itm in space.unpackiterable( w_arg ):
            self.nodes.append( space.interpclass_w( w_arg ) )

def descr_Tuple_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitTuple'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Tuple.typedef = TypeDef('Tuple', Node.typedef, 
                     accept=interp2app(descr_Tuple_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    nodes=GetSetProperty(Tuple.fget_nodes, Tuple.fset_nodes ),
                    )

class UnaryAdd(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "UnaryAdd(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitUnaryAdd(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_UnaryAdd_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitUnaryAdd'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

UnaryAdd.typedef = TypeDef('UnaryAdd', UnaryOp.typedef, 
                     accept=interp2app(descr_UnaryAdd_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(UnaryAdd.fget_expr, UnaryAdd.fset_expr ),
                    )

class UnarySub(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "UnarySub(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitUnarySub(self)

    def fget_expr( space, self):
        return space.wrap(self.expr)
    def fset_expr( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.expr = obj

def descr_UnarySub_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitUnarySub'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

UnarySub.typedef = TypeDef('UnarySub', UnaryOp.typedef, 
                     accept=interp2app(descr_UnarySub_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    expr=GetSetProperty(UnarySub.fget_expr, UnarySub.fset_expr ),
                    )

class While(Node):
    def __init__(self, test, body, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test
        self.body = body
        self.else_ = else_

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.test)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "While(%s, %s, %s)" % (self.test.__repr__(), self.body.__repr__(), self.else_.__repr__())

    def accept(self, visitor):
        return visitor.visitWhile(self)

    def fget_test( space, self):
        return space.wrap(self.test)
    def fset_test( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.test = obj
    def fget_body( space, self):
        return space.wrap(self.body)
    def fset_body( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.body = obj
    def fget_else_( space, self):
        if self.else_ is None:
            return space.w_None
        else:
            return space.wrap(self.else_)
    def fset_else_( space, self, w_arg):
        if space.is_w( w_arg, space.w_None ):
            self.else_ = None
        else:
            obj = space.interpclass_w( w_arg )
            if not isinstance( obj, Node):
                raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
            self.else_ = obj

def descr_While_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitWhile'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

While.typedef = TypeDef('While', Node.typedef, 
                     accept=interp2app(descr_While_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    test=GetSetProperty(While.fget_test, While.fset_test ),
                    body=GetSetProperty(While.fget_body, While.fset_body ),
                    else_=GetSetProperty(While.fget_else_, While.fset_else_ ),
                    )

class Yield(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        "NOT_RPYTHON"
        return self.value,

    def getChildNodes(self):
        return [self.value,]

    def __repr__(self):
        return "Yield(%s)" % (self.value.__repr__(),)

    def accept(self, visitor):
        return visitor.visitYield(self)

    def fget_value( space, self):
        return space.wrap(self.value)
    def fset_value( space, self, w_arg):
        obj = space.interpclass_w( w_arg )
        if not isinstance( obj, Node):
            raise OperationError(space.w_TypeError,space.wrap('Need a Node instance'))
        self.value = obj

def descr_Yield_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitYield'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Yield.typedef = TypeDef('Yield', Node.typedef, 
                     accept=interp2app(descr_Yield_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
                    value=GetSetProperty(Yield.fget_value, Yield.fset_value ),
                    )


class ASTVisitor(object):
    """This is a visitor base class used to provide the visit
    method in replacement of the former visitor.visit = walker.dispatch
    It could also use to identify base type for visit arguments of AST nodes
    """

    def default(self, node):
        for child in node.getChildNodes():
            child.accept(self)

    def visitExpression(self, node):
        return self.default(node)

    def visitEmptyNode(self, node):
        return self.default(node)


    def visitAbstractFunction(self, node):
        return self.default( node )
    def visitAbstractTest(self, node):
        return self.default( node )
    def visitAdd(self, node):
        return self.default( node )
    def visitAnd(self, node):
        return self.default( node )
    def visitAssAttr(self, node):
        return self.default( node )
    def visitAssList(self, node):
        return self.default( node )
    def visitAssName(self, node):
        return self.default( node )
    def visitAssSeq(self, node):
        return self.default( node )
    def visitAssTuple(self, node):
        return self.default( node )
    def visitAssert(self, node):
        return self.default( node )
    def visitAssign(self, node):
        return self.default( node )
    def visitAugAssign(self, node):
        return self.default( node )
    def visitBackquote(self, node):
        return self.default( node )
    def visitBinaryOp(self, node):
        return self.default( node )
    def visitBitOp(self, node):
        return self.default( node )
    def visitBitand(self, node):
        return self.default( node )
    def visitBitor(self, node):
        return self.default( node )
    def visitBitxor(self, node):
        return self.default( node )
    def visitBreak(self, node):
        return self.default( node )
    def visitCallFunc(self, node):
        return self.default( node )
    def visitClass(self, node):
        return self.default( node )
    def visitCompare(self, node):
        return self.default( node )
    def visitConst(self, node):
        return self.default( node )
    def visitContinue(self, node):
        return self.default( node )
    def visitDecorators(self, node):
        return self.default( node )
    def visitDict(self, node):
        return self.default( node )
    def visitDiscard(self, node):
        return self.default( node )
    def visitDiv(self, node):
        return self.default( node )
    def visitEllipsis(self, node):
        return self.default( node )
    def visitExec(self, node):
        return self.default( node )
    def visitFloorDiv(self, node):
        return self.default( node )
    def visitFor(self, node):
        return self.default( node )
    def visitFrom(self, node):
        return self.default( node )
    def visitFunction(self, node):
        return self.default( node )
    def visitGenExpr(self, node):
        return self.default( node )
    def visitGenExprFor(self, node):
        return self.default( node )
    def visitGenExprIf(self, node):
        return self.default( node )
    def visitGenExprInner(self, node):
        return self.default( node )
    def visitGetattr(self, node):
        return self.default( node )
    def visitGlobal(self, node):
        return self.default( node )
    def visitIf(self, node):
        return self.default( node )
    def visitImport(self, node):
        return self.default( node )
    def visitInvert(self, node):
        return self.default( node )
    def visitKeyword(self, node):
        return self.default( node )
    def visitLambda(self, node):
        return self.default( node )
    def visitLeftShift(self, node):
        return self.default( node )
    def visitList(self, node):
        return self.default( node )
    def visitListComp(self, node):
        return self.default( node )
    def visitListCompFor(self, node):
        return self.default( node )
    def visitListCompIf(self, node):
        return self.default( node )
    def visitMod(self, node):
        return self.default( node )
    def visitModule(self, node):
        return self.default( node )
    def visitMul(self, node):
        return self.default( node )
    def visitName(self, node):
        return self.default( node )
    def visitNoneConst(self, node):
        return self.default( node )
    def visitNot(self, node):
        return self.default( node )
    def visitOr(self, node):
        return self.default( node )
    def visitPass(self, node):
        return self.default( node )
    def visitPower(self, node):
        return self.default( node )
    def visitPrint(self, node):
        return self.default( node )
    def visitPrintnl(self, node):
        return self.default( node )
    def visitRaise(self, node):
        return self.default( node )
    def visitReturn(self, node):
        return self.default( node )
    def visitRightShift(self, node):
        return self.default( node )
    def visitSlice(self, node):
        return self.default( node )
    def visitSliceobj(self, node):
        return self.default( node )
    def visitStmt(self, node):
        return self.default( node )
    def visitSub(self, node):
        return self.default( node )
    def visitSubscript(self, node):
        return self.default( node )
    def visitTryExcept(self, node):
        return self.default( node )
    def visitTryFinally(self, node):
        return self.default( node )
    def visitTuple(self, node):
        return self.default( node )
    def visitUnaryAdd(self, node):
        return self.default( node )
    def visitUnaryOp(self, node):
        return self.default( node )
    def visitUnarySub(self, node):
        return self.default( node )
    def visitWhile(self, node):
        return self.default( node )
    def visitYield(self, node):
        return self.default( node )


for name, obj in globals().items():
    if isinstance(obj, type) and issubclass(obj, Node):
        nodes[name.lower()] = obj

