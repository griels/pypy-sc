
"""Python abstract syntax node definitions

This file is automatically generated by Tools/compiler/astgen.py
"""
from consts import CO_VARARGS, CO_VARKEYWORDS, OP_ASSIGN
from pypy.interpreter.baseobjspace import Wrappable
from pypy.interpreter.typedef import TypeDef
from pypy.interpreter.gateway import interp2app, W_Root, ObjSpace
from pypy.interpreter.argument import Arguments

def flatten(list):
    l = []
    for elt in list:
        t = type(elt)
        if t is tuple or t is list:
            for elt2 in flatten(elt):
                l.append(elt2)
        else:
            l.append(elt)
    return l

#def flatten_nodes(list):
#    return [n for n in flatten(list) if isinstance(n, Node)]

nodes = {}

class Node(Wrappable):
    """Abstract base class for ast nodes."""
    def __init__(self, lineno = -1):
        self.lineno = lineno
        self.filename = ""
        #self.scope = None
        
    def getChildren(self):
        pass # implemented by subclasses
    def __iter__(self):
        for n in self.getChildren():
            yield n
    def asList(self): # for backwards compatibility
        return self.getChildren()
    def getChildNodes(self):
        return [] # implemented by subclasses
    def accept(self, visitor):
        raise NotImplementedError
    def flatten(self):
        res = []
        nodes = self.getChildNodes()
        if nodes:
            for n in nodes:
                res.extend( n.flatten() )
        else:
            res.append( self )
        return res

    def __repr__(self):
	return "Node()"

    def descr_repr( self, space ):
	return space.wrap( self.__repr__() )
    
    def descr_getChildNodes( self, space ):
        lst = self.getChildNodes()
        return space.newlist( [ self.wrap( it ) for it in lst ] )

def descr_node_accept( space, w_self, w_visitor ):
    w_callable = space.getattr(w_visitor, space.wrap('visitNode'))
    args = Arguments(space, [ w_self ])
    return space.call_args( w_callable, args )

Node.typedef = TypeDef('ASTNode',
		       #__repr__ = interp2app(descr_node_repr, unwrap_spec=['self', ObjSpace] ),
		       getChildNodes = interp2app(Node.descr_getChildNodes, unwrap_spec=[ 'self', ObjSpace ] ),
		       accept = interp2app(descr_node_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ),
		       )

        
class EmptyNode(Node):
    def accept(self, visitor):
        return visitor.visitEmptyNode(self)

class Expression(Node):
    # Expression is an artificial node class to support "eval"
    nodes["expression"] = "Expression"
    def __init__(self, node):
        Node.__init__(self)
        self.node = node

    def getChildren(self):
        return [self.node,]

    def getChildNodes(self):
        return [self.node,]

    def __repr__(self):
        return "Expression(%s)" % (repr(self.node))

    def accept(self, visitor):
        return visitor.visitExpression(self)



class AbstractFunction(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AbstractFunction()"

    def accept(self, visitor):
        return visitor.visitAbstractFunction(self)

def descr_AbstractFunction_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAbstractFunction'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AbstractFunction.typedef = TypeDef('AbstractFunction', Node.typedef, 
                     accept=interp2app(descr_AbstractFunction_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class AbstractTest(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AbstractTest()"

    def accept(self, visitor):
        return visitor.visitAbstractTest(self)

def descr_AbstractTest_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAbstractTest'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AbstractTest.typedef = TypeDef('AbstractTest', Node.typedef, 
                     accept=interp2app(descr_AbstractTest_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class BinaryOp(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "BinaryOp()"

    def accept(self, visitor):
        return visitor.visitBinaryOp(self)

def descr_BinaryOp_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBinaryOp'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

BinaryOp.typedef = TypeDef('BinaryOp', Node.typedef, 
                     accept=interp2app(descr_BinaryOp_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Add(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Add((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitAdd(self)

def descr_Add_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAdd'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Add.typedef = TypeDef('Add', Node.typedef, 
                     accept=interp2app(descr_Add_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class And(AbstractTest):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "And(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitAnd(self)

def descr_And_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAnd'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

And.typedef = TypeDef('And', Node.typedef, 
                     accept=interp2app(descr_And_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class AssAttr(Node):
    def __init__(self, expr, attrname, flags, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.attrname = attrname
        self.flags = flags

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr, self.attrname, self.flags

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "AssAttr(%s, %s, %s)" % (self.expr.__repr__(), self.attrname.__repr__(), self.flags.__repr__())

    def accept(self, visitor):
        return visitor.visitAssAttr(self)

def descr_AssAttr_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssAttr'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssAttr.typedef = TypeDef('AssAttr', Node.typedef, 
                     accept=interp2app(descr_AssAttr_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class AssSeq(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AssSeq()"

    def accept(self, visitor):
        return visitor.visitAssSeq(self)

def descr_AssSeq_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssSeq'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssSeq.typedef = TypeDef('AssSeq', Node.typedef, 
                     accept=interp2app(descr_AssSeq_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class AssList(AssSeq):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "AssList(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitAssList(self)

def descr_AssList_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssList'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssList.typedef = TypeDef('AssList', Node.typedef, 
                     accept=interp2app(descr_AssList_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class AssName(Node):
    def __init__(self, name, flags, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.flags = flags

    def getChildren(self):
        "NOT_RPYTHON"
        return self.name, self.flags

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "AssName(%s, %s)" % (self.name.__repr__(), self.flags.__repr__())

    def accept(self, visitor):
        return visitor.visitAssName(self)

def descr_AssName_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssName'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssName.typedef = TypeDef('AssName', Node.typedef, 
                     accept=interp2app(descr_AssName_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class AssTuple(AssSeq):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def getArgNames(self):
        argnames = []
        for node in self.nodes:
            if isinstance(node, AssTuple):
                argnames.extend(node.getArgNames())
            elif isinstance(node, AssName):
                name = node.name
                assert isinstance(name, str)
                argnames.append(name)
            else:
                assert False, "should only have AssName and AssTuple as children"
        return argnames

    def __repr__(self):
        return "AssTuple(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitAssTuple(self)

def descr_AssTuple_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssTuple'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AssTuple.typedef = TypeDef('AssTuple', Node.typedef, 
                     accept=interp2app(descr_AssTuple_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Assert(Node):
    def __init__(self, test, fail, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test
        self.fail = fail

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.test)
        children.append(self.fail)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        if self.fail is not None:
            nodelist.append(self.fail)
        return nodelist

    def __repr__(self):
        return "Assert(%s, %s)" % (self.test.__repr__(), self.fail.__repr__())

    def accept(self, visitor):
        return visitor.visitAssert(self)

def descr_Assert_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssert'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Assert.typedef = TypeDef('Assert', Node.typedef, 
                     accept=interp2app(descr_Assert_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Assign(Node):
    def __init__(self, nodes, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.expr)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        nodelist.append(self.expr)
        return nodelist

    def __repr__(self):
        return "Assign(%s, %s)" % (self.nodes.__repr__(), self.expr.__repr__())

    def accept(self, visitor):
        return visitor.visitAssign(self)

def descr_Assign_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAssign'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Assign.typedef = TypeDef('Assign', Node.typedef, 
                     accept=interp2app(descr_Assign_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class AugAssign(Node):
    def __init__(self, node, op, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.node = node
        self.op = op
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.node, self.op, self.expr

    def getChildNodes(self):
        return [self.node, self.expr]

    def __repr__(self):
        return "AugAssign(%s, %s, %s)" % (self.node.__repr__(), self.op.__repr__(), self.expr.__repr__())

    def accept(self, visitor):
        return visitor.visitAugAssign(self)

def descr_AugAssign_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitAugAssign'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

AugAssign.typedef = TypeDef('AugAssign', Node.typedef, 
                     accept=interp2app(descr_AugAssign_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class UnaryOp(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "UnaryOp()"

    def accept(self, visitor):
        return visitor.visitUnaryOp(self)

def descr_UnaryOp_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitUnaryOp'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

UnaryOp.typedef = TypeDef('UnaryOp', Node.typedef, 
                     accept=interp2app(descr_UnaryOp_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Backquote(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Backquote(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitBackquote(self)

def descr_Backquote_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBackquote'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Backquote.typedef = TypeDef('Backquote', Node.typedef, 
                     accept=interp2app(descr_Backquote_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class BitOp(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "BitOp()"

    def accept(self, visitor):
        return visitor.visitBitOp(self)

def descr_BitOp_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBitOp'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

BitOp.typedef = TypeDef('BitOp', Node.typedef, 
                     accept=interp2app(descr_BitOp_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Bitand(BitOp):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Bitand(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitBitand(self)

def descr_Bitand_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBitand'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Bitand.typedef = TypeDef('Bitand', Node.typedef, 
                     accept=interp2app(descr_Bitand_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Bitor(BitOp):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Bitor(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitBitor(self)

def descr_Bitor_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBitor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Bitor.typedef = TypeDef('Bitor', Node.typedef, 
                     accept=interp2app(descr_Bitor_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Bitxor(BitOp):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Bitxor(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitBitxor(self)

def descr_Bitxor_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBitxor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Bitxor.typedef = TypeDef('Bitxor', Node.typedef, 
                     accept=interp2app(descr_Bitxor_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Break(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Break()"

    def accept(self, visitor):
        return visitor.visitBreak(self)

def descr_Break_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitBreak'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Break.typedef = TypeDef('Break', Node.typedef, 
                     accept=interp2app(descr_Break_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class CallFunc(Node):
    def __init__(self, node, args, star_args = None, dstar_args = None, lineno=-1):
        Node.__init__(self, lineno)
        self.node = node
        self.args = args
        self.star_args = star_args
        self.dstar_args = dstar_args

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.node)
        children.extend(flatten(self.args))
        children.append(self.star_args)
        children.append(self.dstar_args)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.node)
        nodelist.extend(self.args)
        if self.star_args is not None:
            nodelist.append(self.star_args)
        if self.dstar_args is not None:
            nodelist.append(self.dstar_args)
        return nodelist

    def __repr__(self):
        return "CallFunc(%s, %s, %s, %s)" % (self.node.__repr__(), self.args.__repr__(), self.star_args.__repr__(), self.dstar_args.__repr__())

    def accept(self, visitor):
        return visitor.visitCallFunc(self)

def descr_CallFunc_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitCallFunc'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

CallFunc.typedef = TypeDef('CallFunc', Node.typedef, 
                     accept=interp2app(descr_CallFunc_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Class(Node):
    def __init__(self, name, bases, doc, code, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.bases = bases
        self.doc = doc
        self.code = code

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.name)
        children.extend(flatten(self.bases))
        children.append(self.doc)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.bases)
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Class(%s, %s, %s, %s)" % (self.name.__repr__(), self.bases.__repr__(), self.doc.__repr__(), self.code.__repr__())

    def accept(self, visitor):
        return visitor.visitClass(self)

def descr_Class_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitClass'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Class.typedef = TypeDef('Class', Node.typedef, 
                     accept=interp2app(descr_Class_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Compare(Node):
    def __init__(self, expr, ops, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        # ops is a list of couples (op_name, node)
        self.ops = ops

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.extend(flatten(self.ops))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        # ops is a list of couples (op_name, node)
        for op_name, node in self.ops:
            nodelist.append(node)
        return nodelist

    def __repr__(self):
        return "Compare(%s, %s)" % (self.expr.__repr__(), self.ops.__repr__())

    def accept(self, visitor):
        return visitor.visitCompare(self)

def descr_Compare_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitCompare'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Compare.typedef = TypeDef('Compare', Node.typedef, 
                     accept=interp2app(descr_Compare_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Const(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        "NOT_RPYTHON"
        return self.value,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Const(%s)" % (self.value.__repr__(),)

    def accept(self, visitor):
        return visitor.visitConst(self)

def descr_Const_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitConst'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Const.typedef = TypeDef('Const', Node.typedef, 
                     accept=interp2app(descr_Const_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Continue(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Continue()"

    def accept(self, visitor):
        return visitor.visitContinue(self)

def descr_Continue_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitContinue'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Continue.typedef = TypeDef('Continue', Node.typedef, 
                     accept=interp2app(descr_Continue_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Decorators(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Decorators(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitDecorators(self)

def descr_Decorators_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitDecorators'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Decorators.typedef = TypeDef('Decorators', Node.typedef, 
                     accept=interp2app(descr_Decorators_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Dict(Node):
    def __init__(self, items, lineno=-1):
        Node.__init__(self, lineno)
        # items is a list of couples (node (key), node (value))
        self.items = items

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.items))

    def getChildNodes(self):
        nodelist = []
        # items is a list of couples (node (key), node (value))
        for key, value in self.items:
            nodelist.append(key)
            nodelist.append(value)
        return nodelist

    def __repr__(self):
        return "Dict(%s)" % (self.items.__repr__(),)

    def accept(self, visitor):
        return visitor.visitDict(self)

def descr_Dict_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitDict'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Dict.typedef = TypeDef('Dict', Node.typedef, 
                     accept=interp2app(descr_Dict_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Discard(Node):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Discard(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitDiscard(self)

def descr_Discard_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitDiscard'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Discard.typedef = TypeDef('Discard', Node.typedef, 
                     accept=interp2app(descr_Discard_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Div(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Div((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitDiv(self)

def descr_Div_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitDiv'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Div.typedef = TypeDef('Div', Node.typedef, 
                     accept=interp2app(descr_Div_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Ellipsis(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Ellipsis()"

    def accept(self, visitor):
        return visitor.visitEllipsis(self)

def descr_Ellipsis_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitEllipsis'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Ellipsis.typedef = TypeDef('Ellipsis', Node.typedef, 
                     accept=interp2app(descr_Ellipsis_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Exec(Node):
    def __init__(self, expr, locals, globals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.locals = locals
        self.globals = globals

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.append(self.locals)
        children.append(self.globals)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.locals is not None:
            nodelist.append(self.locals)
        if self.globals is not None:
            nodelist.append(self.globals)
        return nodelist

    def __repr__(self):
        return "Exec(%s, %s, %s)" % (self.expr.__repr__(), self.locals.__repr__(), self.globals.__repr__())

    def accept(self, visitor):
        return visitor.visitExec(self)

def descr_Exec_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitExec'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Exec.typedef = TypeDef('Exec', Node.typedef, 
                     accept=interp2app(descr_Exec_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class FloorDiv(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "FloorDiv((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitFloorDiv(self)

def descr_FloorDiv_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitFloorDiv'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

FloorDiv.typedef = TypeDef('FloorDiv', Node.typedef, 
                     accept=interp2app(descr_FloorDiv_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class For(Node):
    def __init__(self, assign, list, body, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.list = list
        self.body = body
        self.else_ = else_

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "For(%s, %s, %s, %s)" % (self.assign.__repr__(), self.list.__repr__(), self.body.__repr__(), self.else_.__repr__())

    def accept(self, visitor):
        return visitor.visitFor(self)

def descr_For_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitFor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

For.typedef = TypeDef('For', Node.typedef, 
                     accept=interp2app(descr_For_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class From(Node):
    def __init__(self, modname, names, lineno=-1):
        Node.__init__(self, lineno)
        self.modname = modname
        self.names = names

    def getChildren(self):
        "NOT_RPYTHON"
        return self.modname, self.names

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "From(%s, %s)" % (self.modname.__repr__(), self.names.__repr__())

    def accept(self, visitor):
        return visitor.visitFrom(self)

def descr_From_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitFrom'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

From.typedef = TypeDef('From', Node.typedef, 
                     accept=interp2app(descr_From_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Function(AbstractFunction):
    def __init__(self, decorators, name, argnames, defaults, flags, doc, code, lineno=-1):
        Node.__init__(self, lineno)
        self.decorators = decorators
        self.name = name
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.doc = doc
        self.code = code
        self.varargs = self.kwargs = 0
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1
    


    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.decorators)
        children.append(self.name)
        children.append(self.argnames)
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.doc)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.decorators is not None:
            nodelist.append(self.decorators)
        nodelist.extend(self.defaults)
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Function(%s, %s, %s, %s, %s, %s, %s)" % (self.decorators.__repr__(), self.name.__repr__(), self.argnames.__repr__(), self.defaults.__repr__(), self.flags.__repr__(), self.doc.__repr__(), self.code.__repr__())

    def accept(self, visitor):
        return visitor.visitFunction(self)

def descr_Function_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitFunction'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Function.typedef = TypeDef('Function', Node.typedef, 
                     accept=interp2app(descr_Function_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class GenExpr(AbstractFunction):
    def __init__(self, code, lineno=-1):
        Node.__init__(self, lineno)
        self.code = code
        self.argnames = [AssName('[outmost-iterable]', OP_ASSIGN)]
        self.varargs = self.kwargs = 0
    


    def getChildren(self):
        "NOT_RPYTHON"
        return self.code,

    def getChildNodes(self):
        return [self.code,]

    def __repr__(self):
        return "GenExpr(%s)" % (self.code.__repr__(),)

    def accept(self, visitor):
        return visitor.visitGenExpr(self)

def descr_GenExpr_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGenExpr'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

GenExpr.typedef = TypeDef('GenExpr', Node.typedef, 
                     accept=interp2app(descr_GenExpr_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class GenExprFor(Node):
    def __init__(self, assign, iter, ifs, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.iter = iter
        self.ifs = ifs
        self.is_outmost = False
    


    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.assign)
        children.append(self.iter)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.iter)
        nodelist.extend(self.ifs)
        return nodelist

    def __repr__(self):
        return "GenExprFor(%s, %s, %s)" % (self.assign.__repr__(), self.iter.__repr__(), self.ifs.__repr__())

    def accept(self, visitor):
        return visitor.visitGenExprFor(self)

def descr_GenExprFor_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGenExprFor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

GenExprFor.typedef = TypeDef('GenExprFor', Node.typedef, 
                     accept=interp2app(descr_GenExprFor_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class GenExprIf(Node):
    def __init__(self, test, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test

    def getChildren(self):
        "NOT_RPYTHON"
        return self.test,

    def getChildNodes(self):
        return [self.test,]

    def __repr__(self):
        return "GenExprIf(%s)" % (self.test.__repr__(),)

    def accept(self, visitor):
        return visitor.visitGenExprIf(self)

def descr_GenExprIf_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGenExprIf'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

GenExprIf.typedef = TypeDef('GenExprIf', Node.typedef, 
                     accept=interp2app(descr_GenExprIf_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class GenExprInner(Node):
    def __init__(self, expr, quals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.quals = quals

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(self.quals)
        return nodelist

    def __repr__(self):
        return "GenExprInner(%s, %s)" % (self.expr.__repr__(), self.quals.__repr__())

    def accept(self, visitor):
        return visitor.visitGenExprInner(self)

def descr_GenExprInner_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGenExprInner'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

GenExprInner.typedef = TypeDef('GenExprInner', Node.typedef, 
                     accept=interp2app(descr_GenExprInner_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Getattr(Node):
    def __init__(self, expr, attrname, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.attrname = attrname

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr, self.attrname

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Getattr(%s, %s)" % (self.expr.__repr__(), self.attrname.__repr__())

    def accept(self, visitor):
        return visitor.visitGetattr(self)

def descr_Getattr_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGetattr'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Getattr.typedef = TypeDef('Getattr', Node.typedef, 
                     accept=interp2app(descr_Getattr_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Global(Node):
    def __init__(self, names, lineno=-1):
        Node.__init__(self, lineno)
        self.names = names

    def getChildren(self):
        "NOT_RPYTHON"
        return self.names,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Global(%s)" % (self.names.__repr__(),)

    def accept(self, visitor):
        return visitor.visitGlobal(self)

def descr_Global_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitGlobal'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Global.typedef = TypeDef('Global', Node.typedef, 
                     accept=interp2app(descr_Global_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class If(Node):
    def __init__(self, tests, else_, lineno=-1):
        Node.__init__(self, lineno)
        # tests is a list of couples (node (test), node (suite))
        self.tests = tests
        self.else_ = else_

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.tests))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        # tests is a list of couples (node (test), node (suite))
        for test, suite in self.tests:
            nodelist.append(test)
            nodelist.append(suite)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "If(%s, %s)" % (self.tests.__repr__(), self.else_.__repr__())

    def accept(self, visitor):
        return visitor.visitIf(self)

def descr_If_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitIf'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

If.typedef = TypeDef('If', Node.typedef, 
                     accept=interp2app(descr_If_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Import(Node):
    def __init__(self, names, lineno=-1):
        Node.__init__(self, lineno)
        self.names = names

    def getChildren(self):
        "NOT_RPYTHON"
        return self.names,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Import(%s)" % (self.names.__repr__(),)

    def accept(self, visitor):
        return visitor.visitImport(self)

def descr_Import_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitImport'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Import.typedef = TypeDef('Import', Node.typedef, 
                     accept=interp2app(descr_Import_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Invert(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Invert(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitInvert(self)

def descr_Invert_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitInvert'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Invert.typedef = TypeDef('Invert', Node.typedef, 
                     accept=interp2app(descr_Invert_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Keyword(Node):
    def __init__(self, name, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.name = name
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.name, self.expr

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Keyword(%s, %s)" % (self.name.__repr__(), self.expr.__repr__())

    def accept(self, visitor):
        return visitor.visitKeyword(self)

def descr_Keyword_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitKeyword'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Keyword.typedef = TypeDef('Keyword', Node.typedef, 
                     accept=interp2app(descr_Keyword_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Lambda(AbstractFunction):
    def __init__(self, argnames, defaults, flags, code, lineno=-1):
        Node.__init__(self, lineno)
        self.argnames = argnames
        self.defaults = defaults
        self.flags = flags
        self.code = code
        self.varargs = self.kwargs = 0
        if flags & CO_VARARGS:
            self.varargs = 1
        if flags & CO_VARKEYWORDS:
            self.kwargs = 1
    


    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.argnames)
        children.extend(flatten(self.defaults))
        children.append(self.flags)
        children.append(self.code)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.defaults)
        nodelist.append(self.code)
        return nodelist

    def __repr__(self):
        return "Lambda(%s, %s, %s, %s)" % (self.argnames.__repr__(), self.defaults.__repr__(), self.flags.__repr__(), self.code.__repr__())

    def accept(self, visitor):
        return visitor.visitLambda(self)

def descr_Lambda_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitLambda'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Lambda.typedef = TypeDef('Lambda', Node.typedef, 
                     accept=interp2app(descr_Lambda_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class LeftShift(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "LeftShift((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitLeftShift(self)

def descr_LeftShift_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitLeftShift'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

LeftShift.typedef = TypeDef('LeftShift', Node.typedef, 
                     accept=interp2app(descr_LeftShift_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class List(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "List(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitList(self)

def descr_List_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitList'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

List.typedef = TypeDef('List', Node.typedef, 
                     accept=interp2app(descr_List_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class ListComp(Node):
    def __init__(self, expr, quals, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.quals = quals

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.extend(flatten(self.quals))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(self.quals)
        return nodelist

    def __repr__(self):
        return "ListComp(%s, %s)" % (self.expr.__repr__(), self.quals.__repr__())

    def accept(self, visitor):
        return visitor.visitListComp(self)

def descr_ListComp_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitListComp'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

ListComp.typedef = TypeDef('ListComp', Node.typedef, 
                     accept=interp2app(descr_ListComp_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class ListCompFor(Node):
    def __init__(self, assign, list, ifs, lineno=-1):
        Node.__init__(self, lineno)
        self.assign = assign
        self.list = list
        self.ifs = ifs

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.assign)
        children.append(self.list)
        children.extend(flatten(self.ifs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.assign)
        nodelist.append(self.list)
        nodelist.extend(self.ifs)
        return nodelist

    def __repr__(self):
        return "ListCompFor(%s, %s, %s)" % (self.assign.__repr__(), self.list.__repr__(), self.ifs.__repr__())

    def accept(self, visitor):
        return visitor.visitListCompFor(self)

def descr_ListCompFor_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitListCompFor'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

ListCompFor.typedef = TypeDef('ListCompFor', Node.typedef, 
                     accept=interp2app(descr_ListCompFor_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class ListCompIf(Node):
    def __init__(self, test, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test

    def getChildren(self):
        "NOT_RPYTHON"
        return self.test,

    def getChildNodes(self):
        return [self.test,]

    def __repr__(self):
        return "ListCompIf(%s)" % (self.test.__repr__(),)

    def accept(self, visitor):
        return visitor.visitListCompIf(self)

def descr_ListCompIf_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitListCompIf'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

ListCompIf.typedef = TypeDef('ListCompIf', Node.typedef, 
                     accept=interp2app(descr_ListCompIf_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Mod(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Mod((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitMod(self)

def descr_Mod_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitMod'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Mod.typedef = TypeDef('Mod', Node.typedef, 
                     accept=interp2app(descr_Mod_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Module(Node):
    def __init__(self, doc, node, lineno=-1):
        Node.__init__(self, lineno)
        self.doc = doc
        self.node = node

    def getChildren(self):
        "NOT_RPYTHON"
        return self.doc, self.node

    def getChildNodes(self):
        return [self.node,]

    def __repr__(self):
        return "Module(%s, %s)" % (self.doc.__repr__(), self.node.__repr__())

    def accept(self, visitor):
        return visitor.visitModule(self)

def descr_Module_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitModule'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Module.typedef = TypeDef('Module', Node.typedef, 
                     accept=interp2app(descr_Module_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Mul(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Mul((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitMul(self)

def descr_Mul_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitMul'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Mul.typedef = TypeDef('Mul', Node.typedef, 
                     accept=interp2app(descr_Mul_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Name(Node):
    def __init__(self, varname, lineno=-1):
        Node.__init__(self, lineno)
        self.varname = varname

    def getChildren(self):
        "NOT_RPYTHON"
        return self.varname,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Name(%s)" % (self.varname.__repr__(),)

    def accept(self, visitor):
        return visitor.visitName(self)

def descr_Name_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitName'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Name.typedef = TypeDef('Name', Node.typedef, 
                     accept=interp2app(descr_Name_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class NoneConst(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "NoneConst()"

    def accept(self, visitor):
        return visitor.visitNoneConst(self)

def descr_NoneConst_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitNoneConst'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

NoneConst.typedef = TypeDef('NoneConst', Node.typedef, 
                     accept=interp2app(descr_NoneConst_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Not(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "Not(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitNot(self)

def descr_Not_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitNot'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Not.typedef = TypeDef('Not', Node.typedef, 
                     accept=interp2app(descr_Not_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class NumberConst(Node):
    def __init__(self, number_value, lineno=-1):
        Node.__init__(self, lineno)
        self.number_value = number_value

    def getChildren(self):
        "NOT_RPYTHON"
        return self.number_value,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "NumberConst(%s)" % (self.number_value.__repr__(),)

    def accept(self, visitor):
        return visitor.visitNumberConst(self)

def descr_NumberConst_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitNumberConst'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

NumberConst.typedef = TypeDef('NumberConst', Node.typedef, 
                     accept=interp2app(descr_NumberConst_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Or(AbstractTest):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Or(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitOr(self)

def descr_Or_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitOr'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Or.typedef = TypeDef('Or', Node.typedef, 
                     accept=interp2app(descr_Or_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Pass(Node):
    def __init__(self, lineno=-1):
        Node.__init__(self, lineno)

    def getChildren(self):
        "NOT_RPYTHON"
        return []

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "Pass()"

    def accept(self, visitor):
        return visitor.visitPass(self)

def descr_Pass_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitPass'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Pass.typedef = TypeDef('Pass', Node.typedef, 
                     accept=interp2app(descr_Pass_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Power(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Power((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitPower(self)

def descr_Power_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitPower'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Power.typedef = TypeDef('Power', Node.typedef, 
                     accept=interp2app(descr_Power_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Print(Node):
    def __init__(self, nodes, dest, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.dest = dest

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        if self.dest is not None:
            nodelist.append(self.dest)
        return nodelist

    def __repr__(self):
        return "Print(%s, %s)" % (self.nodes.__repr__(), self.dest.__repr__())

    def accept(self, visitor):
        return visitor.visitPrint(self)

def descr_Print_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitPrint'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Print.typedef = TypeDef('Print', Node.typedef, 
                     accept=interp2app(descr_Print_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Printnl(Node):
    def __init__(self, nodes, dest, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes
        self.dest = dest

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.extend(flatten(self.nodes))
        children.append(self.dest)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        if self.dest is not None:
            nodelist.append(self.dest)
        return nodelist

    def __repr__(self):
        return "Printnl(%s, %s)" % (self.nodes.__repr__(), self.dest.__repr__())

    def accept(self, visitor):
        return visitor.visitPrintnl(self)

def descr_Printnl_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitPrintnl'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Printnl.typedef = TypeDef('Printnl', Node.typedef, 
                     accept=interp2app(descr_Printnl_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Raise(Node):
    def __init__(self, expr1, expr2, expr3, lineno=-1):
        Node.__init__(self, lineno)
        self.expr1 = expr1
        self.expr2 = expr2
        self.expr3 = expr3

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr1)
        children.append(self.expr2)
        children.append(self.expr3)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        if self.expr1 is not None:
            nodelist.append(self.expr1)
        if self.expr2 is not None:
            nodelist.append(self.expr2)
        if self.expr3 is not None:
            nodelist.append(self.expr3)
        return nodelist

    def __repr__(self):
        return "Raise(%s, %s, %s)" % (self.expr1.__repr__(), self.expr2.__repr__(), self.expr3.__repr__())

    def accept(self, visitor):
        return visitor.visitRaise(self)

def descr_Raise_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitRaise'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Raise.typedef = TypeDef('Raise', Node.typedef, 
                     accept=interp2app(descr_Raise_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Return(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        "NOT_RPYTHON"
        return (self.value,)

    def getChildNodes(self):
        nodelist = []
        if self.value is not None:
            nodelist.append(self.value)
        return nodelist

    def __repr__(self):
        return "Return(%s)" % (self.value.__repr__(),)

    def accept(self, visitor):
        return visitor.visitReturn(self)

def descr_Return_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitReturn'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Return.typedef = TypeDef('Return', Node.typedef, 
                     accept=interp2app(descr_Return_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class RightShift(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "RightShift((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitRightShift(self)

def descr_RightShift_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitRightShift'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

RightShift.typedef = TypeDef('RightShift', Node.typedef, 
                     accept=interp2app(descr_RightShift_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Slice(Node):
    def __init__(self, expr, flags, lower, upper, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.flags = flags
        self.lower = lower
        self.upper = upper

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.append(self.lower)
        children.append(self.upper)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        if self.lower is not None:
            nodelist.append(self.lower)
        if self.upper is not None:
            nodelist.append(self.upper)
        return nodelist

    def __repr__(self):
        return "Slice(%s, %s, %s, %s)" % (self.expr.__repr__(), self.flags.__repr__(), self.lower.__repr__(), self.upper.__repr__())

    def accept(self, visitor):
        return visitor.visitSlice(self)

def descr_Slice_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitSlice'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Slice.typedef = TypeDef('Slice', Node.typedef, 
                     accept=interp2app(descr_Slice_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Sliceobj(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Sliceobj(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitSliceobj(self)

def descr_Sliceobj_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitSliceobj'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Sliceobj.typedef = TypeDef('Sliceobj', Node.typedef, 
                     accept=interp2app(descr_Sliceobj_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Stmt(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Stmt(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitStmt(self)

def descr_Stmt_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitStmt'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Stmt.typedef = TypeDef('Stmt', Node.typedef, 
                     accept=interp2app(descr_Stmt_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class StringConst(Node):
    def __init__(self, string_value, lineno=-1):
        Node.__init__(self, lineno)
        self.string_value = string_value

    def getChildren(self):
        "NOT_RPYTHON"
        return self.string_value,

    def getChildNodes(self):
        return []

    def __repr__(self):
        return "StringConst(%s)" % (self.string_value.__repr__(),)

    def accept(self, visitor):
        return visitor.visitStringConst(self)

def descr_StringConst_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitStringConst'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

StringConst.typedef = TypeDef('StringConst', Node.typedef, 
                     accept=interp2app(descr_StringConst_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Sub(BinaryOp):
    def __init__(self, (left, right), lineno=-1):
        Node.__init__(self, lineno)
        self.left = left
        self.right = right

    def getChildren(self):
        "NOT_RPYTHON"
        return self.left, self.right

    def getChildNodes(self):
        return [self.left, self.right]

    def __repr__(self):
        return "Sub((%s, %s))" % (self.left.__repr__(), self.right.__repr__())

    def accept(self, visitor):
        return visitor.visitSub(self)

def descr_Sub_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitSub'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Sub.typedef = TypeDef('Sub', Node.typedef, 
                     accept=interp2app(descr_Sub_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Subscript(Node):
    def __init__(self, expr, flags, subs, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr
        self.flags = flags
        self.subs = subs

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.expr)
        children.append(self.flags)
        children.extend(flatten(self.subs))
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.expr)
        nodelist.extend(self.subs)
        return nodelist

    def __repr__(self):
        return "Subscript(%s, %s, %s)" % (self.expr.__repr__(), self.flags.__repr__(), self.subs.__repr__())

    def accept(self, visitor):
        return visitor.visitSubscript(self)

def descr_Subscript_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitSubscript'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Subscript.typedef = TypeDef('Subscript', Node.typedef, 
                     accept=interp2app(descr_Subscript_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class TryExcept(Node):
    def __init__(self, body, handlers, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.body = body
        # handlers is a list of triplets (expr1, expr2, body)
        self.handlers = handlers
        self.else_ = else_

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.body)
        children.extend(flatten(self.handlers))
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.body)
        # handlers is a list of triplets (expr1, expr2, body)
        for expr1, expr2, body in self.handlers:
            if expr1 is not None:
                nodelist.append(expr1)
            if expr2 is not None:
                nodelist.append(expr2)
            if body is not None:
                nodelist.append(body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "TryExcept(%s, %s, %s)" % (self.body.__repr__(), self.handlers.__repr__(), self.else_.__repr__())

    def accept(self, visitor):
        return visitor.visitTryExcept(self)

def descr_TryExcept_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitTryExcept'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

TryExcept.typedef = TypeDef('TryExcept', Node.typedef, 
                     accept=interp2app(descr_TryExcept_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class TryFinally(Node):
    def __init__(self, body, final, lineno=-1):
        Node.__init__(self, lineno)
        self.body = body
        self.final = final

    def getChildren(self):
        "NOT_RPYTHON"
        return self.body, self.final

    def getChildNodes(self):
        return [self.body, self.final]

    def __repr__(self):
        return "TryFinally(%s, %s)" % (self.body.__repr__(), self.final.__repr__())

    def accept(self, visitor):
        return visitor.visitTryFinally(self)

def descr_TryFinally_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitTryFinally'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

TryFinally.typedef = TypeDef('TryFinally', Node.typedef, 
                     accept=interp2app(descr_TryFinally_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Tuple(Node):
    def __init__(self, nodes, lineno=-1):
        Node.__init__(self, lineno)
        self.nodes = nodes

    def getChildren(self):
        "NOT_RPYTHON"
        return tuple(flatten(self.nodes))

    def getChildNodes(self):
        nodelist = []
        nodelist.extend(self.nodes)
        return nodelist

    def __repr__(self):
        return "Tuple(%s)" % (self.nodes.__repr__(),)

    def accept(self, visitor):
        return visitor.visitTuple(self)

def descr_Tuple_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitTuple'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Tuple.typedef = TypeDef('Tuple', Node.typedef, 
                     accept=interp2app(descr_Tuple_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class UnaryAdd(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "UnaryAdd(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitUnaryAdd(self)

def descr_UnaryAdd_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitUnaryAdd'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

UnaryAdd.typedef = TypeDef('UnaryAdd', Node.typedef, 
                     accept=interp2app(descr_UnaryAdd_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class UnarySub(UnaryOp):
    def __init__(self, expr, lineno=-1):
        Node.__init__(self, lineno)
        self.expr = expr

    def getChildren(self):
        "NOT_RPYTHON"
        return self.expr,

    def getChildNodes(self):
        return [self.expr,]

    def __repr__(self):
        return "UnarySub(%s)" % (self.expr.__repr__(),)

    def accept(self, visitor):
        return visitor.visitUnarySub(self)

def descr_UnarySub_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitUnarySub'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

UnarySub.typedef = TypeDef('UnarySub', Node.typedef, 
                     accept=interp2app(descr_UnarySub_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class While(Node):
    def __init__(self, test, body, else_, lineno=-1):
        Node.__init__(self, lineno)
        self.test = test
        self.body = body
        self.else_ = else_

    def getChildren(self):
        "NOT_RPYTHON"
        children = []
        children.append(self.test)
        children.append(self.body)
        children.append(self.else_)
        return tuple(children)

    def getChildNodes(self):
        nodelist = []
        nodelist.append(self.test)
        nodelist.append(self.body)
        if self.else_ is not None:
            nodelist.append(self.else_)
        return nodelist

    def __repr__(self):
        return "While(%s, %s, %s)" % (self.test.__repr__(), self.body.__repr__(), self.else_.__repr__())

    def accept(self, visitor):
        return visitor.visitWhile(self)

def descr_While_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitWhile'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

While.typedef = TypeDef('While', Node.typedef, 
                     accept=interp2app(descr_While_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))

class Yield(Node):
    def __init__(self, value, lineno=-1):
        Node.__init__(self, lineno)
        self.value = value

    def getChildren(self):
        "NOT_RPYTHON"
        return self.value,

    def getChildNodes(self):
        return [self.value,]

    def __repr__(self):
        return "Yield(%s)" % (self.value.__repr__(),)

    def accept(self, visitor):
        return visitor.visitYield(self)

def descr_Yield_accept( space, w_self, w_visitor):
    w_callable = space.getattr(w_visitor, space.wrap('visitYield'))
    args = Arguments(space, [ w_self ])
    return space.call_args(w_callable, args)

Yield.typedef = TypeDef('Yield', Node.typedef, 
                     accept=interp2app(descr_Yield_accept, unwrap_spec=[ ObjSpace, W_Root, W_Root ] ))


class ASTVisitor(object):
    """This is a visitor base class used to provide the visit
    method in replacement of the former visitor.visit = walker.dispatch
    It could also use to identify base type for visit arguments of AST nodes
    """

    def default(self, node):
        for child in node.getChildNodes():
            child.accept(self)

    def visitExpression(self, node):
        return self.default(node)

    def visitEmptyNode(self, node):
        return self.default(node)


    def visitAbstractFunction(self, node):
        return self.default( node )
    def visitAbstractTest(self, node):
        return self.default( node )
    def visitAdd(self, node):
        return self.default( node )
    def visitAnd(self, node):
        return self.default( node )
    def visitAssAttr(self, node):
        return self.default( node )
    def visitAssList(self, node):
        return self.default( node )
    def visitAssName(self, node):
        return self.default( node )
    def visitAssSeq(self, node):
        return self.default( node )
    def visitAssTuple(self, node):
        return self.default( node )
    def visitAssert(self, node):
        return self.default( node )
    def visitAssign(self, node):
        return self.default( node )
    def visitAugAssign(self, node):
        return self.default( node )
    def visitBackquote(self, node):
        return self.default( node )
    def visitBinaryOp(self, node):
        return self.default( node )
    def visitBitOp(self, node):
        return self.default( node )
    def visitBitand(self, node):
        return self.default( node )
    def visitBitor(self, node):
        return self.default( node )
    def visitBitxor(self, node):
        return self.default( node )
    def visitBreak(self, node):
        return self.default( node )
    def visitCallFunc(self, node):
        return self.default( node )
    def visitClass(self, node):
        return self.default( node )
    def visitCompare(self, node):
        return self.default( node )
    def visitConst(self, node):
        return self.default( node )
    def visitContinue(self, node):
        return self.default( node )
    def visitDecorators(self, node):
        return self.default( node )
    def visitDict(self, node):
        return self.default( node )
    def visitDiscard(self, node):
        return self.default( node )
    def visitDiv(self, node):
        return self.default( node )
    def visitEllipsis(self, node):
        return self.default( node )
    def visitExec(self, node):
        return self.default( node )
    def visitFloorDiv(self, node):
        return self.default( node )
    def visitFor(self, node):
        return self.default( node )
    def visitFrom(self, node):
        return self.default( node )
    def visitFunction(self, node):
        return self.default( node )
    def visitGenExpr(self, node):
        return self.default( node )
    def visitGenExprFor(self, node):
        return self.default( node )
    def visitGenExprIf(self, node):
        return self.default( node )
    def visitGenExprInner(self, node):
        return self.default( node )
    def visitGetattr(self, node):
        return self.default( node )
    def visitGlobal(self, node):
        return self.default( node )
    def visitIf(self, node):
        return self.default( node )
    def visitImport(self, node):
        return self.default( node )
    def visitInvert(self, node):
        return self.default( node )
    def visitKeyword(self, node):
        return self.default( node )
    def visitLambda(self, node):
        return self.default( node )
    def visitLeftShift(self, node):
        return self.default( node )
    def visitList(self, node):
        return self.default( node )
    def visitListComp(self, node):
        return self.default( node )
    def visitListCompFor(self, node):
        return self.default( node )
    def visitListCompIf(self, node):
        return self.default( node )
    def visitMod(self, node):
        return self.default( node )
    def visitModule(self, node):
        return self.default( node )
    def visitMul(self, node):
        return self.default( node )
    def visitName(self, node):
        return self.default( node )
    def visitNoneConst(self, node):
        return self.default( node )
    def visitNot(self, node):
        return self.default( node )
    def visitNumberConst(self, node):
        return self.default( node )
    def visitOr(self, node):
        return self.default( node )
    def visitPass(self, node):
        return self.default( node )
    def visitPower(self, node):
        return self.default( node )
    def visitPrint(self, node):
        return self.default( node )
    def visitPrintnl(self, node):
        return self.default( node )
    def visitRaise(self, node):
        return self.default( node )
    def visitReturn(self, node):
        return self.default( node )
    def visitRightShift(self, node):
        return self.default( node )
    def visitSlice(self, node):
        return self.default( node )
    def visitSliceobj(self, node):
        return self.default( node )
    def visitStmt(self, node):
        return self.default( node )
    def visitStringConst(self, node):
        return self.default( node )
    def visitSub(self, node):
        return self.default( node )
    def visitSubscript(self, node):
        return self.default( node )
    def visitTryExcept(self, node):
        return self.default( node )
    def visitTryFinally(self, node):
        return self.default( node )
    def visitTuple(self, node):
        return self.default( node )
    def visitUnaryAdd(self, node):
        return self.default( node )
    def visitUnaryOp(self, node):
        return self.default( node )
    def visitUnarySub(self, node):
        return self.default( node )
    def visitWhile(self, node):
        return self.default( node )
    def visitYield(self, node):
        return self.default( node )


for name, obj in globals().items():
    if isinstance(obj, type) and issubclass(obj, Node):
        nodes[name.lower()] = obj

