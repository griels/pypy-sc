# tokens
# 
IGNORE: "([ \f\t\n]*)|(//[^\n]*\n)|(/\*([^\*]|\*[^/])*\*?\*/)";

program : sourceelements EOF
        ;

sourceelements  : sourceelement sourceelements
                | sourceelement
                ;

sourceelement   : functiondeclaration
                | statement
                ;

statement   : <block>
            | <variablestatement> [";"]
            | [ ";" ] 
            | <expressionstatement> [";"]
            | <ifstatement> [";"]
            | <iterationstatement> [";"]
            | <continuestatement> [";"]
            | <breakstatement> [";"]
            | <returnstatement> [";"]
            | <withstatement> [";"]
            | <labelledstatement> [";"]
            | <switchstatement> 
            | <throwstatement> [";"]
            | <trystatement> [";"]
            ;

block   : "{" statementlist? "}"
        ;

statementlist   : statement >statementlist<
                | statement
                ;

variablestatement   : ["var"] variabledeclarationlist
                    ; 

variabledeclarationlist : variabledeclaration [","] >variabledeclarationlist<
                        | variabledeclaration
                        ;

variabledeclaration : identifier initialiser?
                    ;
 
initialiser : ["="] assignmentexpression
            ;

expressionstatement : expression
                    ;

ifstatement : ["if"] ["("] expression [")"] statement  ["else"] statement 
            | ["if"] ["("] expression [")"] statement
            ;

iterationstatement  : "do" statement ["while"] ["("] expression [")"]
    | "while" ["("] expression [")"] statement 
    | "for" ["("]expressionnoin? [";"] expression? [";"] expression? [")"] statement 
    | "for" ["("] ["var"] variabledeclarationlistnoin [";"] expression? [";"] expression? [")"] statement 
    | ["for"] ["("] lefthandsideexpression "in" expression [")"] statement 
    | ["for"] ["("] ["var"] variabledeclarationnoin "in" expression [")"] statement
    ; 


continuestatement   : ["continue"] identifier?
                    ;

breakstatement  : ["break"] identifier?
                ;

returnstatement : ["return"] expression?
                ;

withstatement   : ["with"] ["("] expression [")"] statement
                ;
                
labelledstatement   : identifier [":"] statement
                    ;

switchstatement : ["switch"] ["("] expression [")"] caseblock
                ;

caseblock   : ["{"] caseclauses? defaultclause caseclauses? ["}"]
            | ["{"] caseclauses? ["}"]
            ;

# XXX this looks wrong to me
caseclauses : caseclause caseclauses
            ;

caseclause  : ["case"] expression [":"] statementlist?
            ;

defaultclause   : ["default"] [":"] statementlist
                ;

throwstatement  : ["throw"] expression
                ;
                
trystatement    : ["try"] block catch finally
                | ["try"] block catch
                | ["try"] block finally
                ;

catch   : ["catch"] ["("] identifier [")"] block
        ;

finally : ["finally"] block
        ;

identifier  : <IDENTIFIERNAME>;

IDENTIFIERNAME  : "[a-zA-Z_$][a-zA-Z_0-9]*";

literal : <nullliteral>
        | <booleanliteral>
        | <numericliteral>
        | <stringliteral>
        ;

nullliteral : "null";

booleanliteral  : "true"
                | "false"
                ;

numericliteral  : <DECIMALLITERAL>
                | <HEXINTEGERLITERAL>
                ; 

DECIMALLITERAL  : "(((0|[1-9][0-9]*)(\.[0-9]*)?)|(\.[0-9]+))([eE][\+\-]?[0-9]*)?"
                ;

HEXINTEGERLITERAL   : "0[xX][0-9a-fA-F]+"
                    ;

stringliteral   : <SINGLESTRING>
                | <DOUBLESTRING>
                ;

SINGLESTRING    : "'([^']|\\')*'"
                ;

DOUBLESTRING    : "\"([^\"]|\\\")*\""
                ;

primaryexpression   : "this"
                    | <identifier>
                    | <literal>
                    | <arrayliteral>
                    | <objectliteral>
                    | "\(" <expression> "\)"
                    ;

arrayliteral    : ["["] elementlist ["]"] 
                | ["["] elementlist ["," "]"]
                ;

elementlist : assignmentexpression ("," assignmentexpression)*
            ;
            
elision : ","+
        ;

objectliteral   : "{" "}" 
                | "{" propertynameandvaluelist "}"
                ;

propertynameandvaluelist    : hpropertynameandvaluelist* propertyname ":" assignmentexpression
                            ;

hpropertynameandvaluelist   : propertyname ":" assignmentexpression ","
                            ;

propertyname    : <identifier>
                | <stringliteral>
                | <numericliteral>
                ; 

functiondeclaration : "function" identifier "(" formalparameterlist? ")" "{" functionbody "}"
                    ;

functionexpression  : "function" identifier? "(" formalparameterlist? ")" "{" functionbody "}"
                    ;

formalparameterlist : identifier [","] >formalparameterlist<
                    | identifier
                    ;

functionbody    : sourceelements
                ;

begmemberexpression : <primaryexpression>
                    | <functionexpression>
                    ;

memberexpression    : begmemberexpression "[" expression "]" memberexpression* 
                    | begmemberexpression "." identifier memberexpression*
                    | "new" memberexpression arguments
                    | <begmemberexpression>
                    ;

newexpression   : "new" newexpression
                | <memberexpression>
                ;

callexpression  : memberexpression arguments arguments callexpression* 
                | memberexpression arguments "[" expression "]" callexpression*
                | memberexpression arguments "." identifier callexpression* 
                | memberexpression arguments
                ;

arguments   : "(" ")" 
            | "(" argumentlist ")"
            ;
 
argumentlist    : assignmentexpression "," >argumentlist<
                | assignmentexpression;

lefthandsideexpression  : <callexpression>
                        | <newexpression>
                        ; 

postfixexpression   : lefthandsideexpression "++" 
                    | lefthandsideexpression "--"
                    | <lefthandsideexpression>
                    ; 

unaryexpression : "delete" unaryexpression 
                | "void" unaryexpression 
                | "typeof" unaryexpression
                | "++" unaryexpression 
                | "--" unaryexpression 
                | >addop< unaryexpression 
                | "~" unaryexpression 
                | "!" unaryexpression 
                | <postfixexpression>
                ;

multop: "*" | "/" | "%";
multiplicativeexpression    : unaryexpression (>multop< unaryexpression)+
                            | <unaryexpression>
                            ;
addop: "+" | "-";
additiveexpression  : multiplicativeexpression (>addop< multiplicativeexpression)+
                    | <multiplicativeexpression>
                    ;

shiftop: "<<" | ">>" | ">>>";
shiftexpression : additiveexpression (>shiftop< additiveexpression)+
                | <additiveexpression>
                ;

relationalop: "<" | ">" | "<=" | ">=" | "instanceof" | "in";
relationalexpression    : shiftexpression (>relationalop< relationalexpression)+
                        | <shiftexpression>
                        ;

equalityop: "==" | "!=" | "===" | "!==";
equalityexpression  : relationalexpression (>equalityop< relationalexpression)+
                    | <relationalexpression>
                    ;

bitwiseandexpression    : equalityexpression ("&" equalityexpression)+
                        | <equalityexpression>
                        ;

bitwisexorexpression    : bitwiseandexpression ("^" bitwiseandexpression)+
                        | <bitwiseandexpression>
                        ;

bitwiseorexpression     : bitwisexorexpression ("|" bitwisexorexpression)+
                        | <bitwisexorexpression>
                        ; 

logicalandexpression    : bitwiseorexpression ("&&" bitwiseorexpression)+
                        | <bitwiseorexpression>
                        ;

logicalorexpression : logicalandexpression ("||" logicalandexpression)+
                    | <logicalandexpression>
                    ;
                    

conditionalexpression   : logicalorexpression "?" assignmentexpression ":" assignmentexpression
                        | <logicalorexpression>
                        ;

assignmentexpression    : lefthandsideexpression >assignmentoperator< assignmentexpression
                        | <conditionalexpression>
                        ;

assignmentoperator  : "=" | "\*=" | "\/=" | "\%=" | "\+=" | "\-=" | "<<="
                    | ">>=" | ">>>=" | "&=" | "^=" | "\|=" 
                    ;

expression  : assignmentexpression ([","] assignmentexpression)+
            | <assignmentexpression>
            ;

#noin copy

relationalopnoin: "<" | ">" | "<=" | ">=" | "instanceof";
relationalexpressionnoin    : shiftexpression (relationalopnoin shiftexpression)+
                            | <shiftexpression>
                            ;

equalityexpressionnoin  : relationalexpressionnoin (equalityop equalityexpressionnoin)+
                    | <relationalexpressionnoin>
                    ;

bitwiseandexpressionnoin    : equalityexpressionnoin ("&" equalityexpressionnoin)+
                        | <equalityexpressionnoin>
                        ;

bitwisexorexpressionnoin    : bitwiseandexpressionnoin ("^" bitwiseandexpressionnoin)+
                        | <bitwiseandexpressionnoin>
                        ;

bitwiseorexpressionnoin     : bitwisexorexpressionnoin ("|" bitwisexorexpressionnoin)+
                        | <bitwisexorexpressionnoin>
                        ; 

logicalandexpressionnoin    : bitwiseorexpressionnoin ("&&" bitwiseorexpressionnoin)+
                        | <bitwiseorexpressionnoin>
                        ;

logicalorexpressionnoin : logicalandexpressionnoin ("||" logicalandexpressionnoin)+
                    | <logicalandexpressionnoin>
                    ;


conditionalexpressionnoin
                    : logicalorexpressionnoin "?" assignmentexpressionnoin ":" assignmentexpressionnoin
                    | <logicalorexpressionnoin>
                    ;

#lefthandside
assignmentexpressionnoin    : lefthandsideexpression assignmentoperator assignmentexpressionnoin
                        | <conditionalexpressionnoin>
                        ;

expressionnoin  : assignmentexpressionnoin ([","] assignmentexpressionnoin)+
            | <assignmentexpressionnoin>
            ;

#identifier
variabledeclarationnoin : identifier initialisernoin?
                    ;

initialisernoin : "=" assignmentexpressionnoin
            ;

variabledeclarationlistnoin : variabledeclarationnoin "," variabledeclarationlistnoin 
                        | variabledeclarationnoin
                        ;
