FlowObjSpace
============

Introduction
------------

The FlowObjSpace generates a control-flow graph from a function. This graph also contains a trace of the individual operations, so that it is actually just an alternate representation for the function.

The FlowObjSpace is an object space, which means that it exports the standard object space interface and it is driven by the interpreter.

The basic idea is that if the interpreter is given a function, e.g.::

  def f(n):
    return 3*n+2

it will do whatever bytecode dispatching and stack-shuffling needed, during which it issues a sequence of calls to the object space.  The FlowObjSpace merely records these calls (corresponding to "operations") in a structure called a basic block.  To track which value goes where, the FlowObjSpace invents placeholder "wrapped objects" and give them to the interpreter, so that they appear in some next operation.

For example, if the placeholder ``v1`` is given as the argument to the above function, the interpreter will call ``v2 = space.mul(space.wrap(3), v1)`` and then ``v3 = space.add(v2, space.wrap(2))`` and return ``v3`` as the result.  During these calls the FlowObjSpace will record a basic block::

  Block(v1):     # input argument
    v2 = mul(constant(3), v1)
    v3 = add(v2, constant(2))


Joining basic blocks
--------------------

A basic block ends in one of two cases: when the interpreters calls ``is_true()``, or when a joinpoint is reached.

* A joinpoint is a specially marked position in the bytecode.  This is the only bytecode dependency in FlowObjSpace.  Intuitively, there should be one joinpoint at each bytecode position where two different paths can "join" together, e.g. the entry point of a loop.  A joinpoint forces a basic block to end and the next one to begin.  A snapshot of the current frame is taken (a FrameState) and recorded on the joinpoint.  If the control flow later reaches this point again, we put a "backwards" jump to the old basic block that starts at this point.  (The control flow is actually just a graph, with basic blocks pointing to each other, so there is not really a notion of "backwards".)

* If the interpreter calls ``is_true()``, the FlowObjSpace doesn't generally know if the answer should be True or False, so it puts a conditional jump and generates two successor blocks for the current basic block.  There is some trickery involved so that the interpreter is fooled into thinking that ``is_true()`` first returns False (and the subsequent operations are recorded in the first successor block), and later the *same* call to ``is_true()`` also returns True (and the subsequent operations go this time to the other successor block).


Passing variables between basic blocks
--------------------------------------

XXX


FlowExecutionContext
--------------------

The FlowExecutionContext is a modified ExecutionContext that drives the interpreter in a fashion that is quite different from the one needed for normal interpretation.  XXX


Interface
---------

We make one instance of FlowExecutionContext per function to analyse.  The instance has a cache of FrameStates to detect when the control is looping (``self.joinpoints``).  XXX


Old stuff to remove
-------------------

::

  Hello again
  
                             def f(i):
                                 return g(i)+2
                             def g(i):
                                 return i+1
  
  f(3)
  tspace:
  pyxcode.putln('def f(%s):' % sig)
  res = frame.eval(executioncontext)
  pyxcode.putln('return %s' % res)
  
  
  Pyrex: def f(v1):
  dis.dis(f) -->
   2            0 LOAD_GLOBAL              0 (g)
                 w_result =  space.getitem(f.w_globals, w_varname)
  
                3 LOAD_FAST                0 (i)
                6 CALL_FUNCTION            1
  space.call(w_function, w_arguments, w_kwds)
  space.call(w_g, ("v1",), {})
  Pyrex: v2 = g(v1)
                9 LOAD_CONST               1 (2)
  space.wrap(2)
               12 BINARY_ADD
  space.add("v2", "constant 2")
  Pyrex: v3 = v2 + 2
               13 RETURN_VALUE
               14 LOAD_CONST               0 (None)
               17 RETURN_VALUE
  Pyrex: return v3
  
  
  Result:
  def f(v1):
    v2 = g(v1)
    v3 = v2 + 2
    return v3
  
  
  def h(i, j):
    if i < 0:
      i = j
    return i+1
  
  Pyrex: def h(v1, v2):
  --> interpreter
    3           0 LOAD_FAST                0 (i)
                3 LOAD_CONST               1 (0)
                6 COMPARE_OP               0 (<)
  "v3" = space.lt("v1", "constant 0")
  Pyrex: v3 = v1 < 0
                9 JUMP_IF_FALSE           10 (to 22)
  space.is_true("v3")
  Pyrex: if v3: cinline "goto Label1;"
               12 POP_TOP
  
    4          13 LOAD_FAST                1 (j)
               16 STORE_FAST               0 (i)
               19 JUMP_FORWARD             1 (to 23)
          >>   22 POP_TOP
  
  Pyrex: cinline "LabelBytecode23:"   # just in case for later
    5     >>   23 LOAD_FAST                0 (i)
               26 LOAD_CONST               2 (1)
               29 BINARY_ADD
  space.add("v1", "constant 2")
  Pyrex: v4 = v1 + 2
               30 RETURN_VALUE
               31 LOAD_CONST               0 (None)
               34 RETURN_VALUE
  Pyrex: return v4
  
  pyrex: cinline "Label1:"
               12 POP_TOP
  
    4          13 LOAD_FAST                1 (j)
               16 STORE_FAST               0 (i)
  (in the interpreter fastlocals now: i="v2" j="v2")
               19 JUMP_FORWARD             1 (to 23)
          >>   22 POP_TOP
  
  (bytecode 23 already seen!)
  Pyrex: v1 = v2
  Pyrex: cinline "goto LabelBytecode23;"
    5     >>   23 LOAD_FAST                0 (i)
  
  def h(i, j):
    if i < 0:
      i = j
    return i+1
  
  def h(v1, v2):
      v3 = v1 < 0
      if v3: cinline "goto label1;"
  
      cinline "labelBytecode23:"
      v4=v1+1
      return v4
      cinline "label1:"
      v1=v2
      cinline "goto labelBytecode23;"
  
