=========================
Annotate Object Space
=========================

was TranslateObjectSpace
-------------------------
This has been renamed and is currently being re-written. Older information follows:

This is an example of an ObjectSpace that differs a lot from StandardObjectSpace_.

At some point in the near future we will have to design a translator from all the RestrictedPython_ code we have into C code. This is the sine qua non condition for our work to be actually usable. Quite unexpectedly, the major piece of the translator is itself an object space, the TranslateObjectSpace. Its goal is to run any RestrictedPython code and produce C code in the background as it does so.

More specifically, we take our PyPy interpreter with the TranslateObjectSpace instead of the StandardObjectSpace, and run that, asking it to interpret some RestrictedPython bytecode. The idea is that a wrapped object is now the name of a variable in the C program we are emitting:

The TranslateObjectSpace's add method takes two such variable names x and y, and emits the C code z=x+y;, where z is a new variable name which is returned as the result of add. So when the interpreter goes along the bytecode, the TranslateObjectSpace will create variable names and emit C code that does just the same thing as the bytecode.

The above description is what would occur if RestrictedPython only had integer data types. We must actually make the wrapped objects a bit more elaborate to also record, besides the C variable name, its basic type. This can be easy, like prefixing the variable name with a type character; for example, add would behave as above if the variable names begin with ``i_`` but differently if they begin with the prefix denoting floats or lists, say.

Once you grasp the idea that this process can actually easily translate any RestrictedPython to C, and if you remember that the interpreter main loop itself is written in RestrictedPython, then you shouldn't be surprised if I say that all we have to do next is run the interpreter to interpret itself (and thus translate itself to C)!

This is again a rough sketch, but it shows why I expect translating RestrictedPython to C to be easy. The RestrictedPython is precisely restricted in such a way that makes the above process work, e.g. we only ever use well-known types and operations that are easy to convert to an efficient C equivalent. (For example, if lists are translated to C arrays, I'm sure Christian would insist on not using '+' between lists in RestrictedPython but rather '+=', which has a more direct translation as realloc() -- although by now he might be convinced that supporting '+' as a bonus isn't going to be any difficult anyway :-) )

------------------------------

.. _StandardObjectSpace: stdobjspace.html
.. _RestrictedPython: restrictedpy.html
