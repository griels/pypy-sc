=========================
MultiMethods and Coercion
=========================

Introduction
------------

A "multimethod" is the generalization of the OOP notion of "method".  
Theoretically, a method is a "message name" and signature attached to a
particular base class, which is implementated in the class or its subclasses.  
To do a "method call" means to send a message to an object, using a message
name and actual arguments.  We call "message dispatch" the operation of
finding which actual implementation is suitable for a particular call.  For
methods, a message is dispatched by looking up the class of the "self" object,
and finding an implementation in that class, or in its base classes, in a
certain order.

A multimethod is a message name and signature that can have implementations
that depend not only on the class of the first "self" argument, but on the
class of several arguments.  Because of this we cannot use Python's nice model
of storing method implementations as functions, in the attributes of the
class.

Here is a common implementation of multimethods: they are instances of a
specific MultiMethod class, and the instances are callable (there is a
__call__ operator on MultiMethod).  When a MultiMethod is called, a dispatch
algorithm is used to find which, among the registered implementations, is the
one that should be called; this implementation is then immediately called. The
most important difference with normal methods is that the MultiMethod object
to call is no longer syntactically attached to classes.  In other words,
whereas a method is called with ``obj.somemethod(args)``, a multimethod is
called much like a function, e.g. ``dosomething(obj1, obj2, obj3...)``.  You
have to find the MultiMethod object ``dosomething`` in some namespace; it is
no longer implicitely looked up in the namespace of the "self" object.

In PyPy the MultiMethod objects are stored in the object space instance, thus
``space.add`` is the name of a MultiMethod.  The ``space`` argument is not
used for the dispatch, but just as a convenient place to put the MultiMethod
object.


Concept Trees
-------------

A multimethod is a "signature" and a set of "implementations", which are
regular Python functions.  The difficulty is to figure out an algorithm that
should be used to know, given actual argument values, which implementation
should be called.

This algorithm should only depend on the types of the arguments. For
explicitness we will *not* use the Python class inheritance at all (because it
is better suited to normal methods, and anyway it can be emulated if needed).  
Thus the following diagram looks like inheritance diagrams, but it is actually
just an explicitely specified tree::

       Value
          \
           \
          Float
          /   \
         /     \
     Integer    \
       / \       F1
      /   \
     I1   I2

This diagram contains three Python types I1, I2 and F1, and three "concepts"
Integer, Float and Value, which are just names.  The types I1 and I2 could be
two different ways to implement integers (e.g. machine-sized ints, and
variable-sized longs), and the type F1 could be the IEEE doubles.  Note that in
this model the real Python types are the "leaves" of the tree.

Consider the multimethod ``add(Value, Value)``.  The signature specifies that
the two arguments should be two Values (remember that Value is not a type,
just some "concept"; you cannot ask whether a Python object is a Value or
not).  Suppose that this multimethod has got three implementations:
``add(I1,I1)``, ``add(I1,I2)`` and ``add(F1,F1)``.  If you call ``add(t1,t2)`` with
two objects of type ``I1``, the first implementation is used; if you call it
with a ``I1`` and a ``I2``, the second one is used; and if you call it with two
``F1``, the third one is used.

But if you call it with another pattern of types, there is no direct match.  
To be able to satisfy the call, at least one of the arguments will have to be
converted to another type.  This is where the shape of the tree becomes
important.  Remember that the signature of the multimethod is ``add(Value,
Value)``.  The two ``Value`` here mean that conversions are allowed inside of
the part of the tree that is below ``Value``.  (This is the tree shown above;
maybe there are other "concepts" above ``Value`` outside the picture, but they
are ignored.)  The intuitive meaning of the signature is: "add() is an
operation between two Values".  It allows an object of type I1 to be converted
into an object of type I2 or F1 and vice-versa, as long as the objects have the
same "Value", in an intuitive sense.  An example of conversion that destroys
the Value would be casting a I1 object into an instance of ``object``, which is
a parent class of any Python class.


Conversion
----------

All conversions that don't change the "Value" of an object can be registered
as Python functions.  For example::

    def f(x):
        return F1(x)

might be a conversion from I1 to F1.  But we can say more: this conversion is
more precisely defined at the level of "Float" in the tree above.  
Similarily, a conversion from I1 to I2 would probably be defined at the
"Integer" level.

Suppose that we have defined these two conversions, from I1 to F1 and
from I1 to I2.  Suppose now that we call ``add(i,f)`` where ``i`` is of
type I1 and ``f`` is of type F1.  Clearly, we want ``i`` to be converted
into a F1, which allows ``add(Value, Value)`` to be called and
dispatched to the ``add(F1,F1)`` implementation.  To find this
conversion, the algorithm looks into the subconcepts of ``Value``,
starting from the leaves and going back to the higher levels, until it
can satisfy the call request by inserting conversions registered at
these levels.

Starting from the lower levels and going up allows the tree to prioritize the
solutions: it is better to try to convert between Integers, and only if that
fails, to try to convert at the Float level, which might promote integer
objects into floats.


Multimethod signature
---------------------

The signature ``add(Value, Value)`` of the multimethod is essential to specify
that conversions are indeed allowed for the addition.  In other multimethods,
some arguments might play different roles.  Consider a multimethod for
"in-place addition": as this operation might mutate its first argument, it
must never be automatically converted.  This is expressed by saying that the
signature of this multimethod is ``inplace_add(Identity, Value)`` where
``Identity`` is another concept that intuitively means "a Python object whose
identity is important".  ``Identity`` would not appear in a tree, or if it
would, it would not have conversions between its subtypes.

Note how a real Python object of type I1 can either be an "Integer" or an
"Identity" depending on its role in a multimethod call.  This is why we cannot
use normal inheritance as the (global) conversion tree: which tree to use
depends on the role of the argument, which changes in different positions of
different multimethods.

This approach is general enough to allow arguments to play very different
roles.  For example, the same mecanisms could be used for an argument that
must be an integer: the multimethod signature would specify ``Integer``
instead of ``Value``.  It still allows conversion between integer
representations, but not from float to int.

In PyPy, some "concepts" are by convention tied to the application-level
types: ``Integer`` corresponds to the application-level ``class int``,
and ``Float`` to ``class float``.  The I1, I2 and F1 types are
interpreter-level implementations, and they are normally not visible at
application-level.  It is then natural to define what the method
``int.__add__(self, other)`` should do: it should require an ``Integer``
as its first argument, but it could be I1 or I2 -- appropriate conversions
can be done, as long as we don't convert ``self`` outside the realm of
``Integer``.


Conversion multimethods
-----------------------

As conversion functions are linked to levels in the tree, and there can be
several conversions for each level, they are much like multimethods
themselves.  In other words, for each "concept" (Value, Float, Integer) we can
introduce a multimethod (valueconv, floatconv, integerconv) with the
corresponding signature (``valueconv(Value)``, ``floatconv(Float)``,
``integerconv(Integer)``).  Specific conversion functions are implementations
of one of these multimethods.  For example, if ``g`` is a I1-to-I2 conversion,
it is an implementation of ``integerconv(Integer)``, with the type ``g(I1)``.

The job of the multimethod dispatcher algorithm is to insert the appropriate
implementations of the allowed ``xxxconv(Xxx)`` multimethods until the call
can be satisfied.

A nice point of view is that these conversion multimethod are identity
functions (i.e. functions that do nothing, and return their argument
unmodified): ``integerconv(Integer)`` is the abstract function that takes an
Integer and just returns it; an implementation like ``g(I1)`` actually takes a
I1 and returns a I2, which is different, but when you look at it abstractedly at
the Integer level, you just see an Integer input argument and the same Integer
result.


Algorithm
---------

Here is a suggested algorithm.  Roughly, it assumes that arguments with the
same abstract signature (e.g. ``Value`` in ``add(Value, Value)``) work
together, but arguments with distinct signature are independent.

Assume that the signature of a multimethod is ``m(C1,...,Cn)``, and we want to
dispatch the call ``m(A1,...,An)``, where the arguments have types
``T1,...,Tn`` respectively.  Each type ``Ti`` must appear in the subtree below
``Ci``, otherwise it is a TypeError.

We use a single set S of types and concepts, which will grow until it is large
enough to contain the appropriate conversion functions::

    S = { }   # empty set
    sortedmatches = []
    while 1:
        find_matches_in(S)
        i = the largest integer in {1,...,n} such that Ci not in S
                       or break if there isn't any such i any more
        C = the first item in order(Ci) such that C not in S
        add C into S
        also add into S the whole subtree of C

where ``order(C)`` is a kind of "method resolution order" of everything
*under* ``C`` (instead of *over* ``C`` for Python's MRO).  For example,
following Python 2.2::

    def order(C):
        lst = []
        for j in range(n,0,-1):
            if Tj in subtree(C):
                lst += [Tj, parent(Tj), parent(parent(Tj)), ..., C]
        for each D that appears more than once in lst:
            remove all but the last occurrence of D in lst
        return lst

The algorithm in Python 2.3 is slightly different, and could probably be used
instead, though the difference should not be significant for the kind of trees
we are using.

Finally::

    def find_matches_in(S):
        matches = list_matches_in(S)
        remove from matches the items already in sortedmatches
        if len(matches) > 1:
            warning ambiguity, or maybe use performance hints
        sortedmatches += matches

    def list_matches_in(S):
        conv = { implementations of the conversion multimethod of C
                 for C in S }
        combine in all possible ways the functions in conv to change
                 the types T1,...,Tn into the types U1,...,Un of an
                 implementation of the multimethod to call

The resulting ``sortedmatches`` list contains, in preference order, the
implementations that are available to be dispatched to.  We generally just
call the first one, but it (or any later one) may raise FailedToImplement; in
this case the dispatcher tries the next one.

The rest of the algorithm are implementation and performance tricks, e.g. it
should try to call a given conversion function only once and remember the
value of the converted argument in case we need it again after a
FailedToImplement.
