==================================
Getting started with PyPy
==================================

.. contents::
.. sectnum::

.. _howtopypy: 

Just the facts 
============== 

getting & running the PyPy 0.6 release 
---------------------------------------

Download one of the following release files and unpack it: 

*pypy-0.6 (not released yet)*
    
    * download `pypy-0.6.zip` or `pypy-0.6.tar.gz` and unpack it 
    
    * alternatively run ``svn co http://codespeak.net/svn/pypy/tag/0.6 pypy-0.6`` 

then change to the ``pypy-0.6`` directory
and execute the following command line:: 

    python pypy/bin/py.py 

This will give you a PyPy prompt, i.e. a very compliant 
Python interpreter implemented in Python.  Because this version
of PyPy still runs on top of CPython, it runs around 3000-4000
times slower than the original CPython.  The 0.6 release focus 
really was on compliancy: PyPy passes around `90% of CPythons core 
language regression tests`_. 

Have a look at `interesting starting points`_ 
for guidance on how to continue. 

.. _`90% of CPythons core language regression tests`: http://codespeak.net/~hpk/pypy-testresult/ 

Svn-check out & run the latest PyPy as a two-liner
--------------------------------------------------

If you want to play with the ongoing development PyPy version 
you can check it out from the repository using subversion. Download 
and install subversion_ if you don't allready have it. Then you can
issue on the command line (DOS box or terminal)::

    svn co http://codespeak.net/svn/pypy/dist pypy-dist 

This will create a directory named ``pypy-dist``, and will get you the PyPy
source in ``pypy-dist/pypy`` and documentation files in
``pypy-dist/pypy/documentation``.

After checkout you can get a PyPy interpreter via:: 

    python pypy-dist/pypy/bin/py.py

have fun :-) 

We have some `help on installing subversion`_ for PyPy. 
Have a look at `interesting starting points`_ 
for some guidance on how to continue. 

.. _`help on installing subversion`: svn-help.html

Understanding PyPy's architecture
---------------------------------

For in-depth information about architecture and coding documentation 
head over to the `documentation section`_ where you'll find lots of 
interesting information.  Additionally, in true hacker spirit, you 
may just `start reading sources`_ . 

.. _`documentation section`: index.html 

running all of PyPy's tests  
---------------------------

If you want to see if PyPy works on your machine/platform 
you can simply run PyPy's large test suite with:: 

    python pypy/test_all.py 

test_all.py is just another name for `py.test`_ which is the
testing tool that we are using and enhancing for PyPy.   

.. _`py.test`: http://codespeak.net/py/current/doc/test.html 

Filing bugs or feature requests 
-------------------------------

You may file `bug reports`_ on our issue tracker which is
also accessible through the 'issues' top menu of 
the PyPy website.  `using the development tracker`_ has 
more detailed information on specific features of the tracker. 

.. _`using the development tracker`: coding-guide.html#using-development-tracker

.. _`interesting starting points`: 

Interesting Starting Points in PyPy 
===================================

The following assumes that you have successfully downloaded and exctracted the
PyPy release or have checked out PyPy using svn. It assumes that you are in
the top level directory of the PyPy source tree, e.g. pypy-x.x (if you
got a release) or pypy-dist (if you checked out the most recent version using
subversion).

Main entry point / special PyPy features 
------------------------------------------

The py.py interpreter
+++++++++++++++++++++

To start interpreting Python with PyPy, use Python 2.3 or greater::

    cd pypy/bin
    python py.py

After a few seconds (remember: this is running on top of CPython), 
you should be at the PyPy prompt, which is the same as the Python 
prompt, but with an extra ">".

Now you are ready to start running Python code.  Most Python
modules should work if they don't involve CPython extension 
modules.  Here is an example of determining PyPy's performance 
in pystones:: 

    >>>> from test import pystone 
    >>>> pystone.main(10)

Note that this is a slightly modified version of pystone -- the
original version does not accept the parameter to main().  The
parameter is the number of loops to run through the test, and the
default is 50000, which is far too many to run in a reasonable time
on the current PyPy implementation.

py.py options
+++++++++++++

To list the PyPy interpreter command line options, type::

    cd pypy/bin
    python py.py --help

As an example of using PyPy from the command line, you could type::

    python py.py -c "from test import pystone; pystone.main(10)"

Alternatively, as with regular Python, you can simply give a
script name on the command line::

    python py.py ../../lib-python/modified-2.3.4/test/pystone.py 10

Interpreter-level console
+++++++++++++++++++++++++

There are a few extra features of the PyPy console: If you press
<Ctrl-C> on the console you enter the interpreter-level console, a
usual CPython console.  You can then access internal objects of PyPy
(e.g. the object space) and any variables you have created on the PyPy
prompt with the affix ``w_``:: 

    >>>> a = 123
    >>>> <Ctrl-C>
    *** Entering interpreter-level console ***
    >>> w_a
    W_IntObject(123)

Note that the prompt of the interpreter-level console is only '>>>' since
it runs on CPython level. To return to PyPy, press <Ctrl-D>.

Tracing bytecode and operations on objects
++++++++++++++++++++++++++++++++++++++++++ 

You can use the trace object space to monitor the interpretation
of bytecodes in connection with object space operations.  To enable 
it, set ``__pytrace__=1`` on the interactive PyPy console:: 

    >>>> __pytrace__ = 1
    Tracing enabled
    >>>> a = 1 + 2
    |-<<<<<enter <inline>a = 1 + 2 @ 1>>>>>>>
    |- 0    LOAD_CONST    0 (W_IntObject(1))
    |- 3    LOAD_CONST    1 (W_IntObject(2))
    |- 6    BINARY_ADD
      |-                 >> add(W_IntObject(1), W_IntObject(2))
      |-                    add =: W_IntObject(3)
    |- 7    STORE_NAME    0 (a)
      |-                 >> setitem(globals(), W_StringObject('a'), W_IntObject(3))
      |-                    setitem =: <W_NoneObject()>
    |-10    LOAD_CONST    2 (<W_NoneObject()>)
    |-13    RETURN_VALUE
    |-<<<<<leave <inline>a = 1 + 2 @ 1>>>>>>>

lazily computed objects 
+++++++++++++++++++++++

One of the original features provided by the py.py interpreter that are
without equivalent in CPython is the "thunk" object space, providing
lazily-computed objects in a transparent manner::

    cd pypy/bin
    python py.py -o thunk

    >>>> def longcomputation(lst):
    ....     print "computing..."
    ....     return sum(lst)
    .... 
    >>>> x = thunk(longcomputation, range(5))
    >>>> y = thunk(longcomputation, range(10))

from the application perspective, ``x`` and ``y`` represent 
exactly the objects being returned by the ``longcomputation()``
invocations.  You can put these objects into a dictionary 
without triggering the computation:: 

    >>>> d = {5: x, 10: y}
    >>>> result = d[5]
    >>>> result
    computing...
    10
    >>>> type(d[10])
    computing...
    <type 'int'>
    >>>> d[10]
    45

It is interesting to note that this lazy-computing Python extension 
is solely implemented in a small `objspace/thunk.py`_ file consisting 
of around 100 lines of code. 

Running the tests
+++++++++++++++++

The PyPy project uses test-driven-development.  Right now, there are
a couple of different categories of tests which you can run.
To run all the unit tests::

    cd pypy
    python test_all.py

Alternatively, you may run subtests by going to the correct subdirectory
and running them individually::

    python test_all.py module/test/test_builtin.py

``test_all.py`` is actually just a synonym for `py.test`_ which is 
our external testing tool. If you have installed that then you 
can as well just issue ``py.test DIRECTORY_OR_FILE`` in order 
to perform test runs or simply start it without arguments to 
run all tests below the current directory. 

Finally, there are standard regression tests which you can 
run like this::

    cd lib-python-2.3.4/test 
    python ../../pypy/test_all.py -E

or if you have `installed py.test`_ then you simply say::

    py.test -E

from the lib-python-2.3.4/test directory. 

.. _`installed py.test`: http://codespeak.net/py/current/doc/getting_started.html

Demos
+++++

The `demo/`_ directory contains examples of various aspects of PyPy,
ranging from running regular Python programs (that we used as compliance goals) 
over experimental distribution mechanisms to examples translating 
sufficiently static programs into low level code. 

.. _`try out the translator`:

Trying out the translator
------------------------- 

The translator is a tool based on the PyPy interpreter which can translate
sufficiently static Python programs into low-level code.

1. Download and install `Dot Graphviz`_.

2. Download and install Pygame_ if you do not already have it.

3. Type::

        cd pypy/bin
        python translator.py

   Test snippets of translatable code are provided in the file
   ``pypy/translator/test/snippet.py``, which is imported under the name
   ``test``.  For example::

        >>> t = Translator(test.is_perfect_number)
        >>> t.view()
        
.. >>> from pypy.translator.translator import Translator 
.. >>> from pypy.translator.test import snippet as test 

4. We have a type annotator that can completely infer types for functions like
   ``is_perfect_number`` (as well as for much larger examples)::

        >>> a = t.annotate([int])
        >>> t.view()

   Move the mouse over variable names (in red) to see their inferred types. To
   perform simplifications based on the annotation you can do::

        >>> a.simplify()

5. The graph can be turned into C code::

       >>> a.specialize()
       >>> f = t.ccompile()

   The first command replaces operations with variables of types that are
   avaiable in C (e.g. int) with low level versions. This can be ommited if no
   annotation (step 4) has been performed.

6. If you feel adventureous (and have LLVM installed and on your path) you can
   also try to compile the graph with LLVM. This is still quite experimental
   and only works with some functions: One of the most visible restriction is
   that return type of the entry function has to be and int, float or bool. To
   try it do::

       >>> print t.llvm()
       >>> f = t.llvmcompile(optimize=True)
       >>> f(28)
       1

   This works only with fully annotated graphs.

7. There is a small-to-medium demo showing the translator and the annotator::

       cd demo
       python bpnn.py

   This causes ``bpnn.py`` to display itself as a call graph and class
   hierarchy.  Clicking on functions shows the flow graph of the particular
   function.  Clicking on a class shows the attributes of its instances.  All
   this information (call graph, local variables' types, attributes of
   instances) is computed by the annotator.

8. Not for the faint of heart nor the owner of a very old machine: you can
   run the annotator over the whole PyPy interpreter itself.  This is the
   largest and ultimate example of source that our annotator can (very
   successfully!) process::

       cd pypy/translator/goal
       python translate_pypy.py -no-t -no-c

   Moving around is difficult because of the sheer size of the result.
   For this reason, the debugger prompt you get at the end has been
   enhanced with commands to facilitate locating functions and classes.
   Type ``help graphs`` for a list of the new commands.  Help is also
   available on each of these new commands.

   The ``translate_pypy`` script itself takes a number of options controlling
   what to translate and how.  See ``translate_pypy.py -h``.  Try out::

       cd pypy/translator/goal
       python translate_pypy.py targetrpystone

   or a simplified, scaled-down version::

       python translate_pypy.py targetrpystone2


.. _`start reading sources`: 
   
Where to start reading the sources
---------------------------------- 

PyPy is made from parts that are relatively independent from each other.
You should start looking at the part that attracts you most (all parts are
relative to the PyPy toplevel directory):

*  `pypy/interpreter`_ contains the basic interpreter: bytecode dispatcher
   in pyopcode.py_, frame and code objects in eval.py_ and pyframe.py_,
   function objects and argument passing in function.py_ and argument.py_,
   the object space interface definition in baseobjspace.py_, modules in
   module.py_ and mixedmodule.py_.  Core types supporting the interpreter are
   defined in typedef.py_.

*  `pypy/objspace/std`_ contains the `Standard object space`_.  The main file
   is objspace.py_.  For each type, the files ``xxxtype.py`` and
   ``xxxobject.py`` contain respectively the definition of the type and its
   (default) implementation.

*  `pypy/objspace`_ contains a few other object spaces: the thunk_
   one, the trace_ one, the flow_ one.  The latter is a relatively short piece
   of  code that builds the control flow graphs when the interpreter runs in it.

*  `pypy/translator`_ contains the code analysis and generation stuff.
   Start reading from translator.py_, from which it should be easy to follow
   the pieces of code involved in the various translation phases.

*  `pypy/annotation`_ contains the data model for the type annotation that
   can be inferred about a graph.  The graph "walker" that uses this is in
   `pypy/translator/annrpython.py`_.


To learn more
------------- 

* To learn more about PyPy and its development process,  
  read around in the documentation_ and consider 
  subscribing to the `mailing lists`_ (or simply
  read the archives online) 
  
* show up on irc.freenode.net:6667, channel #pypy and ask
  questions.  The logs of the channel can be found at 
  http://nimrod.terra-link.net/pypy/_.

* To help PyPy become Python-the-next-generation, you 
  are invited to participate in its development. 
   
.. _optionaltool: 

Additional Tools for running (and hacking) PyPy 
-----------------------------------------------

We use some optional tools for working on pypy. They are not required to run 
the basic tests or to get an interactive PyPy prompt but they help to
understand  and debug PyPy especially for the ongoing translation work.  

Recommended tools 
+++++++++++++++++

*graphviz* 

	(used for visualizing the control-flow)
	http://www.research.att.com/sw/tools/graphviz/download.html 

*pygame*

	(to visualize control flow and annotation analysis of python programs)
	http://www.pygame.org/download.shtml

Optional tools 
++++++++++++++ 

*llvm* 

    (used for the optional LLVM translation backend)
    One of our backends uses the `low level virtual machine`_ to generate
    processor independant machine level code.

    LLVM can be quite annoying to install: you need a fairly recent version of
    GCC to compile it and there can be severe problems under windows. There are
    detailed instructions on `how to install LLVM`_. To use the LLVM backend
    you don't need the GCC front end of LLVM, only LLVM itself. If you run
    into problems with the installation the `LLVM mailing list`_ is very
    helpful and friendly.

*CLISP* 

    (used for the optional Lisp translation backend)
	http://clisp.cons.org/_


.. _`low level virtual machine`: http://llvm.cs.uiuc.edu/
.. _`how to install LLVM`: http://llvm.cs.uiuc.edu/docs/GettingStarted.html
.. _`LLVM mailing list`: http://mail.cs.uiuc.edu/mailman/listinfo/llvmdev


.. _Dot Graphviz:           http://www.research.att.com/sw/tools/graphviz/
.. _Pygame:                 http://www.pygame.org/
.. _pyopcode.py:            http://codespeak.net/svn/pypy/dist/pypy/interpreter/pyopcode.py
.. _eval.py:                http://codespeak.net/svn/pypy/dist/pypy/interpreter/eval.py
.. _pyframe.py:             http://codespeak.net/svn/pypy/dist/pypy/interpreter/pyframe.py
.. _function.py:            http://codespeak.net/svn/pypy/dist/pypy/interpreter/function.py
.. _argument.py:            http://codespeak.net/svn/pypy/dist/pypy/interpreter/argument.py
.. _baseobjspace.py:        http://codespeak.net/svn/pypy/dist/pypy/interpreter/baseobjspace.py
.. _module.py:              http://codespeak.net/svn/pypy/dist/pypy/interpreter/module.py
.. _mixedmodule.py:          http://codespeak.net/svn/pypy/dist/pypy/interpreter/mixedmodule.py
.. _typedef.py:             http://codespeak.net/svn/pypy/dist/pypy/interpreter/typedef.py
.. _Standard object space:  http://codespeak.net/pypy/index.cgi?doc/stdobjspace.html
.. _objspace.py:            http://codespeak.net/svn/pypy/dist/pypy/objspace/std/objspace.py
.. _thunk:                  http://codespeak.net/svn/pypy/dist/pypy/objspace/thunk.py
.. _trace:                  http://codespeak.net/svn/pypy/dist/pypy/objspace/trace.py
.. _flow:                   http://codespeak.net/svn/pypy/dist/pypy/objspace/flow/
.. _translator.py:          http://codespeak.net/svn/pypy/dist/pypy/translator/translator.py
.. _mailing lists:          http://codespeak.net/pypy/index.cgi?lists
.. _documentation:          index.html 
.. _wiki:                   http://codespeak.net/moin/pypy/moin.cgi/FrontPage?action=show
.. _unit tests:             http://codespeak.net/pypy/index.cgi?doc/testdesign.html
.. _bug reports:            https://codespeak.net/issue/pypy-dev/


.. _`directory reference`: 

PyPy directory reference 
======================================================

Here is a fully referenced alphabetical two-level deep 
directory overview of PyPy: 

============================   =========================================== 
Directory                      explanation/links
============================   =========================================== 
`annotation/`_                 `type inferencing code`_ for `RPython`_ programs 

`documentation/`_              text versions of PyPy `documentation`_ files shown on the website 

`documentation/revreport/`_    the source code for the `revision report`_ 

`documentation/website/`_      text versions of the navigation webpages 

`interpreter/`_                bytecode interpreter and related objects (frames, functions, modules,...) 

`lib/`_                        PyPy's wholesale reimplementations of CPython modules_

`lib/test2/`_                  tests running at interp-level against the reimplementations 

`module/`_                     contains `mixed modules`_ implementing core modules with 
                               both application and interpreter level code 

`module/_sre_pypy/`_           an experimental approach wrapping CPython's ``_sre`` module 
                               without using faking 

`module/builtin/`_             full implementation of CPython's ``__builtin__`` module. 

`module/parser/`_              parser package from Jonathan David Riehl's `basil`_ package

`module/recparser/`_           parser package from Logilab 

`module/sys2/`_                implementation of CPython's ``sys`` module.  

`objspace/`_                   `object space`_ implementations

`objspace/trace.py`_           the `trace object space`_ monitoring bytecode and space operations

`objspace/thunk.py`_           the `thunk object space`_, providing unique object features 

`objspace/flow/`_              the FlowObjSpace_ implementing `abstract interpretation`

`objspace/std/`_               the StdObjSpace_ implementing CPython's objects and types

`rpython/`_                    the `RPython Typer`_ 

`tool/`_                       various utilities and hacks used from various places 

`tool/pytest/`_                support code for our `testing methods`_

`tool/tb_server/`_             a somewhat outdated http-server for presenting 
                               tracebacks in a helpful manner 

`translator/`_                 translation_ backends and support code

`translator/genc/`_            the `GenC backend`_ producing a CPython C-extension 
                               module from a given RPython program. 

`translator/java/`_            experimental code to utilize Java for annotation 

`translator/llvm/`_            contains the `LLVM backend`_ producing LLVM assembler 
                               from fully annotated RPython programs 

`translator/tool/`_            helper tools for translation 

``*/test/``                    many directories have a test subdirectory containing test 
                               modules (see `Testing in PyPy`_) 

``_cache/``                    holds cache files from internally translating application 
                               level to interpreterlevel code.  (XXXM0.5 insert link here 
                               when geninterp documentation is there). 
============================   =========================================== 

.. _`Testing in PyPy`: coding-guide.html#testing-in-pypy 
.. _`mixed modules`: coding-guide.html#mixed-modules 
.. _`modules`: coding-guide.html#modules 
.. _`basil`: http://people.cs.uchicago.edu/~jriehl/BasilTalk.pdf
.. _`object space`: objspace.html
.. _FlowObjSpace: objspace.html#the-flow-object-space 
.. _`trace object space`: objspace.html#the-trace-object-space 
.. _`thunk object space`: objspace.html#the-thunk-object-space 
.. _StdObjSpace: objspace.html#the-standard-object-space 
.. _`abstract interpretation`: theory.html#abstract-interpretation
.. _`rpython`: coding-guide#rpython 
.. _`type inferencing code`: translation#the-annotation-pass 
.. _`RPython Typer`: translation.html#rpython-typer 
.. _`testing methods`: coding-guide.html#testing-in-pypy
.. _`translation`: translation.html 
.. _`GenC backend`: translation.html#genc 
.. _`LLVM backend`: translation.html#llvm 
.. _`revision report`: http://codespeak.net/pypy/rev/current 

.. _subversion: svn-help.html

.. include:: _ref.txt
