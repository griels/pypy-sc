==================
PyPy Object Spaces
==================

.. contents::
.. sectnum::


.. _`Object Spaces`: architecture.html#the-object-space


Introduction 
============

This document describes aspects of the implementation of PyPy's `Object Spaces`_.


Object Space Interface
======================

This is a draft version of the Object Space interface. It is still evolving, although the public interface is not evolving as much as the internal interface that subclasses need to know about. This document now generally refers to the public interface; for subclassing you need to poke at the code in detail anyway.


Administrative Functions
----------------------------

**initialize():**
  Function which initializes w_builtins and the other w_constants.

**getexecutioncontext():**
  Return current active execution context.

Operations on Objects in ObjSpace
-----------------------------------------

These functions both take and return "wrapped" objects.

*The following functions implement the same operations as those in CPython:*

``id, type, issubtype, iter, repr, str, len, hash,``

``getattr, setattr, delattr, getitem, setitem, delitem,``

``pos, neg, not_, abs, invert, add, sub, mul, truediv, floordiv, div, mod, divmod, pow, lshift, rshift, and_, or_, xor,``

``hex, oct, int, float, ord,``

``lt, le, eq, ne, gt, ge, contains,``

``inplace_add, inplace_sub, inplace_mul, inplace_truediv, inplace_floordiv, inplace_div, inplace_mod, inplace_pow, inplace_lshift, inplace_rshift, inplace_and, inplace_or, inplace_xor,``

``get, set, delete``

**next(w):**
  Call the next function for iterator w, or raises a real NoValue.

**call(w_callable, w_args, w_kwds):**
  Call a function with the given args and keywords.

**call_function(w_callable, *args_w, **kw_w):**
  Convenience function that collects the arguments in a wrapped tuple and dict and invokes 'call()'.

**is_(w_x, w_y):**
  Implements 'w_x is w_y'. (Returns a wrapped result too!)

**isinstance(w_obj, w_type):**
  Implements 'issubtype(type(w_obj), w_type)'. (Returns a wrapped result too!)

**exception_match(w_exc_type, w_check_class):**
  Checks if the given exception type matches 'w_check_class'. Used in matching the actual exception raised with the list of those to catch in an except clause. (Returns a wrapped result too!)

Creation of Application Level objects
---------------------------------------

**wrap(x):**
  Returns a wrapped object that is a reference to the interpreter-level object x. This can be used either on simple immutable objects (integers, strings...) to create a new wrapped object, or on complex mutable objects to obtain an application-level-visible reference to them (e.g. instances of internal interpreter classes).

**newbool(b):**
  Creates a Bool Object from an interpreter level object.

**newtuple([..]):**
  Take an interpreter level list of wrapped objects.

**newlist([..]):**
  Takes an interpreter level list of wrapped objects.

**newdict([..]):**
  Takes an interpreter level list of interpreter level pairs of wrapped key:wrapped value entries (and NOT an interpreter level dictionary!).

**newslice(w_start, w_end, w_step):**
  Makes a new slice object.

**newstring(asciilist):**
  Creates a string from a list of wrapped integers.

Conversions from Application Level to Interpreter Level
----------------------------------------------------------

**unwrap(w_x):**
  Return Interpreter Level equivalent of w_x

**interpclass_w(w_x):**
  If w_x is a wrapped instance of an interpreter class -- for example Function, Frame, Cell, etc. -- return it unwrapped.  Otherwise return None.

**int_w(w_x):**
  If w_x is an application-level integer or long which can be converted without overflow to an integer, return an interpreter-level integer.  Otherwise raise TypeError or OverflowError.

**str_w(w_x):**
  If w_x is an application-level string, return an interpreter-level string.  Otherwise raise TypeError.

**float_w(w_x):**
  If w_x is an application-level float, integer or long, return interpreter-level float.  Otherwise raise TypeError or OverflowError in case of very large longs.

**is_true(w_x):**
  Return a interpreter level bool (True or False).

**unpackiterable(w_iterable, expected_length=None):**
  Unpack an iterable object into a real (interpreter level) list. Raise a real ValueError if the expected_length is wrong.

**unpacktuple(w_tuple, expected_length=None):**
  Same as unpackiterable(), but only for tuples.


Data Members
-----------------

+ self.builtin
+ self.sys
+ self.w_None: The ObjSpace's None
+ self.w_True: The ObjSpace's True
+ self.w_False: The ObjSpace's False
+ self.w_Ellipsis: The ObjSpace's Ellipsis
+ self.w_NotImplemented: The ObjSpace's NotImplemented

+ ObjSpace.MethodTable:
   List of tuples (method name, symbol, number of arguments, list of special names) for the regular part of the interface. (Tuples are interpreter level.)

+ ObjSpace.BuiltinModuleTable:
   List of names of built-in modules.

+ ObjSpace.ConstantTable:
   List of names of the constants that the object space should define

+ ObjSpace.ExceptionTable:
   List of names of exception classes.


.. _`standard object space`: 

The Standard Object Space
=========================

Introduction
------------

The Standard Object Space (StdObjSpace_) is the direct equivalent of CPython's object library (the "Objects/" subdirectory in the distribution). It is an implementation of the common Python types in a lower-level language.

The Standard Object Space defines an abstract parent class, W_Object, and a bunch of subclasses like W_IntObject, W_ListObject, and so on. A wrapped object (a "black box" for the interpreter main loop) is thus an instance of one of these classes. When the main loop invokes an operation, say the addition, between two wrapped objects w1 and w2, the Standard Object Space does some internal dispatching (similar to "Object/abstract.c" in CPython) and invokes a method of the proper W_XyzObject class that can do the operation. The operation itself is done with the primitives allowed by RestrictedPython. The result is constructed as a wrapped object again. For example, compare the following implementation of integer addition with the function "int_add()" in "Object/intobject.c": ::

    def add__Int_Int(space, w_int1, w_int2):
        x = w_int1.intval
        y = w_int2.intval
        try:
            z = ovfcheck(x + y)
        except OverflowError:
            raise FailedToImplement(space.w_OverflowError,
                                    space.wrap("integer addition"))
        return W_IntObject(space, z)

Why such a burden just for integer objects? Why did we have to wrap them into W_IntObject instances? For them it seems it would have been sufficient just to use plain Python integers. But this argumentation fails just like it fails for more complex kind of objects. Wrapping them just like everything else is the cleanest solution. You could introduce case testing wherever you use a wrapped object, to know if it is a plain integer or an instance of (a subclass of) W_Object. But that makes the whole program more complicated. The equivalent in CPython would be to use PyObject* pointers all around except when the object is an integer (after all, integers are directly available in C too). You could represent small integers as odd-valuated pointers. But it puts extra burden on the whole C code, so the CPython team avoided it.

In our case it is a later optimization that we could make. We just don't want to make it now (and certainly not hard-coded at this level -- it could be introduced by the code generators at translation time). So in summary: wrapping integers as instances is the simple path, while using plain integers instead is the complex path, not the other way around.

Note that the Standard Object Space implementation uses MultiMethod_ dispatch instead of the complex rules of "Object/abstract.c". I think that this can be translated to a different low-level dispatch implementation that would be binary compatible with CPython's (basically the PyTypeObject structure and its function pointers). If compatibility is not required it will be more straightforwardly converted into some efficient multimethod code.

.. _StdObjSpace: http://codespeak.net/svn/pypy/dist/pypy/objspace/std/
.. _MultiMethod: theory.html#multimethods


Object types
------------

The larger part of the `StdObjSpace`_ package defines and implements the library of Python's standard built-in object types.  Each type (int, float, list, tuple, str, type, etc.) is typically implemented by two modules:

* the *type specification* module, which for a type ``xxx`` is called ``xxxtype.py``;

* the *implementation* module, called ``xxxobject.py``.

The ``xxxtype.py`` module basically defines the type object itself.  For example, `listtype.py`_ contains the specification of the object you get when you type ``list`` in a PyPy prompt.  `listtype.py`_ enumerates the methods specific to lists, like ``append()``.

A particular method implemented by all types is the ``__new__()`` special method, which in Python's new-style-classes world is responsible for creating an instance of the type.  In PyPy, ``__new__()`` locates and imports the module implementing *instances* of the type, and creates such an instance based on the arguments the user supplied to the constructor.  For example, `tupletype.py`_ defines ``__new__()`` to import the class ``W_TupleObject`` from `tupleobject.py`_ and instantiate it.  The `tupleobject.py`_ then contains a "real" implementation of tuples: the way the data is stored in the ``W_TupleObject`` class, how the operations work, etc.

The goal of the above module layout is to cleanly separate the Python type object, visible to the user, and the actual implementation of its instances.  It is possible (though not done so far) to provide *several* implementations of the instances of the same Python type.  The ``__new__()`` method could decide to create one or the other.  From the user's point of view, they are still all instances of exactly the same type; the possibly multiple internal ``W_XxxObject`` classes are not visible.  PyPy knows that (e.g.) the application-level type of its interpreter-level ``W_TupleObject`` instances is "tuple" because there is a ``typedef`` class attribute in ``W_TupleObject`` which points back to the tuple type specification from `tupletype.py`_.

.. _`listtype.py`: http://codespeak.net/svn/pypy/dist/pypy/objspace/std/listtype.py
.. _`tupletype.py`: http://codespeak.net/svn/pypy/dist/pypy/objspace/std/tupletype.py
.. _`tupleobject.py`: http://codespeak.net/svn/pypy/dist/pypy/objspace/std/tupleobject.py



The Trace Object Space
======================

XXX see `this overview`_.

.. _`this overview`: architecture.html#trace-object-space


The Thunk Object Space
======================

This small object space, meant as a nice example, wraps another object space (e.g. the standard one) and adds two capabilities: lazily computed objects (computed only when an operation is performed on them), and "become", which completely and globally replaces an object with another.

Example usage::

    $ python interpreter/py.py -o thunk
    >>>> def f():
    ...     print 'computing...'
    ...     return 6*7
    ...
    >>>> x = thunk(f)
    >>>> x
    computing...
    42
    >>>> x
    42
    >>>> y = thunk(f)
    >>>> type(y)
    computing...
    <pypy type 'int'>


The Flow Object Space
=====================

Introduction
------------

The task of the FlowObjSpace_ is to generate a control-flow graph from a function.  This graph will also contain a trace of the individual operations, so that it is actually just an alternate representation for the function.

The FlowObjSpace is an object space, which means that it exports the standard object space interface and it is driven by the interpreter.

The basic idea is that if the interpreter is given a function, e.g.::

  def f(n):
    return 3*n+2

it will do whatever bytecode dispatching and stack-shuffling needed, during which it issues a sequence of calls to the object space.  The FlowObjSpace merely records these calls (corresponding to "operations") in a structure called a basic block.  To track which value goes where, the FlowObjSpace invents placeholder "wrapped objects" and give them to the interpreter, so that they appear in some next operation.  This technique is an example of `Abstract Interpretation`_.

.. _`Abstract Interpretation`: theory.html#abstract-interpretation

For example, if the placeholder ``v1`` is given as the argument to the above function, the interpreter will call ``v2 = space.mul(space.wrap(3), v1)`` and then ``v3 = space.add(v2, space.wrap(2))`` and return ``v3`` as the result.  During these calls the FlowObjSpace will record a basic block::

  Block(v1):     # input argument
    v2 = mul(Constant(3), v1)
    v3 = add(v2, Constant(2))


.. _FlowObjSpace: http://codespeak.net/svn/pypy/dist/pypy/objspace/flow/


The Flow model
--------------

``pypy.objspace.flow.model`` defines the data model used by the flow graphs, as created by the FlowObjSpace, manipulated by ``pypy.translator.simplify`` and ``pypy.translator.transform``, and in general read by almost all the modules in ``pypy.translator``.

It is recommended to play with ``python translator.py`` on a few examples to get an idea of the structure of flow graphs.  Here is a short summary of the non-obvious parts.


FunctionGraph
    A container for one graph (corresponding to one function).

    :startblock:   the first block.  It is where the control goes when the function is called.  The input arguments of the startblock are the function's arguments.  If the function takes a ``*args`` argument, the ``args`` tuple is given as the last input argument of the startblock.
    :returnblock:  the (unique) block that performs a function return.  It is empty, not actually containing any ``return`` operation; the return is implicit.  The returned value is the unique input variable of the returnblock.
    :exceptblock:  the (unique) block that raises an exception out of the function.  The two input variables are the exception class and the exception value, respectively.  (No other block will actually link to the exceptblock if the function does not explicitely raise exceptions.)


Block
    A basic block, containing a list of operations and ending in jumps to other basic blocks.  All the values that are "live" during the execution of the block are stored in Variables.  Each basic block uses its own distinct Variables.

    :inputargs:   list of fresh, distinct Variables that represent all the values that can enter this block from any of the previous blocks.
    :operations:  list of SpaceOperations.
    :exitswitch:  see below
    :exits:       list of Links representing possible jumps from the end of this basic block to the beginning of other basic blocks.

    Each Block ends in one of the following ways:

    * unconditional jump: exitswitch is None, exits contains a single Link.
    * conditional jump: exitswitch is one of the Variables that appear in the Block, and exits contains one or more Links (usually 2).  Each Link's exitcase gives a concrete value.  This is the equivalent of a "switch": the control follows the Link whose exitcase matches the run-time value of the exitswitch Variable.  It is a run-time error if the Variable doesn't match any exitcase.  (Currently only used with 2 Links whose exitcase are False and True, respectively.)
    * exception catching: exitswitch is ``Constant(last_exception)``.  The first Link has exitcase set to None and represents the non-exceptional path.  The next Links have exitcase set to a subclass of Exception, and are taken when the *last* operation of the basic block raises a matching exception.  (Thus the basic block must not be empty, and only the last operation is protected by the handler.)
    * return or except: the returnblock and the exceptblock have operations set to an empty tuple, exitswitch to None, and exits empty.


Link
    A link from one basic block to another.

    :prevblock:  the Block that this Link is an exit of.
    :target:     the target Block to which this Link points to.
    :args:       a list of Variables and Constants, of the same size as the target Block's inputargs, which gives all the values passed into the next block.  (Note that each Variable used in the prevblock may appear zero, one or more times in the ``args`` list.)
    :exitcase:   see above.

    Note that ``args`` uses Variables from the prevblock, which are matched to the target block's ``inputargs`` by position, as in a tuple assignment or function call would do.


SpaceOperation
    A recorded (or otherwise generated) basic operation.

    :opname:  the name of the operation.  Generally one from the list in ``pypy.interpreter.baseobjspace``.
    :args:    list of arguments.  Each one is a Constant or a Variable seen previously in the basic block.
    :result:  a *new* Variable into which the result is to be stored.

    Note that operations usually cannot implicitely raise exceptions at run-time; so for example, code generators can assume that a ``getitem`` operation on a list is safe and can be performed without bound checking.  The exceptions to this rule are: (1) if the operation is the last in the block, which ends with ``exitswitch == Constant(last_exception)``, then the implicit exceptions must be checked for, generated, and caught appropriately; (2) calls to other functions, as per ``simple_call`` or ``call_args``, can always raise whatever the called function can raise --- and such exceptions must be passed through to the parent unless they are caught as above.


Variable
    A placeholder for a run-time value.  There is mostly debugging stuff here.

    :name:  it is good style to use the Variable object itself instead of its ``name`` attribute to reference a value, although the ``name`` is guaranteed unique.


Constant
    A constant value used as argument to a SpaceOperation, or as value to pass across a Link to initialize an input Variable in the target Block.

    :value:  the concrete value represented by this Constant.
    :key:    a hashable object representing the value.

    A Constant can occasionally store a mutable Python object.  It represents a static, pre-initialized, read-only version of that object.  The flow graph should not attempt to actually mutate such Constants.


XXX talk about implicit exceptions


How the FlowObjSpace works
--------------------------

The FlowObjSpace works by recording all operations issued by the interpreter into basic blocks.  A basic block ends in one of two cases: when the interpreters calls ``is_true()``, or when a joinpoint is reached.

* A joinpoint occurs when the next operation is about to be recorded into the current block, but there is already another block that records an operation for the same bytecode position.  This means that the interpreter has closed a loop and is interpreting already-seen code again.  In this situation, we interrupt the interpreter and we make a link from the end of the current block back to the previous block, thus closing the loop in the flow graph as well.  (Note that this occurs only when an operation is about to be recorded, which allows some amount of constant-folding.)

* If the interpreter calls ``is_true()``, the FlowObjSpace doesn't generally know if the answer should be True or False, so it puts a conditional jump and generates two successor blocks for the current basic block.  There is some trickery involved so that the interpreter is fooled into thinking that ``is_true()`` first returns False (and the subsequent operations are recorded in the first successor block), and later the *same* call to ``is_true()`` also returns True (and the subsequent operations go this time to the other successor block).

(This section to be extended...)
