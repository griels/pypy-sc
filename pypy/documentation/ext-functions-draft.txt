example of interp-level code needing to somehow call an external function::

    import os
    def open(space, w_fname):
        fname = space.str_w(fname)
        fd = os.open(fname)
        return space.wrap(fd)

* os.open will be special-cased along all translation levels, there
  will be a table mapping "sys calls" functions to the information
  needed by the various levels.
 
* annotation/builtin.py will take information from the common table 
  to annotate the calls.

* rtyper will replace the calls with for testing or dummy lowlevel
  functions (ll_os_open for os.open), specified somehow trough the
  table. The usual specialisation for low-level helpers will happem
  but the original function will be attached as _callable to the
  function pointer such that backends can recognize the original
  function as from the table.

* the backends will have implementations for these helper functions
  (to allow writing such implementations we will need a way to assign
  fixed names for some of the defined lltypes introduced by the rtyper)

* XXX: integrate the following refinement:: 

      interplevel: os.open()
      annotation knows it returns an int. 
      rtyper knows to subst by a dummy ll_os_open
      def ll_os_open(...): 
          fd = oslevel_open(...) 
          if fd == -1: 
            raise ... 
