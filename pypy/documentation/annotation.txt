The annotation pass
===================

(INCOMPLETE DRAFT)

We describe below how a control flow graph can be "annotated" to 
discover the types of the objects.  This annotation pass is a form of 
type inference.  It is done after control flow graphs are built by the 
FlowObjSpace, but before these graphs are translated into low-level code 
(e.g. C/Lisp/Pyrex).


Model
-----

The major goal of the annotator is to "annotate" each variable that 
appears in a flow graph.  An "annotation" describes all the possible 
Python objects that this variable could contain at run-time, based on a 
whole-program analysis of all the flow graphs --- one per function.

An "annotation" is an instance of ``SomeObject``.  There are subclasses 
that are meant to represent specific families of objects.  Note that 
these classes are all meant to be instantiated; the classes ``SomeXxx`` 
themselves are not the annotations.

Here is an overview (see ``pypy.annotation.model``):

* ``SomeObject`` is the base class.  An instance ``SomeObject()`` 
  represents any Python object.  It is used for the case where we don't 
  have enough information to be more precise.  In practice, the presence 
  of ``SomeObject()`` means that we have to make the annotated source code 
  simpler or the annotator smarter.

* ``SomeInteger()`` represents any integer.  
  ``SomeInteger(nonneg=True)`` represent a non-negative integer (``>=0``).

* ``SomeString()`` represents any string; ``SomeChar()`` a string of 
  length 1.

* ``SomeTuple([s1,s2,..,sn])`` represents a tuple of length ``n``.  The 
  elements in this tuple are themselves constrained by the given list of 
  annotations.  For example, ``SomeTuple([SomeInteger(), SomeString()])`` 
  represents a tuple with two items: an integer and a string.

There are more complex subclasses of ``SomeObject`` that we describe in 
more details below.

All the ``SomeXxx`` instances can optionally have a ``const`` attribute, 
which means that we know exactly which Python object the Variable will 
contain.

All the ``SomeXxx`` instances are supposed to be immutable.  The 
annotator manages a dictionary mapping Variables (which appear in flow 
graphs) to ``SomeXxx`` instances; if it needs to revise its belief about 
what a Variable can contain, it does so by updating this dictionary, not 
the ``SomeXxx`` instance.


Annotator
---------

The annotator itself (``pypy.translator.annrpython``) works by 
propagating the annotations forward in the flow graphs, starting at some 
entry point function, possibly with explicitely provided annotations 
about the entry point's input arguments.  It considers each operation in 
the flow graph in turn.  Each operation takes a few input arguments 
(Variables and Constants) and produce a single result (a Variable).  
Depending on the input argument's annotations, an annotation about the 
operation result is produced.  The exact rules to do this are provided 
by the whole ``pypy.annotation`` subdirectory, which defines all the 
cases in detail according to the R-Python semantics.  For example, if 
the operation is 'v3=add(v1,v2)' and the Variables v1 and v2 are 
annotated with ``SomeInteger()``, then v3 also receives the annotation 
``SomeInteger()``.  So for example the function::

    def f(n):
        return n+1

corresponds to the flow graph::

    start ----------.
                    |
                    V 
           +-------------------+
           |  v2 = add(v1, 1)  |
           +-------------------+
                    |
                    `---> return block

If the annotator is told that v1 is ``SomeInteger()``, then it will 
deduce that v2 (and hence the function's return value) is 
``SomeInteger()``.

This step-by-step annotation phase proceeds through all the operations 
in a block, and then along the links between the blocks of the flow 
graph.  If there are loops in the flow graph, then the links will close 
back to already-seen blocks, as in::

    def g(n):
        i = 0
        while n:
            i = i + n
            n = n - 1

whose flow graph is::

    start -----.           ,-----------------.
               | n1 0      | m3 j3           |
               V           v                 |
           +-------------------+             |
           |   input: n2 i2    |             |
           |  v2 = is_true(n2) |             |
           +-------------------+             |
               |             |               |
               |ifFalse      |ifTrue         |
    return <---'             | n2 i2         |
                             V               |
                    +--------------------+   |
                    |   input: n3 i3     |   |
                    |  j3 = add(i3, n3)  |   |
                    |  m3 = sub(n3, 1)   |---'
                    +--------------------+

Be sure to follow the variable renaming that occurs systematically 
across each link in a flow graph.  In the above example the Variables 
have been given names similar to the name of the original variables in 
the source code (the FlowObjSpace tries to do this too) but keep in mind 
that all Variables are different: n1, n2, i2, v2, n3, i3, j3, m3.

Assume that we call the annotator with an input annotation of 
``SomeInteger()`` for n1.  Following the links from the start, the 
annotator will first believe that the Variable i2, whose value comes 
from the constant 0 of the first link, must always be zero.  It will 
thus use the annotation ``SomeInteger(const=0)`` for i2.  Then it will 
propagate the annotations through both blocks, and find that v2 is 
``SomeBool()`` and all other variables are ``SomeInteger()``.  In 
particular, the annotation of j3 is different from the annotation of the 
Variable i2 into which it is copied (via the back-link).  More 
precisely, j3 is ``SomeInteger()`` but i2 is the more specific 
``SomeInteger(const=0)``.  This means that the assumption that i2 must 
always be zero is found to be wrong.  At this point, the annotation of 
i2 is *generalized* to include both the existing and the new annotation.  
(This is the purpose of ``pypy.annotation.model.unionof()``).  Then 
these more general annotations must again be propagated forward.

This process of successive generalizations continues until the 
annotations stabilize.  In the above example, it is sufficient to 
re-analyse the first block once, but in general it can take several 
iterations to reach a fixpoint.  Annotations may also be propagated from 
one flow graph to another and back repeatedly, across ``call`` 
operations.  The overall model should ensure that this process 
eventually terminates under reasonable conditions.  Note that as long as 
the process is not finished, the annotations given to the Variables are 
wrong, in the sense that they are too specific; at run-time, the 
Variables will possibly contain Python objects outside the set defined 
by the annotation, and the annotator doesn't know it yet.


XXX write more

