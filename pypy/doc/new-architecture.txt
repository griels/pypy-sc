==================================================
PyPy - Goals and Architecture Overview 
==================================================

.. contents::
.. sectnum::

This document gives an overview of the goals and architecture of PyPy.
See `getting started`_ for a practical introduction and starting points. 

Mission statement 
====================

We aim to provide:

 * a common translation and support framework for producing
   implementations of dynamic languages, emphasising a clean
   separation between language specification and implementation
   aspects.

 * a compliant, flexible and fast implementation of the Python_ Language 
   using the above framework to enable new advanced features without having
   to encode low level details into it.

By separating concerns in this way, we intend for our implementation
of Python - and other dynamic languages - to become robust against almost 
all implementation decisions, including target platform, memory and 
threading models, optimizations applied, up to to the point of being able to
automatically *generate* Just-in-Time compilers for dynamic languages.

Conversely, our implementation techniques, including the JIT compiler 
generator, should become robust against changes in the languages 
implemented. 


High Level Goals
=============================

PyPy - The Translation Framework 
-----------------------------------------------

Traditionally, language interpreters are written in a target platform language
like C/Posix, Java or C#.  Each such implementation fundamentally provides 
a mapping from application source code to the target environment.  One of 
the goals of the "all-encompassing" environments, like the .NET framework
and to some extent the Java virtual machine, is to provide standardized
and higher level functionalities in order to support language implementors
for writing language implementations. 

PyPy is experimenting with a more ambitious approach.  We are using a
subset of the high-level language Python, called RPython_, in which we
write languages as simple interpreters with few references to and
dependencies on lower level details.  Our translation framework then
produces a concrete virtual machine for the platform of our choice by
inserting appropriate lower level aspects.  The result can be customized
by selecting other feature and platform configurations.

Our goal is to provide a possible solution to the problem of language
implementors: having to write ``l * o * p`` interpreters for ``l``
dynamic languages and ``p`` platforms with ``o`` crucial design
decisions.  PyPy aims at having any one of these parameters changeable
independently from each other:

* ``l``: the language that we analyze can be evolved or entirely replaced;

* ``o``: we can tweak and optimize the translation process to produce 
  platform specific code based on different models and trade-offs;

* ``p``: we can write new translator back-ends to target different
  physical and virtual platforms.

By contrast, a standardized target environment - say .NET -
enforces ``p=1`` as far as it's concerned.  This helps making ``o`` a
bit smaller by providing a higher-level base to build upon.  Still,
we believe that enforcing the use of one common environment 
is not necessary.  PyPy's goal is to give weight to this claim - at least 
as far as language implementation is concerned - showing an approach
to the ``l * o * p`` problem that does not rely on standardization.

The most ambitious part of this goal is to *generate Just-In-Time
Compilers* in a language-independent way, instead of only translating
the source interpreter into an interpreter for the target platform.
This is an area of language implementation that is commonly considered
very challenging because of the involved complexity.


PyPy - the Python Interpreter 
--------------------------------------------

Our main motivation for developing the translation framework is to
provide a full featured, customizable and fast Python implementation,
working on and interacting with a large variety of platforms and
allowing the quick introduction of new advanced language features.

This Python implementation is written in RPython as a relatively simple
interpreter, in some respects easier to understand than CPython, the C
reference implementation of Python.  We are using its high level and
flexibility to quickly experiment with features or implementation
techniques in ways that would, in a traditional approach, require
pervasive changes to the source code.  The archetypical example is
reference counting in CPython: changing it to use another garbage
collector would be a major undertaking, whereas in PyPy it is an issue
orthogonal to the interpreter source code.


PyPy Architecture 
===========================

As you would expect from a project implemented using ideas from the world
of `Extreme Programming`_, the architecture of PyPy has evolved over time
and continues to evolve.  Nevertheless, the high level architecture is 
stable. There are two rather independent basic subsystems: the `Python 
Interpreter`_ and `the Translation Framework`_.  We first talk about the 
Python Interpreter because of its re-use by the Translation framework.

.. _`standard interpreter`: 
.. _`python interpreter`: 

The Python Interpreter
-------------------------------------

PyPy's *Python Interpreter* implements the Python language
with the following key components: 

- a bytecode compiler responsible for producing Python code objects 

- a `bytecode evaluator`_ responsible for interpreting 
  Python code objects. 

- a `standard object space`_ responsible for creating, accessing and
  modifying Python application level objects.  

The *bytecode evaluator* is the part that interprets the compact
bytecode format produced from user Python sources by a preprocessing
phase, the *bytecode compiler*.  The bytecode compiler itself is
implemented as a chain of flexible passes (tokenizer, lexer, parser,
abstract syntax tree builder, bytecode generator).  The bytecode
evaluator does its work by delegating all actual manipulations of
user objects to the *object space*.  The latter can be thought of as the
library of built-in types.  It defines the implementation of the user
objects, like integers and lists, as well as the operations between
them, like addition or truth-value-testing.  

This division between bytecode evaluator and object space is very
important, as it gives a lot of flexibility.  One can plug in 
different `object spaces`_ to get different or enriched behaviours 
of the Python objects.  Additionally, a special more abstract object space 
allows to reuse the bytecode evaluator for our translation process. 

.. _`bytecode evaluator`: interpreter.html
.. _`standard object space`: objspace.html#the-standard-object-space
.. _`object spaces`: objspace.html
.. _`flow object space`: objspace.html#the-flow-object-space

.. _`the translation framework`:

The Translation Process
-----------------------

The job of translation tool chain is to translate RPython_ programs into an
efficient version of that program for one of various target platforms,
generally one that is considerably lower-level than Python.

.. XXX "vital detail"?

A vital detail of PyPy's approach is that the level of abstraction is
reduced in several steps from the high level of RPython down to that
of the target platform, whatever that may be.  Currently we support
two broad flavours of target platforms, one that assumes a C-like
memory model with structures and pointers and another that assumes an
object-oriented model with classes, instances and methods.

The translation tool chain never sees Python source code or syntax
trees, but rather starts with the *code objects* that define the
behaviour of the function objects one gives it as input.

The steps the translation process can be summarized as follows:

 * A code object is converted to a `control flow graph` by the `Flow
   Object Space`_.

 * The control flow graphs are processed by the Annotator_, which
   performs whole-program type inference to annotate each variable of
   the control flow graph with the types it may take at run-time.

 * The information provided by the annotator is used by the RTyper_ to
   convert the high level operations of the control flow graphs into
   operations closer to abstraction level of the target platform.

 * Optionally, `various transformations`_ can then be applied which, for
   example, perform optimizations such as inlining or add capabilities
   such as stackless_-style concurrency.

 * Then, the graph is converted to source code for the target platform
   and compiled into an executable.

This process is described in much more detail in the `document about
the translation process`_.

.. _`control flow graph`: translation.html#the-flow-model
.. _`Flow Object Space`: objspace.html#the-flow-object-space
.. _Annotator: translation.html#the-annotation-pass
.. _RTyper: rtyper.html#overview
.. _`various transformations`: translation.html#the-optional-transformations
.. _`document about the translation process`: translation.html

Further reading
===============

All of PyPy's documentation can be reached from the `documentation
index`_.  Of particular interest after reading this document might be:

 * `getting-started`_: a hands-on guide to getting involved with the
   PyPy source code.

 * `PyPy's approach to virtual machine construction`_: a paper
   presented to the Dynamic Languages Symposium attached to OOPSLA
   2006.

 * `The translation document`_: a detailed description of our
   translation process.

 * `Compiling dynamic language implementations`_: a paper describing
   the annotation pass with a greater emphasis on theoretical aspects
   than in the other documentation.

 * All our `Technical reports`_. XXX reference specific reports
   and provide a summary here? 

.. _`documentation index`: index.html
.. _`getting-started`: getting-started.html
.. _`PyPy's approach to virtual machine construction`: http://codespeak.net/svn/pypy/extradoc/talk/dls2006/pypy-vm-construction.pdf
.. _`the translation document`: translation.html
.. _`Compiling dynamic language implementations`: dynamic-language-translation.html
.. _`Technical reports`: index-report.html

.. _`getting started`: getting-started.html
.. _`Extreme Programming`: http://www.extremeprogramming.com/

.. XXX link to this again:
.. _`very compliant`: http://www2.openend.se/~pedronis/pypy-c-test/allworkingmodules/summary.html

.. _`RPython`: coding-guide.html#rpython

.. _Python: http://docs.python.org/ref
.. _Psyco: http://psyco.sourceforge.net
.. _Stackless: http://stackless.com 

.. include:: _ref.txt

