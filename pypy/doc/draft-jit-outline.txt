=======================
JIT Generation in PyPy
=======================

Introduction
=============

.. Interpreters to compilers, psyco parallel...

One the of the central goals of the PyPy project is to automatically
produce a Just in Time Compiler from the interpreter, with as little
as possible intervention on the interpreter codebase itself.  The Just
in Time Compiler should be another aspect as much as possible
transparently introduced by and during the translation process.

Partial evaluation techniques should, at least theoretically, allow
such a derivation of a compiler from an interpreter. XXX scalability
issues references ...

The forest of flow graphs that the translation process generates and
transforms constitutes a reasonable base for the necessary analyses.
That's a further reason why having an high-level runnable and
analysable description of the language was always a central tenet of
the project.

Transforming an interpreter into a compiler involves constructing a so
called generating extension, which takes input programs to the
interpreter, and produces what would be the output of partial
evaluating the interpreter with the input data left variable and the
input program being fixed. The generating extension is essentially
capable of compiling the input programs.

Generating extensions can be produced by self-applying partial evaluators,
but this approach may lead to not optimal results or be not scalable

For PyPy, our approach aims at producing the generating extension more
directly from the analysed interpreter in the form of a forest of flow
graphs. We call such process *timeshifting*.

To be able to achieve this, gathering binding time information is
crucial, this means for an input program distinguishing values in the
data-flow that are compile-time bound and immutable at run-time,
versus respectively runtime values.

Currently we base the binding time computation on propagating the
information based on a few hint inserted in the interpreter. Propagation
is implemented by reusing our annotation/type inference framework XXX
ref.

The code produced by a generating extension for an input program may
not be good, especially for a dynamic language, because essentially
the input program doesn't contain enough information to generate good
code. What is really desired is not a generating extension doing
static compilation, but one capable of dynamic compilation, exploiting
runtime information in its result, or using a different terminology
(XXX explain differently the following)
capable of producing code that is specialised with respect to some of
the run-time information, for example language-level types.

Inspired by Psyco, which in some sense is such a specialising
generating extension for Python, but hand-written, we added support
for so-called *promotion* to our framework for producing generating
extensions.

Simply put, promotion on a value stops compilation when encountered,
when the same point is reached at run-time compilation is restarted
and the current run-time value is used and propagated as a compile-time
value. Concretely the promotion expands into a switch to choose based
on the run-time value one of the possible specialised code paths, plus
a default case to compile further specialised paths. This can be also
thought as a generalisation of polymorphic inline caches XXX ref.


Hint-Annotation and Compile Time Values
=========================================

Hint annotator and hint(concrete=True)...

calls...

green propagation at fixpoint...

deepfreeze...

blue containers...


Timeshifting: transforming interpreter into compilers
======================================================

intro and basics


Transform vs hrtyping
-----------------------

...

Split and Merges
--------------------

...

Calls and inlining
---------------------

...

Virtual Containers
--------------------

...vstructs, vlist, vdict...

Exceptions
------------

...

Promotion and global merges
-----------------------------

...

Partial data
-------------

...

Portals
----------------------

...

Scaling to PyPy
----------------------

...


Backends
====================

...

The Backend interface
-----------------------

...

