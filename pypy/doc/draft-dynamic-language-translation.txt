============================================================
       Compiling dynamic language implementations
============================================================

.. contents::
.. sectnum::


The analysis of dynamic languages
===============================================

Dynamic languages are definitely not new on the computing scene.  
However, new conditions like increased computing power and designs driven
by larger communities have enabled the emergence of new aspects in the
recent members of the family, or at least made them more practical than
they previously were.  The following aspects in particular are typical not
only of Python but of most modern dynamic languages:

* The driving force is not minimalistic elegance.  It is a balance between
  elegance and practicality, and rather un-minimalistic -- the feature
  sets built into languages tend to be relatively large and growing
  (to some extent, depending on the language).

* High abstractions and theoretically powerful low-level primitives are
  generally ruled out in favor of a larger number of features that try to
  cover the most common use cases.  In this respect, one could even regard
  these languages as mere libraries on top of some simpler (unspecified)
  language.

* Implementation-wise, language design is no longer driven by a desire to
  enable high performance; any feature straightforward enough to achieve
  with an interpreter is candidate.  As a result, compilation and most
  kinds of static inference are made impossible due to this dynamism
  (unless they are simply tedious due to the size of the language).


No Declarations
~~~~~~~~~~~~~~~

The notion of "declaration", central in compiled languages, is entirely
missing in Python.  There is no aspect of a program that must be declared;
the complete program is built and run by executing statements.  Some of
these statements have a declarative look and feel; for example, some
appear to be function or class declarations.  Actually, they are merely
statements that, when executed, build a function or class object.  A
reference to the new object is then stored in a namespace from where it
can be accessed.  Units of programs -- modules, whose source is one
file each -- are similarily mere objects in memory, built on demand by some
other module executing an ``import`` statement.  Any such statement --
class construction or module import -- can be executed at any time during
the execution of a program.

This point of view should help explain why an analysis of a program is
theoretically impossible: there is no declared structure.  The program
could for example build a class in completely different ways based on the
results of NP-complete computations or external factors.  This is not just
a theoretical possibility but a regularly used feature: for example, the
pure Python module ``os.py`` provides some OS-independent interface to
OS-specific system calls, by importing internal OS-specific modules and
completing it with substitute functions, as needed by the OS on which
``os.py`` turns out to be executed.  Many large Python projects use custom
import mechanisms to control exactly how and from where each module is
loaded, by tampering with import hooks or just emulating parts of the
``import`` statement manually.

In addition, there are of course classical (and only partially true)
arguments against compiling dynamic languages (there is an ``eval``
function that can execute arbitrary code, and introspection can change
anything at run-time), but we consider the argument outlined above as more
fundamental to the nature of dynamic languages.


The analysis of live programs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

How can we perform some static analysis on a program written in a dynamic
language while keeping to the spirit of `No Declarations`_, i.e. without
imposing that the program be written in a static way in which these
declarative-looking statements would actually *be* declarations?

The approach of PyPy is, first of all, to perform analysis on live
programs in memory instead of dead source files.  This means that the
program to analyse is first fully imported and initialized, and once it
has reached a state that is deemed advanced enough, we limit the amount of
dynamism that is allowed *after this point* and we analyse the program's
objects in memory.  In some sense, we use the full Python as a
preprocessor for a subset of the language, called RPython.  Informally,
RPython is Python without the operations and effects that are not supported
by our analysis toolchain (e.g. class creation, and most non-local effects).

Of course, putting more efforts into the toolchain would allow us to
support a larger subset of Python.  We do not claim that our toolchain --
which we describe in the sequel of this paper -- is particularly advanced.
To make our point, let us assume as given an analysis tool, which supports
a given subset of a language.  Then:

* Analysing dead source files is equivalent to giving up all dynamism
  (as far as unsupported by this tool).  This is natural in the presence of
  static declarations.

* Analysing a frozen memory image of a program that we loaded and
  initialized is equivalent to giving up all dynamic after a certain point
  in time.  This is natural in image-oriented environments like Smalltalk,
  where the program resides in memory and not in files in the first place.

Our approach goes further and analyses *live* programs in memory:
the program is allowed to contain fully dynamic sections, as long as these
sections are entered a *bounded* number of times.
For example, the source code of the PyPy
interpreter, which is itself written in this bounded-dynamism style, makes
extensive use of the fact that it is possible to build new classes at any
point in time -- not just during an initialization phase -- as long as the
number of new classes is bounded.  E.g. `interpreter/gateway.py`_ builds a
custom class
for each function that some variable can point to.  There is a finite
number of functions in total, so this can obviously only create
a finite number of extra classes.  But the precise set of functions that
need a corresponding class is difficult to manually compute in advance;
instead, the code that builds and cache a new class is invoked by the
analysis tool itself each time it discovers that a new function object can
reach the corresponding point.

This approach is derived from dynamic analysis techniques that can support
unrestricted dynamic languages by falling back to a regular interpreter for
unsupported features (e.g. Psyco, described in
http://psyco.sourceforge.net/psyco-pepm-a.ps.gz).
The above argumentation should have shown why we think that being similarily
able to fall back to regular interpretation for parts that cannot be
understood is a central feature of the analysis of dynamic languages.


Concrete and abstract interpretation
======================================================

Object Spaces
~~~~~~~~~~~~~

The semantics of Python can be roughly divided in two groups: the syntax of
the language, which focuses on control flow aspects, and the object semantics,
which define how various types of objects react to various operations and
methods.  As it is common in all languages of the family, both the
syntactic elements and the object semantics are complex and at times
complicated (as opposed to more classical languages that tend to subsume
one aspect to the other: for example, Lisp's execution semantics are almost
trivial).

This observation led us to the concept of *Object Space*.  An interpreter can
be divided in two non-trivial parts: one for handling compilation to and
interpretation of pseudo-code (control flow aspects) and one implementing
the object library's semantics.  The former, called *bytecode interpreter*,
considers objects as black boxes; any operation on objects requested by the
bytecode is handled over to the object library, called *object space*.
The point of this architecture is, precisely, that neither of these two
components is trivial; separating them explicitely, with a well-defined
interface inbetween, allows each part to be reused independently.  This is
a major flexibility feature of PyPy: we can for example insert proxy object
spaces in front of the real one, like the `Thunk Object Space`_ adding lazy
evaluation of objects.

Note that the term "object space" has already been reused for other
dynamic language implementations, e.g. XXX for Perl 6.


Abstract interpretation
~~~~~~~~~~~~~~~~~~~~~~~

In the sequel of this paper, we will consider another application
of the object space separation.  The analysis we perform in PyPy
is whole-program type inference.  The analysis of the non-dynamic
parts themselves is based on their `abstract interpretation`_.
PyPy has an alternate object space called the `Flow Object Space`_,
whose objects are empty placeholders.  The over-simplified view
is that to analyse a function, we bind its input arguments to such
placeholders, and execute the function -- i.e. let the interpreter follow
its bytecode and invoke the object space for each operations, one by one.  
The Flow object space records each operation when it is issued, and
returns a new placeholder as a result.  At the end, the list of recorded
operations, along with the involved placeholders, gives an assembler-like
view of what the function performs.

The global picture is then to run the program while switching between the
flow object space for static enough functions, and a standard, concrete
object space for functions or initializations requiring the full dynamism.

If the placeholders are endowed with a bit more information, e.g. if they
carry a type information that is propagated to resulting placeholders by
individual operations, then our abstract interpretation simultaneously
performs type inference.  This is, in essence, executing the program while
abstracting out some concrete values and replacing them with the set of
all values that could actually be there.  If the sets are broad enough,
then after some time we will have seen all potential value sets along each
possible code paths, and our program analysis is complete.

An object space is thus an *interpretation domain*; the Flow Object Space
is an *abstract interpretation domain*.  We are thus interpreting the
program while switching dynamically between several abstraction levels.
This is possible because our design allows the *same* interpreter to work
with a concrete or an abstract object space.

Following parts of the program at the abstract level allows us to deduce
general information about the program, and for parts that cannot be analysed
we switch to the concrete level.  The restrictions placed on the program
to statically analyse are that to be crafted in such a way that this process
eventually terminates; from this point of view, more abstract is better (it
covers whole sets of objects in a single pass).  Thus the compromize that
the author of the program to analyse faces are less strong but more subtle
than not using a specific set of dynamic features at all, but using them
sparsingly enough.


The PyPy analysis toolchain
~~~~~~~~~~~~~~~~~~~~~~~~~~~

We developed above a theoretical point of view that differs
significantly from what we have implemented, for many reasons.  The
devil is in the details.

The rest of this document is organized as follows:

* the `Flow Object Space`_ chapter describes how we turn Python bytecode
  objects into control flow graphs by performing its abstract
  interpretation;

* the `Annotator`_ chapter describes our type inference model and process;

* the `Code Generation`_ chapter gives an overview about how we turn
  annotated flow graphs into low-level code.


Flow Object Space
===========================================

In our bytecode-interpreter design evaluation responsibilities are
split between the Object Space, frames and the so-called execution
context. The latter two object kinds are properly part of the
interpretation engine, while the object space implements all
operations on values which are treated as black boxes by the engine.

The Object Space plays the role of a factory for execution contexts,
whose base implementation is supplied by the engine, and exposes hooks
triggered when frames are entered, left and before each bytecode,
allowing to gather a trace of the execution.

Frames have run/resume methods which embed the interpretation loop,
These methods take an execution context invoking the appropriate hooks
at the corresponding situations.

The Flow Object Space in our current design is responsible of
constructing a flow graph for a single function using abstract
interpretation.  The domain on which the Flow Space operates comprises
variables and constant objects. They are stored as such in the frame
objects without problems because by design the interpreter engine treat
them as black boxes.


Construction of flow graphs
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Concretely, the Flow Space plugs itself in the interpreter as an object
space and supplies a derived execution context implementation.  It also
wraps a fix-point loop around invocations of the frame resume method.
In our current design, this fix-point searching is implemented by
interrupting the normal interpreter loop in the frame after every
bytecode, and comparing the state with previously-seen states.  These
states describe the execution state for the frame at a given point.
They are synthesised out of the frame by the Flow Space; they contain
position-dependent data (current bytecode index, current exception
handlers stack) as well as a flattened list of all variables and
constants currently handled by the frame.

The Flow Space constructs the flow graph, operation after operation, as
a side effect of seeing these operations performed by the interpretation
of the bytecode.  During construction, blocks in the graph all have an
associated frame state. The Flow Space start from an empty block with an
a frame state corresponding to a frame freshly initialized, with a new
variables for each input argument of the analysed function.  It proceeds
by recording the operations in this block, as follows: when an operation
is delegated to the Flow Space by the frame interpretation loop, either
a constant result is produced -- in the case of constant arguments to an
operation with no side-effects -- or a fresh new variable is produced.
In the latter case, the operation (together with its input variables and
constant arguments, and its output variable) is recorded in the current
block and the new variable is returned as result to the frame
interpretation loop.

When a new bytecode is about to be executed, as signalled by the
bytecode hook, the Flow Space considers the frame state corresponding to
the current frame contents.  This state is compared with the existing
states attached to the blocks produced so far.  If the state was not
seen before, the Flow Space creates a new block in the graph.  If the
same state was already seen before, then a backlink to the previous
block is inserted, and the abstract interpretation stops here.  If only
a "similar enough" state was seen so far, then the current and the
previous states are merged to produce a more general state.

In more details, "similar enough" is defined as having the same
position-dependant part, the so-called "non-mergeable frame state",
which mostly means that only frame states corresponding to the same
bytecode position can ever be merged.  This process thus produces blocks
that are generally in one-to-one correspondance with the bytecode
positions seen so far.  The exception to this rule is in the rare cases
where frames from the same bytecode position have a different
non-mergeable state, which typically occurs during the "finally" part of
a "try: finally:" construct, where the details of the exception handler
stack differs according to whether the "finally" part was entered
normally or as a result of an exception.

If two states have the same non-mergeable part, they can be merged using
a "union" operation: only two equal constants unify to a constant of the
same value; all other combinations (variable-variable or
variable-constant) unify to a fresh new variable.

In summary, if some previously associated frame state for the next
byecode can be unified with the current state, then a backlink to the
corresponding existing block is inserted; additionally, if the unified
state is strictly more general than the existing one, then the existing
block is cleared, and we proceed with the generalized state, reusing the
block.  (Reusing the block avoids the proliferation of over-specific
blocks.  Ror example, without this, all loops would typically have their
first pass unrolled with the first value of the counter as a constant;
instead, the second pass through the loop that the Flow Space does with
the counter generalized as a variable will reuse the same entry point
block, and any further blocks from the first pass are simply
garbage-collected.)


Branching
~~~~~~~~~

Branching on conditions by the engine usually involves querying the
truth value of a object through the ``is_true`` space operation.  When
this object is a variable, the result is not statically known; this
needs special treatment to be able to capture both possible flow paths.
In theory, this would require continuation support at the language level
so that we can pretend that ``is_true`` returns twice into the engine,
once for each possible answer, so that the Flow Space can record both
outcomes.  Without proper continuations in Python, we have implemented a
more explicit scheme that we describe below.  (The approach is related
to the one used in Psyco_, where continuations would be entierely
inpractical, as described in the `ACM SIGPLAN 2004 paper`_.)

At any point in time, multiple pending blocks can be scheduled for
abstract interpretation by the Flow Space, which proceeds by picking one
of them and reconstructing a frame from the frame state associated with
the block.  This frame reconstruction is actually delegated to the
block, which also returns a so-called "recorder" through which the Flow
Space will append new space operations to the block.  The recorder is
also responsible for handling the ``is_true`` operation.

A normal recorder simply appends the space operations to the block from
which it comes from.  However, when it sees an ``is_true`` operation, it
creates and schedules two special blocks (one for the outcome ``True``
and one for the outcome ``False``) which don't have an associated frame
state.  The previous block is linked to the two new blocks with
conditional exits.  At this point, abstract interpretation stops (i.e.
an exception is raised to interrupt the engine).

The special blocks have no frame state, and cannot be used to setup a
frame: indeed, unlike normal blocks, which correspond to the state of
the engine between the execution of two bytecode, special blocks
correspond to a call to ``is_true`` issued the engine.  The details of
the engine state (internal call stack and local variables) are not
available at this point.

However, it is still possible to put the engine back into the state
where it was calling ``is_true``.  This is what occurs later on, when
one of the special block is scheduled for further execution: the block
considers its previous block, and possibly its previous block's previous
block, and so on up to the first normal block.  As we can see, these
blocks form a binary tree of special blocks with a normal block at the
root.  A special block thus corresponds to a branch in the tree, whose
path is described by a list of outcomes -- a list of boolean values.  We
can thus restore the state of any block by starting from the root and
asking the engine to replay the execution from there; intermediate
``is_true`` calls issued by the engine are answered according to the
list of outcomes until we reach the desired state.

This is implemented by having a special blocks (called ``EggBlocks``
internally, whereas normal blocks are ``SpamBlocks``) return a chain of
recorders: one so-called "replaying" recorder for each of the parent
blocks in the tree, followed by a normal recorder for the block itself.
When the engine replays the execution from the root of the tree, the
intermediate recorders check (for consistency) that the same operations
as the ones already recorded are issued again, ending in a call to
``is_true``; at this point, the replaying recorder gives the answer
corresponding to the branch to follow, and switch to the next recorder
in the chain.

This mechanism ensures that all flow paths are considered, including
different flow paths inside the engine and not only flow paths that are
explicit in the bytecode.  For example, an ``UNPACK_SEQUENCE`` bytecode
in the engine iterates over a sequence object and checks that it
produces exactly the expected number of values; so the single bytecode
``UNPACK_SEQUENCE n`` generates a tree with ``n+1`` branches
corresponding to the ``n+1`` times the engine asks the iterator if it
has more elements to produce.  A simpler example is a conditional jump,
which will generate a pair of special blocks for the ``is_true``, each
of which consisting only in a jump to the normal block corresponding to
the next bytecode -- either the one following the conditional jump, or
the target of the jump, depending on whether the replayer answered
``False`` or ``True`` to the ``is_true``.

Note a limitation of this mechanism: the engine cannot use an unbounded
loop to implement a single bytecode.  All *loops* must still be
explicitly present in the bytecodes.  The reason is that the Flow Space
can only insert backlinks between bytecodes.


Dynamic merging
~~~~~~~~~~~~~~~

For simplicity, we have so far omitted a point in the description of how
frame states are associated to blocks.  In our implementation, there is
not necessarily a block corresponding to each bytecode position (or more
precisely each non-mergeable state): we avoid creating blocks at all if
they would stay empty.  This is done by tentatively running the engine
on a given frame state and seeing if it creates at least one operation;
if it does not, then we simply continue with the new frame state without
having created a block for the previous frame state.  The previous frame
state is discarded without having even tried to compare it with
already-seen state to see if it merges.

The effect of this is that merging only occurs at the beginning of a
bytecode that actually produces an operation.  This allows some amount
of constant-folding: for example, the two functions below produce the
same flow graph::

    def f(n):             def g(n):
        if n < 0:             if n < 0:
            n = 0                 return 1
        return n+1            else:
                                  return n+1

because the two branches of the condition are not merged where the
``if`` statement syntactically ends: the ``True`` branch propagates a
constant zero in the local variable ``n``, and the following addition is
constant-folded and does not generate a residual operation.

Note that this feature means that the Flow Space is not guaranteed to
terminate.  The analysed function can contain arbitrary computations on
constant values (with loops) that will be entierely constant-folded by
the Flow Space.  A function with an obvious infinite loop will send the
Flow Space following the loop ad infinitum.  This means that it is
difficult to give precise conditions for when the Flow Space terminates
and which complexity it has.  Informally, "reasonable" functions should
not create problems: it is uncommon for a function to perform
non-trivial constant computations at run-time; and the complexity of the
Flow Space can more or less be bound by the run-time complexity of the
constant parts of the function itself, if we ignore pathological cases
where a part of a function contains infinite loops but cannot be entered
at run-time for some reasons unknown to the Flow Space.


Geninterp
~~~~~~~~~

Introducing `Dynamic merging`_ can be seen as a practical move: it does
not, in practice, prevent even large functions to be analysed reasonably
quickly, and it is useful to simplify the flow graphs of some functions.
This is specially true for functions that are themselves automatically
generated.

In the PyPy interpreter, for convenience, some of the core functionality
has been written as application-level Python code, which means that the
interpreter will consider some core operations as calls to further
application-level code.  This has, of course, a performance hit due to
the interpretation overhead.  To minimize this overhead, we
automatically turn some of this application-level code into
interpreter-level code, as follows.  Consider the following trivial
example function at application-level::

    def f_app(n):
        return n+1

Interpreting it, the engine just issues an ``add`` operation on the
object space, which means that it is mostly equivalent to the following
interpreter-level function::

    def f_interp(space, wrapped_n):
        return space.add(wrapped_n, wrapped_1)

The translation from ``f_app`` to ``f_interp`` can be done automatically
by using the Flow Space as well: we produce the flow graph of ``f_app``
using the techniques described above, and then we turn the resulting
flow graph into ``f_interp`` by generating for each operation a call to
the corresponding method of ``space``.

This process looses the original syntactic structure of ``f_app``,
though; the flow graph is merely a collection of blocks that jump to
each other.  It is not always easy to reconstruct the structure from the
graph (or even possible at all, in some cases where the flow graph does
not exactly follow the bytecode).  So, as is common for code generators,
we use a workaround to the absence of explicit gotos::

    def f_interp(...):
        next_block = 0
        while True:

            if next_block == 0:
                ...
                next_block = 1

            if next_block == 1:
                ...

This produces Python code that is particularly sub-efficient when it is
interpreted; however, if it is further re-analysed by the Flow Space,
dynamic merging will ensure that ``next_block`` will always be
constant-folded away, instead of having the various possible values of
``next_block`` be merged at the beginning of the loop.

For more information see `The Interplevel Back-End`_ in the reference
documentation.

.. _`The Interplevel Back-End`: translation.html#the-interplevel-back-end



Annotator 
=================================

The annotator is the type inference part of our toolchain.  The
annotator infers *types* in the following sense: given a program
considered as a family of control flow graphs, it assigns to each
variable of each graph a so-called *annotation*, which describes what
are the possible run-time objects that this variable will contain.  Note
that in the literature such an annotation is usually called a type, but
we prefer to avoid this terminology to avoid confusion with the Python
notion of the concrete type of an object.  Annotations are sets of
possible values that is not always exactly the set of all objects of a
specific Python type.

We will first expose a simplified, static model of how the annotator
works, and then hint at some differences between the model and the
reality.


Static model
~~~~~~~~~~~~

The annotator can be considered as taking as input a finite family of
functions calling each other, and working mainly on the control flow
graphs of each of these functions as built by the `Flow Object Space`_.
Additionally, for a particular "entry point" function, each input
argument is given a user-specified annotation.

The goal of the annotator is to find the most precise annotation that
can be given to each variable of all control flow graphs while
respecting constrains imposed by the operations in which these variables
are involved.

More precisely, it is usually possible to deduce information about the
result variable of an operation given information about its arguments.
For example, we can say that the addition of two integers must be an
integer.  Most programming languages have this property.  However,
Python -- like many languages not specifically designed with type
inference in mind -- does not possess a type system that allows much
useful information to be derived about variables based on how they are
*used*; only on how they were *produced*.  For example, a number of very
different built-in types can be involved in an addition; the meaning of
the addition and the type of the result depends on the type of the input
arguments.  Merely knowing that a variable will be used in an addition
does not give much information per se.  For this reason, our annotator
works by flowing annotations forward, operation after operation, i.e. by
performing abstract interpretation of the flow graphs.  In a sense, it
is a more naive approach than the one taken by type systems specifically
designed to enable more advanced inference algorithms.  For example,
`Hindley-Milner`_ type inference works in an inside-out direction, by
starting from individual operations and propagating type constrains
outwards.

Naturally, simply propagating annotations forward requires the use of a
fixpoint algorithm in the presence of loops in the flow graphs or in the
inter-procedural call graph.  Indeed, we flow annotations forward from
the beginning of the entry point function into each block, operation
after operation, and follow all calls recursively.  During this process,
each variable along the way gets an annotation.  In various cases,
e.g. when we close a loop, the previously assigned annotations can be
found to be too restrictive.  In this case, we generalize them to allow
for a larger set of possible run-time values, and schedule the block
where they appear for reflowing.  The more general annotations can
generalize the annotations of the results of the variables in the block,
which in turn can generalize the annotations that flow into the
following blocks, and so on.  This process continues until a fixpoint is
reached.

We can consider that all variables are initially assigned the "bottom"
annotation corresponding to an empty set of possible run-time values.
Annotations can only ever be generalized, and the model is simple enough
to show that there is no infinite chain of generalization, so that this
process necessarily terminates, as we will show in the sequel.


Flow graph model
~~~~~~~~~~~~~~~~

For the purpose of the sequel, an informal description of the data model
used to represent flow graphs will suffice (a `precise description`_ can
be found in the reference documentation).

The flow graphs are in Static Single Information (SSI) form, an
extension of Static Single Assignment (SSA_): each variable is only used
in exactly one basic block.  All variables that are not dead at the end
of a basic block are explicitely carried over to the next block and
renamed.  Instead of the traditional phi functions of SSA we use a minor
variant, parameter-passing style: each block declares a number of *input
variables* playing the role of input arguments to the block; each link
going out of a block carries a matching number of variables and
constants from the previous block into the target block's input
arguments.

We use the following notation for an *operation* recorded in a block of
the flow graph of a function::

    z = opname(x_1, ..., x_n) | z'

where *x_1, ..., x_n* are the arguments of the operation (either
variables defined earlier in the block, or constants), *z* is the
variable into which the result is stored (each operation introduces a
new fresh variable as its result), and *z'* is a fresh extra variable
called the "auxiliary variable" which we will use in particular cases
(which we omit from the notation when it is irrelevant).

.. _`definition of V`:

Let us assume that we are given a user program, which for the purpose of
the model we assume to be fully known in advance.  Let us define the set
*V* of all variables as follows:

* *V* contains all the variables that appear in operations, in any flow
  graph of any function of the program, as described above;

* in addition, for each class ``C`` of the user program and each
  possible attribute name ``attr``, we add to *V* a variable called
  *v_C.attr*.

For a function ``f`` of the user program, we call *arg_f_1, ...,
arg_f_n* the variables bound to the input arguments of ``f`` (which are
actually the input variables of the first block in the flow graph of
``f``) and *return_f* the variable bound to the return value of ``f``
(which is the single input variable of a special empty "return" block
ending the flow graph).

Note that the complete knowledge of the operations and classes that
appear in the user program allow us to bound the size of *V*.  Indeed,
the set of possible attribute names can be defined as all names that
appear in a ``getattr`` or ``setattr`` operation; no other name will
play a role during annotation.

.. _`precise description`: objspace.html#the-flow-model
.. _`SSA`: http://en.wikipedia.org/wiki/Static_single_assignment_form


Annotation model
~~~~~~~~~~~~~~~~

As in the `formal definition`_ of Abstract Interpretation, the model for
our annotation forms a lattice_, although we only use its structure of
`join-semilattice`_.

The set *A* of annotations is defined as the following formal terms:

* Bot, Top -- the minimum and maximum elements (corresponding to
  "impossible value" and "most general value");

* Int, NonNegInt, Bool -- integers, known-non-negative integers, booleans;

* Str, Char -- strings, characters (which are strings of length 1);

* Inst(*class*) -- instance of *class* or a subclass thereof (there is
  one such term per *class*);

* List(*v*) -- list; *v* is a variable summarizing the items of the list
  (there is one such term per variable);

* Pbc(*set*) -- where the *set* is a subset of the (finite) set of all
  `Prebuilt Constants`_, defined below.  This set includes all the
  callables of the user program: functions, classes, and methods.

* None -- stands for the singleton ``None`` object of Python.

More details about the annotations will be introduced in due time.  In
addition, some of the annotations have a corresponding "nullable" twin,
which stands for "either the object described or ``None``".  We use it
to propagate knowledge about which variable, after translation to C,
could ever contain a NULL pointer.  (More precisely, there are a
NullableStr, nullable instances, and nullable Pbcs, and all lists are
implicitely assumed to be nullable).

Each annotation corresponds to a family of run-time Python object; the
ordering of the lattice is essentially the subset order.  Formally, it
is the partial order generated by:

* Bot <= a <= Top -- for any annotation *a*;

* Bool <= NonNegInt <= Int;

* Char <= Str;

* Inst(*subclass*) <= Inst(*class*) -- for any class and subclass;

* Pbc(*subset*) <= Pbc(*set*);

* a <= b -- for any annotation *a* with a nullable twin *b*;

* None <= b -- for any nullable annotation *b*.

It is left as an exercice to show that this partial order makes *A* a
lattice.

Graphically::

                ____________ Top ___________
               /      /       |       \     \
              /      /        |        \     \
             /      /         |         |     \
            /   NullableStr   |         |      |
          Int     /   \       |       (lists)  |
          /     Str    \  (instances)   |      |
    NonNegInt     \     \     |         |   (Pbcs)
          \       Char   \    |\       /      /
          Bool      \     \   | \     /      /
            \        \     `----- None -----/
             \        \       |   /        /
              \        \      |  /        /
               `--------`-- Bottom ------'

Here is the part about instances and nullable instances, assuming a
simple class hierarchy with only two direct subclasses of ``object``::

                             Top
                              |
                              |
                              |
                       NuInst(object)
                          /      / \
                  Inst(object)  /   \
                     /      \  /     \
                    /        \/       \
                   /         /\        \
                  /         /  \        \
                 /         /    \        \
                /  NuInst(cls2)  \     NuInst(cls1)
               /   /      \       \     /  /
           Inst(cls2)      \  Inst(cls1)  / 
                 \          \    /       /
                  \          \  /       /
                   \          \/       /
                    \         /\      /
                     \       /   None
                      \     /  /
                        Bottom

All list terms for all variables are unordered::

             __________________ Top __________________
            /            /     /   \     \            \
           /            /     /     \     \            \
          /            /     /       \     \            \
    List(v_1)       ...        ...        ...         List(v_n)
          \            \     \       /     /            /
           \            \     \     /     /            /
            \            \     \   /     /            /
             '------------'--- None ----'------------'

The Pbcs form a classical finite set-of-subsets lattice.  In practice,
we consider ``None`` as a degenerated prebuilt constant, so the None
annotation is actually Pbc({None}).

We should mention (but ignore for the sequel) that all annotations also
have a variant where they stand for a single known object; this
information is used in constant propagation.  In addition, we have left
out a number of other annotations that are irrelevant for the basic
description of the annotator, and straightforward to handle.  The
complete list is defined and documented in `pypy/annotation/model.py`_
and described in the `annotator reference documentation`_.

.. _`annotator reference documentation`: translation.html#annotator


Rules
~~~~~

In the sequel, we will use the following notations:

- *A* is the lattice defined above;

- *V* is the set of variable;

- *E*, *E'*, *E''*... are equivalence relations on *V*; where
  unambiguous, we write *v~v'* to mean that *v* and *v'* are identified
  by *E*.

- *b*, *b'*, *b''*... are maps from *V* to *A*.

We call *state* a pair *(b,E)*.  We say that a state *(b',E')* is more
general than a state *(b,E)* if for all variables *v* we have ``b'(v) >=
b(v)`` and *E'* includes at least all relations of *E*.  There is:

- a most general state, with *bmax(v) = Top* for all *v* and *Emax*
  identifying all variables with each other;

- a least general state, with *bmin(v) = Bottom* for all *v* and *Emin*
  containing no relation (apart from the mandatory *v~v*).

The goal of the annotator is to find the least general (i.e. most
precise) state that is sound (i.e. correct for the user program).  The
algorithm used is a fixpoint search: we start from the least general
state and consider the conditions repeatedly; if a condition is not met,
we generalize the state incrementally to accomodate for it.  This
process continues until all conditions are satisfied.

The conditions are presented as a set of rules.  A rule is a functional
operation that, when applied, maps a state *(b,E)* to a possibly more
general state *(b',E')* that satisfies the condition represented by the
rule.  *Soundness* is formally defined as a state in which all the
conditions are already satisfied, i.e. none of the rules would produce a
strictly more general state.

Basically, each operation in the flow graphs of the user program
generates one such rule.  The rules are conditional on the annotations
bound to the operation's input argument variables, in a way that mimics
the ad-hoc polymorphic nature of most Python operations.  We will not
give all rules in the sequel, but focus on representative examples.  An
``add`` operation generates the following rules (where *x*, *y* and *z*
are replaced by the variables that really appear in each particular
``add`` operation in the flow graphs of the user program)::

         z=add(x,y), Bool<=b(x)<=Int, Bool<=b(y)<=Int
      ------------------------------------------------------
               b' = b with (z->Int)


         z=add(x,y), Bool<=b(x)<=NonNegInt, Bool<=b(y)<=NonNegInt
      -------------------------------------------------------------
               b' = b with (z->NonNegInt)


         z=add(x,y), Char<=b(x)<=NullableStr, Char<=b(y)<=NullableStr
      ----------------------------------------------------------------
               b' = b with (z->Str)

The rules are read as follows: for the operation ``z=add(x,y)``, we
consider the bindings of the variables *x* and *y* in the current state
*(b,E)*; if the bindings satisfy the given conditions, then the rule is
applicable.  Applying the rule means producing a new state *(b',E')*
derived from the current state -- here by changing the binding of the
result variable *z*.

Note that for conciseness, we omitted the guards in the first rule that
prevent it from being applied if the second rule (which is more precise)
applies as well.  As none of these rules modify *E*, we also omitted the
``E'=E``.

Also note that we do not generally try to prove the correctness and
safety of the user program, preferring to rely on test coverage for
that.  This is apparent in the third rule above, which considers
concatenation of two potentially "nullable" strings, i.e. strings that
the annotator could not prove to be non-None.  Instead of reporting an
error, we take it as a hint that the two strings will not actually be
None at run-time and proceed.

~~~~~~~~~~~~~~~~~~~~~~

.. _merge:

In the sequel, a lot of rules will be based on the following
``merge`` operator.  Given an annotation *a* and a variable *x*,
``merge a => x`` modifies the state as follows::

         merge a => x:
             if a=List(v) and b(x)=List(w):
                 b' = b
                 E' = E union (v ~ w)
             else:
                 b' = b with (x -> a \/ b(x))
                 E' = E

where ``\/`` is the union in the lattice *A*.

The above operator is first of all used to propagate bindings of
variables across links between basic block in the control flow graphs.
For every link mapping a variable *x* in the source block to a variable
*y* in the target block, we generate the following rule (``phi`` is not
a normal operation in our `Flow graph model`_; we abuse the notation)::

         y = phi(x)
      ----------------------------------------
               merge b(x) => y

The purpose of the equivalence relation *E* is to force two identified
variables to keep the same binding.  The rationale for this is explained
in the `Mutable objects`_ section below.  It is enforced by the
following family of rules (one for each pair *(x,y)*)::

         (x~y) in E
      ----------------------------------------
               merge b(x) => y
               merge b(y) => x

Note that a priori, all rules should be tried repeatedly until none of
them generalizes the state any more, at which point we have reached a
fixpoint.  However, the rules are well suited to a simple metarule that
tracks a small set of rules that can possibly apply.  Only these
"scheduled" rules are tried.  The metarule is as follows:

- when an identification *x~y* is added to *E*, then the rule
  ``(x~y) in E`` is scheduled to be considered;

- when a binding *b(x)* is modified, then all rules about operations
  that have *x* as an input argument are (re-)scheduled.  This includes
  the rules ``(x~y) in E`` for each *y* that *E* identifies to *x*.
  This also includes the cases where *x* is the auxiliary variable
  of an operation (see `Flow graph model`_).

These rules and metarules favor a forward propagation: the rule
corresponding to an operation in a flow graph typically modifies the
binding of the operation's result variable which is used in a following
operation in the same block, thus scheduling the following operation's
rule for consideration.  The actual process is very similar to -- and
actually implemented as -- abstract interpretation on the flow graphs,
considering each operation in turn in the order they appear in the
block.  Effects that are not local to a block trigger a rescheduling of
the whole block instead of single operations.


Mutable objects
~~~~~~~~~~~~~~~

Tracking mutable objects is the difficult part of our approach.  RPython
contains three types of mutable objects that need special care: lists
(Python's vectors), dictionaries (mappings), and instances of
user-defined classes.  The current section focuses on lists;
dictionaries are similar.  `Classes and instances`_ will be described in
their own section.

For lists, we try to derive a homogenous annotation for all items of the
list.  In other words, RPython does not support heteregonous lists.  The
approach is to consider each list-creation point as building a new type
of list and following the way the list is used to derive the union type
of its items.

Note that we are not trying to be more precise than finding a single
item type for each list.  Flow-sensitive techniques could be potentially
more precise by tracking different possible states for the same list at
different points in the program and in time.  But in any case, a pure
forward propagation of annotations is not sufficient because of
aliasing: it is possible to take a reference to a list at any point, and
store it somewhere for future access.  If a new item is inserted into a
list in a way that generalizes the list's type, all potential aliases
must reflect this change -- this means all references that were "forked"
from the one through which the list is modified.

To solve this, each list annotation -- ``List(v)`` -- contains an
embedded variable, called the "hidden variable" of the list.  It does
not appear directly in the flow graphs of the user program, but
abstractedly stands for "any item of the list".  The annotation
``List(v)`` is propagated forward as with other kinds of annotations, so
that all aliases of the list end up being annotated as ``List(v)`` with
the same variable *v*.  The binding of *v* itself, i.e. ``b(v)``, is
updated to reflect generalization of the list item's type; such an
update is instantly visible to all aliases.  Moreover, the update is
described as a change of binding, which means that the metarules will
ensure that any rule based on the binding of this variable will be
reconsidered.

The hidden variable comes from the auxiliary variable syntactically
attached to the operation that produces a list::

         z=new_list() | z'
      -------------------------------------
               b' = b with (z->List(z'))

Inserting an item into a list is done by merging the new item's
annotation into the list's hidden variable (*y* is the index in the list
*x* and *z* is the new item)::

         setitem(x,y,z), b(x)=List(v)
      --------------------------------------------
               merge b(z) => v

Reading an item out a list requires care to ensure that the rule is
rescheduled if the binding of the hidden variable is generalized.  We do
so be identifying the hidden variable with the current operation's
auxiliary variable.  The identification ensures that the hidden
variable's binding will eventually propagate to the auxiliary variable,
which -- according to the metarule -- will reschedule the operation's
rule::

         z=getitem(x,y) | z', b(x)=List(v)
      --------------------------------------------
               E' = E union (z'~v)
               b' = b with (z->b(z'))

If you consider the definition of `merge`_ again, you will notice
that merging two different lists (for example, two lists that come from
different creation points via different code paths) identifies the two
hidden variables.  This effectively identifies the two lists, as if they
had the same origin.  It makes the two list annotations aliases for each
other, allowing any storage location to contain lists coming from any of
the two sources indifferently.  This process gradually builds a
partition of all lists in the program, where two lists are in the
partition if they are combined in any way.

As an example of further list operations, here is the addition (which is
the concatenation for lists)::

         z=add(x,y), b(x)=List(v), b(y)=List(w)
      --------------------------------------------
               E' = E union (v~w)
               b' = b with (z->List(v))

As with `merge`_, it identifies the two lists.


Prebuilt constants
~~~~~~~~~~~~~~~~~~

The ``Pbc`` annotations play a special role in our approach.  They
regroup in a single family most of the constant user-defined objects
that pre-exist the annotation phase.  This includes the functions and
classes defined in the user program, but also some other objects that
have been built while the user program was initializing itself.

The presence of the latter kind of objects -- which comes with a number
of new problems to solve -- is a distinguishing property of the idea of
analysing a live program instead of static source code.  All the user
objects that pre-exist the annotation phase are divided in two further
families: the "frozen prebuilt constants" ones and the "prebuilt
instances".  By default, instances of some user-defined class that
happens to pre-exist annotation have no constantness requirement on
their own; after annotation and possibly compilation, these instances
will continue to behave as regular mutable instances of that class,
turned into mostly regular ``Inst(C)`` annotations when the annotator
encounters them.  However, the user program can give a hint that forces
the annotator to consider the object as a "frozen prebuilt constant".
The object is then considered as a now-immutable container of
attributes.  It looses its object-oriented aspects and its class becomes
irrelevant -- it was only useful to the user program to build the object
up to its current state.

In summary, the prebuilt constants are:

* all functions ``f`` of the user program (including the ones appearing
  as methods);

* all classes ``C`` of the user program;

* all frozen prebuilt constants;

For convenience, we add the following objects to the above set:

* for each function ``f`` and class ``C``, a "potential bound method"
  object written ``C.f``, used below to handle method calls;

* the singleton None object (a special case of frozen prebuilt constant).

The annotation ``Pbc(*set*)`` stands for an object that belongs to the
specified *set* of prebuilt constant objects, which is a subset of all
the prebuilt constant objects.

In practice, the set of all prebuilt constants is not fixed in advance,
but grows while annotation discovers new functions and classes and
frozen user objects; only the objects that are still alive will be
included in the set, leaving out the ones that were only relevant during
the initialization phase of the program.


Classes and instances
~~~~~~~~~~~~~~~~~~~~~

Remember that Python has no notion of classes declaring attributes and
methods.  Classes are merely hierarchical namespaces: an expression like
``obj.attr`` means that the ``attr`` attribute is looked up in the class
that ``obj`` is an instance of at run-time, and all parent classes (a
``getattr`` operation).  Expressions like ``obj.meth()`` that look like
method calls are actually grouped as ``(obj.meth)()``: they correspond
to two operations, a ``getattr`` followed by a ``call``.  The
intermediate object ``obj.meth`` is a bound method.

As the goal of annotator is to derive type information about the user
program that is static enough, it must reconstruct a static structure
for each class in the hierarchy.  It does so by observing the usage
patterns of the classes and their instances, by propagating annotations
of the form ``Inst(cls)`` -- which stands for "an instance of the class
*cls* or any subclass".  Instance fields are attached to a class
whenever we see that the field is being written to an instance of this
class.  If the user program manipulates instances polymorphically, the
variables holding the instances will be annotated ``Inst(cls)`` with
some abstract base class *cls*; accessing attributes on such generalized
instances lifts the inferred attribute declarations up to *cls*.  The
same technique works for inferring the location of both fields and
methods.

~~~~~~~~~~~~~~~~~~~~~~

We assume that the classes in the user program are organized in a single
inheritance tree rooted at the ``object`` base class.  (Python supports
multiple inheritance, but the annotator is limited to single inheritance
plus simple mix-ins.)  We also assume that polymorphic instance usage is
"bounded" in the sense that all instances that can reach a specific
program point are instances of a user-defined common base class, i.e.
not ``object``.

Remember from `definition of V`_ that we have a variable ``v_C.attr``
for each class ``C`` and each possible attribute name ``attr``.  The
annotation state *(b,E)* has the following meaning on these variables:

* the binding map *b* gives an annotation to each of them, as with other
  variables.  The annotation ``b(v_C.attr)`` is the inferred type of the
  values that can show up when the attribute ``attr`` is read out of an
  instance of ``C``.

* to account for the inheritance between classes, the equivalence
  relation *E* identifies some of these variables as follows: if an
  attribute ``attr`` is found to belong to a base class ``C``, then all
  variables ``v_D.attr`` for all subclasses ``D`` of ``C`` are
  identified with ``v_C.attr``.  This ensures that the instances of the
  subclasses are all given the same generic attribute defined in ``C``.

Formally::

         z=getattr(x,attr) | z', b(x)=Inst(C)
      ---------------------------------------------------------------------
               E' = E union (v_C.attr ~ v_D.attr)  for all D subclass of C
               E' = E union (z' ~ v_C.attr)
               b' = b with (z->lookup_filter(b(z'), C))


         setattr(x,attr,z), b(x)=Inst(C)
      ---------------------------------------------------------------------
               E' = E union (v_C.attr ~ v_D.attr)  for all D subclass of C
               check b(z) for the absence of potential bound method objects
               merge b(z) => v_C.attr

Note the similarity with the ``getitem`` and ``setitem`` of lists, in
particular the usage of the auxiliary variable *z'*.

The purpose of ``lookup_filter`` is to avoid loosing precision in method
calls.  Indeed, if ``attr`` names a method of the class ``C`` then the
binding ``b(v_C.attr)`` is initialized to ``Pbc(m)``, where *m* is the
following set:

* for each subclass ``D`` of ``C``, if the class ``D`` introduces a method
  ``attr`` implemented as, say, the function ``f``, then the "potential
  bound method" object ``D.f`` belongs to *m*.

However, because of the possible identification between the variable
``v_C.attr`` and the corresponding variable ``v_B.attr`` of a
superclass, the set *m* might end up containing potential bound methods
of other unrelated subclasses of ``B``, even when performing a
``getattr`` on what we know is an instance of ``C``.  The
``lookup_filter`` reverses this effect as follows::

    lookup_filter(Pbc(set), C) = Pbc(newset)
    lookup_filter(NonPbcAnnotation, C) = NonPbcAnnotation

where the *newset* only keeps the non-methods of *set* (if any) plus the
following methods:

* the ones bound to a strict subclass of ``C``, plus

* among the methods bound to ``C`` or superclasses of ``C``, only the
  one from the most derived class.

Finally, note that we still allow real bound methods to be handled quite
generically, in the way that is quite unique to Python: if ``meth`` is
the name of a method of *x*, then ``y = x.meth`` is allowed, and the
object *y* can be passed around and stored in data structures.  However,
we do not allow such objects to be stored directly back into other
instances (it is the purpose of the check in the rule for ``setattr``).
This would create a confusion between class-level and instance-level
attributes in a subsequent ``getattr``, because our annotator does not
distinguish these two levels -- there is only one set of ``v_C.attr``
variables for both.


Calls
~~~~~

The ``Pbc`` annotations regroup (among others) all user-defined callable
objects: functions, methods and classes.  A call in the user program
turns into a ``simplecall`` operation whose first argument is the object
to call.  Here is the corresponding rule -- regrouping all cases because
the same ``Pbc(set)`` could mix several kinds of callables::

         z=simplecall(x,y1,...,yn), b(x)=Pbc(set)
      ---------------------------------------------------------------------
           for each c in set:
               if c is a function:
                   E' = E union (z ~ returnvar_c)
                   merge b(y1) => arg_c_1
                   ...
                   merge b(yn) => arg_c_n
               if c is a class:
                   let f = c.__init__
                   merge Inst(c) => z
                   merge Inst(c) => arg_f_1
                   merge b(y1) => arg_f_2
                   ...
                   merge b(yn) => arg_f_(n+1)
               if c is a method:
                   let class.f = c
                   E' = E union (z ~ returnvar_f)
                   merge Inst(class) => arg_f_1
                   merge b(y1) => arg_f_2
                   ...
                   merge b(yn) => arg_f_(n+1)

Calling a class returns an instance and flows the annotations into the
contructor ``__init__`` of the class.  Calling a method inserts the
instance annotation as the first argument of the underlying function
(the annotation is exactly ``Inst(C)`` for the class ``C`` in which the
method is found).


Termination and soundness
~~~~~~~~~~~~~~~~~~~~~~~~~

As the annotation process is a fix-point search, it is necessary for
completeness to prove more formally that it is well-behaved.  The
following proofs are all rather easy given the approach we have taken.

Termination
***********

We first have to check that each rule can only turn a state *(b,E)* into
a state *(b',E')* that is either identical or more general.  Clearly,
*E'* can only be generalized -- applying a rule can only add new
identifications, not remove existing ones.  What is left to check is
that the annotation ``b(v)`` of each variable, when modified, can only
become more general.  We prove it in the following order:

1. the annotations ``b(v_C.attr)`` of variables corresponding to
   attributes on classes;

2. the annotations of the input variables of blocks;

3. the annotations of the auxiliary variable of operations;

4. the annotations of the input and result variables of operations.

Proof:

1. Variables corresponding to attributes of classes

       The annotation of such variables can only be modified by the
       ``setattr`` rule and by being identified with other variables,
       i.e. by the ``(x~y) in E`` rule.  In both cases the modification
       is done with a ``merge``.  The latter trivially guarantees the
       property of generalization, as it is based on the union operator
       ``\/`` of the lattice.

2. Input variables of blocks

       The annotation of these variables are only modified by the
       ``phi`` rule, which is based on ``merge``.

3. Auxiliary variables of operations

       The auxiliary variable *z'* of an operation is only ever modified
       by being identified with other variables.

4. Input and result variables of operations

       First note that the result variable *z* of an operation is only
       ever modified by the rule or rules specific to that operation.
       This is true because *E* never identifies such a result variable
       with any other variable.  This allows us to check the property of
       generalization on a case-by-case basis.

       For a given block, we prove this point by recurrence on the
       number of operations present in the block.  The recurrence is
       based on the fact that each input variable of an operation must
       be either the result variable of a previous operation of the same
       block or an input variable of the block.  By the point 2 above,
       if it is an input variable of the block then it can only get
       generalized, as desired.  So the recurrence step only needs to
       check that if all the input variables of an operation can only be
       generalized, then the same property holds for its result
       variable.

       Most cases are easy to check.  Cases like ``b' = b with
       (z->b(z'))`` are based on point 3 above.  The only non-trivial
       case is in the rule for ``getattr``::

            b' = b with (z->lookup_filter(b(z'), C))

       The class ``C`` comes from the annotation ``Inst(C)`` of an input
       variable.  This is where the recurrence hypothesis is needed.  It
       is enough to prove that given annotations ``a1 <= a2`` and
       ``Inst(C1) <= Inst(C2)``, we have::

            lookup_filter(a1, Inst(C1)) <= lookup_filter(a2, Inst(C2))

       The only interesting case is if ``a1 = Pbc(set1)`` and ``a2 =
       Pbc(set2)``.  In this case *set1* is a subset of *set2*.  ...

       XXX first prove that the sets are "reasonable": if C.f in set,
           then D.f in set for all parent classes D


STOP

using the previous point, this can be checked on the rule (or rules) of
each operation independently.  Indeed, there are only two ways in which
``b(z)`` is modified: by ``merge .. => z``, which trivially
guarantees the property by being based on the union operator ``\/`` of
the lattice, or explicitely in a way that can easily be checked to
respect the property.




Each basic step (execution of one rule) can lead to the generalization
of the state.  If it does, then other rules may be scheduled or
re-scheduled for execution.  The state can only be generalized a finite
number of times because both the lattice *A* and the set of variables
*V* of which *E* is an equivalence relation are finite.  If a rule does
not lead to any generalization, then it does not trigger re-scheduling
of any other rule.  This ensures that the process eventually terminates.

The extended lattice used in practice is a priori not finite.  As we did
not describe this lattice formally here, we have to skip the (easy)
proof that it still contains no infinite ascending chain.  An ascending
chain is a sequence where each item is strictly larger than the previous
one.

Soundness
*********

We define an annotation state to be *sound* if none of the rules would
lead to further Xxx.


XXX termination + soundness + most-precise-fixpoint-ness + complexity 


Complexity
**********

The lattice is finite, although its size depends on the size of the
program.  The List part has the same size as *V*, and the Pbc part is
exponential on the number of prebuilt constants.  However, in this model
a chain of annotations cannot be longer than::

    max(5, number-of-pbcs + 3, depth-of-class-hierarchy + 3).

In the extended lattice used in practice it is more difficult to compute
an upper bound.  Such a bound exists -- some considerations can even
show that a finite subset of the extended lattice suffices -- but it
does not reflect any practical complexity considerations.  It is simpler
to prove that there is no infinite ascending chain, which is enough to
guarantee termination.

Additionally, an important property of ``lookup_filter`` is to be
monotonic: XXX


Non-static aspects
~~~~~~~~~~~~~~~~~~

Specialization
***************

The type system used by the annotator does not include polymorphism
support beyond object-oriented polymorphism with subclasses and
overriding and parametric polymorphism for builtin containers (lists,
...).  In this respect we opted for simplicity, considering this in
most cases sufficient for the kind of system programming RPython is
aimed at and matching our main targets.

Not all of our target code or expressivity needs fit into this model.
The fact that we allow unrestricted dynamism at bootstrap helps a
great deal, but in addition we also support the explicit flagging of
certain functions or classes as requiring special treatment.  One such
special treatment is support for parametric polymorphism, which if
supported for all callables would lead to an explosion of function
implementations and likely the need for some kind of target specific
type erasure and coalescing.

Another special treatment is more outright special casing: providing
code to explicitly compute the annotation information for a given
function as opposed to abstractly interpreting the function's
bytecode.

XXX details of what is supported



XXX executing more user program code (idem)

XXX constant propagation to remove bootstrap-only code

XXX termination even with non-static aspects


Code Generation
===============================

XXX rewriting to low-level operations

XXX introduction, repr

Low-level type system for C
~~~~~~~~~~~~~~~~~~~~~~~~~~~

XXX

Implementing operations as helpers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

XXX XXX reusing the annotator and specialization

Generating C code
~~~~~~~~~~~~~~~~~

XXX collecting functions and data structures recursively

XXX inserting hand-written C functions for suggested_primitives

XXX messy



.. _architecture: architecture.html
.. _`Thunk Object Space`: objspace.html#the-thunk-object-space
.. _`abstract interpretation`: theory.html#abstract-interpretation
.. _`formal definition`: http://en.wikipedia.org/wiki/Abstract_interpretation
.. _lattice: http://en.wikipedia.org/wiki/Lattice_%28order%29
.. _`join-semilattice`: http://en.wikipedia.org/wiki/Semilattice
.. _`Flow Object Space`: objspace.html#the-flow-object-space
.. _`Standard Object Space`: objspace.html#the-standard-object-space
.. _Psyco: http://psyco.sourceforge.net/
.. _`ACM SIGPLAN 2004 paper`: http://psyco.sourceforge.net/psyco-pepm-a.ps.gz
.. _`Hindley-Milner`: http://en.wikipedia.org/wiki/Hindley-Milner_type_inference

.. include:: _ref.txt
