============================================
PyPy Extension Compiler 
============================================

This document describes the PyPy extension compiler which is able to
compile a set of source code to a PyPy or a CPython extension module.

**WARNING: this is beta software, APIs and details may change.**

The documentation corresponds to release 0.9.  The extension compiler
has not been extensively tested and polished so far, so bugs and rough
edges are likely.


Understanding the ext compiler 
----------------------------------

PyPy provides a generic way to write modules for all Python
implementations: the so-called *mixed module* approach.  A single mixed
module is implemented as a set of Python source files, making a
subpackage of the ``pypy.module`` package.  While running PyPy, each of
these subpackages appears to be a single module, whose interface was
specified in the ``__init__.py`` of the subpackage, and whose
implementation is lazily loaded from the various other ``.py`` files of
the subpackage.

The subpackage is written in a way that allows it to be reused for
non-PyPy implementations of Python.  The goal of the *Extension
Compiler* is to compile a mixed module into an extension module for
these other Python implementation (so far, this means CPython only).

This means that you can do the following with a mixed module:

* run it on top of CPython.  This uses the CPy Object Space to directly
  run all space operations.  Example::

    $ python
    >>> from pypy.interpreter.mixedmodule import testmodule
    >>> demo = testmodule("_demo")
    [ignore output here]
    >>> demo.measuretime(1000000, long)
    5

* compile it as a CPython extension module.  Example::

    $ pypy/bin/compilemodule.py _demo
    [lots of output]
    Created '/tmp/usession-5/_demo/_demo.so'.
    $ cd /tmp/usession-5/_demo
    $ python
    >>> import _demo
    >>> _demo.measuretime(10000000, long)
    2

* run it with PyPy on top of CPython.  Example::

    $ python pypy/bin/py.py --usemodules=_demo
    PyPy 0.9.0 in StdObjSpace on top of Python 2.4.4c0 (startuptime: 2.47 secs)
    >>>> import _demo
    >>>> _demo.measuretime(10000, long)
    [ignore output here]
    4

* compile it together with PyPy.  It becomes a built-in module of ``pypy-c``.
  Example::

    $ cd pypy/translator/goal
    $ python translate.py targetpypystandalone --usemodules=_demo
    [wait for 1/2 to 1 hour]
    [translation:info] created: ./pypy-c
    (Pbd)
    $ ./pypy-c
    Python 2.4.1 (pypy 0.9.0 build 28xxx) on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    (InteractiveConsole)
    >>>> import _demo
    >>>> _demo.measuretime(10000000, long)
    2


- using rctypes for binding to external libraries 
- exchangeability of CPyObjspace and StdObjSpace 
  * translation to CPython 
  * translation to PyPy 

Using the ext compiler  
----------------------------------------------------

XXXXXXXXXXXXXXXX THIS IS DOCUMENTATION WITHOUT CODE XXXXXXXXXXXXXXXXXXXXXX

writing a module (provide example)
+++++++++++++++++++++++++++++++++++++++++

You have to put your module into its own directory in `pypy/module/`_ 
of your local `pypy checkout`_. 

see `pypy/module/readline`_ for an example. 

XXX describe directory structure here 

.. _`pypy checkout`: getting-started.html#gettingpypy

testing a module 
++++++++++++++++++++++++

testing only the (ctypes) bindings::

    python2.4 pypy/test_all.py pypy/module/readline/test/test_c_readline.py 

testing the (wrapped) package::
    python2.4 pypy/test_all.py pypy/module/readline/test/test_readline.py 

or::
    py.test pypy/module/readline/test/test_readline.py 

# XXX 

pypy/module/readline/test/test_readline.py


translating a module to a CPython extension
++++++++++++++++++++++++++++++++++++++++++++++++++++

:: 
    python2.4 pypy/bin/extcompiler.py readline  #<needs to be in module dir

The extension compiler imports the specified module/package 
and produces a shared library importable from your local 
python2.4 installation.  The produced shared library is 
put into the current working directory by default. 

XXX think about shared state of imported modules (e.g. linecache
    or other modules which might get imported from the ext-package) 

XXX what actually happens to applevel code in an extension module? 

somewhere-in-PYTHONPATH:
    supportpackage/somecode.py 


XXX integration as a PyPy module 




Installation notes requirements 
--------------------------------------------------

XXX more verbose, links
you need to have a full PyPy checkout, refer to getting started

required ctypes version
++++++++++++++++++++++++++++

As of this time, only `ctypes-0.9.9.6`_ is known to work. 

.. _`ctypes-0.9.9.6`: http://sourceforge.net/project/showfiles.php?group_id=71702&package_id=71318&release_id=411554 

platform notes 
++++++++++++++++++


Mac OSX 
++++++++++++++++++++++++++

*ctypes 0.9.9.6 on OSX 10.3*: you need to change the ``RTLD_LOCAL`` default 
in  ctypes/__init__.py line 293 to::

    def __init__(self, name, mode=RTLD_GLOBAL, handle=None):

otherwise it will complain with "unable to open this file with RTLD_LOCAL"
when trying to load the C library. 

.. include:: _ref.txt
