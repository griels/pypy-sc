
=============================
PyPy's ctypes implementation 
=============================

terminology:

* application level code - code written in full Python

* interpreter level code - code written in RPython, compiled
  to something else, say C, part of the interpreter.

PyPy's ctypes implementation in its current state proves the
feasibility of implementing a module with the same interface and
behavior for PyPy as ctypes for CPython.

PyPy's implementation internally uses `libffi`_ like CPython's ctypes.
In our implementation as much as possible of the code is written in
full Python, not RPython. In CPython's situation, the equivalent would
be to write as little as possible code in C.  We essentially favored
rapid experimentation over worrying about speed for this first trial
implementation. This allowed to provide a working implementation with
a large part of ctypes features in 2 months real time.

We reused the ``ctypes`` package as-is from CPython. We implemented
``_ctypes`` which is a C module in CPython mostly in pure Python based on
a lower-level layer extension module ``_rawffi``.

.. _`libffi`: http://sources.redhat.com/libffi/

Low-level part: ``_rawffi``
============================

This PyPy extension module (``pypy/module/_rawffi``) exposes a simple interface
to create C objects (arrays and structures) and calling functions
in dynamic libraries through libffi. Freeing objects in most cases and making
sure that objects referring to each other are kept alive is responsibility of the higher levels.

This module uses bindings to libffi which are defined in ``pypy/rlib/libffi.py``.

We tried to keep this module as small as possible. It is conceivable
that other implementations (e.g. Jython) could use our ctypes
implementation by writing their version of ``_rawffi``.

High-level parts
=================

The reused ``ctypes`` package lives in ``pypy/lib/ctypes``. ``_ctypes``
implementing the same interface as ``_ctypes`` in CPython is in
``pypy/lib/_ctypes``.

Discussion and limitations
=============================

Reimplementing ctypes features was in general possible. PyPy supports
pluggable garbage collectors, some of them are moving collectors, this
means that the strategy of passing direct references inside Python
objects to an external library is not feasible (unless the GCs
support pinning, which not the case right now).  The consequence of
this is that sometimes copying instead of sharing is required, this
may result in some semantics differences. C objects created with
_rawffi itself are allocated outside of the GC heap, so they can be
passed to external functions without worries.

Porting the implementation to interpreter-level should likely improve
its speed, Further the current layering and the current _rawffi
interface require more object allocations and copying than strictly
necessary, this too could be improved.

The implementation was developed and has only been tested on Linux.

Here is a list of the limitations and missing features of the
current implementation:

* No support for ``PyXxx`` functions from ``libpython``, for obvious reasons.

* We copy Python strings instead of having pointers to raw buffers

* Features we did not get to implement:

  - custom alignment and bit-fields

  - resizing (``resize()`` function)

  - non-native byte-order objects

  - callbacks accepting by-value structures

  - expected semantics when ctypes types are subclassed

Getting the code and test suites
=================================

A stable revision of PyPy containing the ctypes implementation can be checked out with subversion from: 

http://codespeak.net/svn/pypy/branch/ctypes-stable XXX make the branch

The various tests can be run on Linux.

If one goes inside the checkout it is possible to run ``_rawffi`` tests with::

    $ cd pypy
    $ python test_all.py module/_rawffi/

The ctypes implementation test suite is derived from the tests for
ctypes 1.0.2, we have skipped some tests corresponding to not
implemented features or implementation details, we have also added
some tests.

To run the test suite a compiled pypy-c is required with the proper configuration. To build the required pypy-c  one should inside the checkout::

   $ cd pypy/translator/goal
   $ ./translate.py --text --batch --gc=generation targetpypystandalone.py --withmod-_rawffi 

this should produce a pypy-c executable in the ``goal`` directory.

To run the tests then::

   $ cd ../.. # back to pypy/
   $ ./translator/goal/pypy-c test_all.py lib/app_test/ctypes_tests

There should be 255 passed and 36 skipped tests.

Running example code
=====================

XXX not reviewed or tried yet

You need a translation with ``--withmod-_rawffi`` in order to run any
ctypes code. For most examples ``--allworkingmodules`` translation option
also makes sense. Known applications to run are `pysqlite-ctypes`_ and
`pyglet`_. As of March 2008, from pysqlite all tests passes except one
that relies on __del__ being called immediately. From pyglet, the following
examples work:
  
  - opengl.py
  - multiple_windows.py
  - events.py
  - window_platform_event.py
  - fixed_resolution.py
  - html_label.py
  - media_player.py
  - timer.py

The following don't work:

  - fixed_resolution.py needs PIL
  - image_convert.py needs PIL
  - image_display.py needs PIL
  - astraea/astraea.py needs PIL
  - video.py (but didn't work for me on CPython either)
  - soundscape needs avbin

The `stress tests`_ of Johnathan Hartley is also working.

.. _`pysqlite-ctypes`: http://XXX-link
.. _`pyglet`: http://pyglet.org/
.. _`stress tests`: http://tartley.com/?p=264


ctypes configure
=================

We also released `ctypes-configure`_, which is an experimental package trying to
approach the portability issues of ctypes-based code.

.. _`ctypes-configure`: http://codespeak.net/~fijal/configure.html
