JIT ideas and areas of work
------------------------------

Plan
===========================

Short-term plans:

1. Write a small interpreter in RPython for whatever bytecode language,
   as an example and for testing.  The goal is to turn that interpreter
   into a JIT.

2. Write code that takes LL graphs and "specializes" them, by making a
   variable constant and propagating it.

3. Think more about how to plug 1 into 2 :-)


Discussion and details
===========================

Low-level graphs abstract interpreter
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the context of PyPy architecture a JIT can be envisioned as a
run-time specialiser (doing constant folding, partial evaluation and
keeping allocation virtual as much as possible). The specialiser would
be able to produce for some runtime execution state of a function new
low-level graphs from a predetermined relevant subset of the forest of
low-level graphs making up PyPy and given entry points and parameter
variables whose run-time constantness can be exploited (think the eval
loop for an entry-point and the bytecode of the function for such a
variable and the graphs for the directly involved PyPy functions as the
subset). This new low-level graphs could then be turned into machine
code by a run-time machine code backend, mapping progressively
the function bytecode into machine code.

Ideally PyPy translation should generate code from this determined
subset, list of entry-points and variables that implements run-time
specialisation for it, plus management/bookkeeping and instrumentation
code.

To explore and understand this problem space, we should probably start
by writing a pure Python abstract interpreter doing constant-folding
and partial evaluation of low-level graphs. Increasing abstraction
this could maybe evolve in the code for generating the specialiser or
at least be used to analyse which subset of the graphs is relevant.

issue: too fine granularity of low-level implementations of rpython dicts

Simple target interpreter for experimentation and testing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

Given that PyPy eval loop is quite a large chunk to swallow, ahem,
analyse, it would be nice to have some kind of minimal bytecode eval
loop for some very simple bytecode written in RPython to use for
testing/experimenting and as first target. Ideally the interpreter
state for this should not be much more than an instruction counter and
a value stack.

L3 interpreter
~~~~~~~~~~~~~~~~~~~

* in RPython

* the code should try to be straightforward (also for efficiency)

* try to avoid needing maximal parameters that need to be 
  computed over all the graph (makes emitting a graph incrementally harder)

* one major issue to keep in mind is where the information
  about offsets into low-level data types comes from/is computed
  (C compiler offset values, vs. made-up values)

* translatable together with an RPython program, and capable
  of accepting (constant) data and functions from it 
  in the interpreted graphs

* ideally this should evolve into the intermediate representation
  used between the JIT and the machine code backends


Machine code backends and register allocation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

xxx

Alternative: RPython interface to code generation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As a first step, to allow experimentation with code generation without
all the difficulties of the L3 graph model and L3 interpreter, we could
provide a set of primitive RPython functions that enable simple code
generation.

TBD
