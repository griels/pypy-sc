=====================
 PyPy - Translation
=====================

.. contents::
.. sectnum::

This document describes the tool chain that we have developed to analyze
and "compile" RPython_ programs (like PyPy itself) to various target
platforms.

.. _RPython: coding-guide.html#restricted-python

It consists of three broad sections: a slightly simplified overview, a
brief introduction to each of the major components of our tool chain and
then a more comprehensive section describing how the pieces fit together.
If you are reading this document for the first time, the Overview_ is
likely to be most useful, if you are trying to refresh your PyPy memory
then the `How It Fits Together`_ is probably what you want.

Overview
========

The job of translation tool-chain is to translate RPython_ progams into an
efficient version of that progam for one of various target platforms,
generally one that is considerably lower-level than Python.  It divides
this task into several steps, and the purpose of this document is to
introduce them.

As of the 0.9 release, RPython_ programs can be translated into the following
languages/platforms: C/POSIX, LLVM/POSIX, CLI/.NET, Squeak, Javascript and
Common Lisp (in addition, there's `a backend`_ that translates
`application-level`_ into `interpreter-level`_ code, but this is a special
case in several ways).

.. _`a backend`: geninterp.html
.. _`application-level`: coding-guide.html#application-level
.. _`interpreter-level`: coding-guide.html#interpreter-level


The choice of the target platform affects the process somewhat, but to
start with we describe the process of translating an RPython_ program into
C (which is the default and original target).

Most of the steps in the translation process operate on control flow
graphs, which are produced from functions in the input program, analyzed,
transformed and then translated to the target language.

It is helpful to consider translation as being made up of the following
steps:

1. The complete program is imported, arbitrary run-time initialization can
   be performed.  Once this is done, the program must be present in memory
   as a form that is "static enough" in the sense of RPython_.

2. The Annotator_ performs a global analysis starting from an specified
   entry point to deduce type and other information about what each
   variable can contain at run-time, building flow graphs using the `Flow
   Object Space`_ as it encounters them.

3. The `RPython Typer`_ (or RTyper) uses the high-level information
   inferred by the Annotator to turn the operations in the control flow
   graphs into low-level operations.

4. After RTyping there are two, rather different, `optional
   transformations`_ which can be applied -- the "backend optimizations"
   which are make the resulting program go faster, and the "stackless
   transform" which transforms the program into a form of continuation
   passing style which allows the implementation of coroutines and other
   forms of non-standard control flow.

5. The next step is `preparing the graphs for source generation`_, which
   involves computing the names that the various functions and types in
   the program will have in the final source and applying transformations
   which insert explicit exception handling and memory management
   operations.

6. The `C backend`_ (colloquially known as "GenC") produces a number of C
   source files (as noted above, we are ignoring the other backends for
   now).

7. These source files are compiled to produce an executable.

(although these steps are not quite as distinct as you might think from
this presentation).

There is an `interactive interface`_ called `translatorshell.py`_ to the
translation process which allows you to interactively work through these
stages.

.. _`SSA`: http://en.wikipedia.org/wiki/Static_single_assignment_form
.. _`translator.py`: http://codespeak.net/pypy/dist/pypy/translator/translator.py
.. _`play around`: getting-started.html#trying-out-the-translator
.. _`Flow Object Space`: objspace.html#the-flow-object-space
.. _`control flow graph`: objspace.html#the-flow-model
.. _`Common Lisp`: http://codespeak.net/pypy/dist/pypy/translator/cl/
.. _Pyrex: http://codespeak.net/pypy/dist/pypy/translator/pyrex/
.. _JavaScript: http://codespeak.net/pypy/dist/pypy/translator/js/
.. _Squeak: http://codespeak.net/pypy/dist/pypy/translator/squeak/
.. _CLI: http://codespeak.net/pypy/dist/pypy/translator/cli/
.. _graph: image/translation.pdf
.. _`interactive interface`: getting-started.html#try-out-the-translator
.. _`translatorshell.py`: http://codespeak.net/pypy/dist/pypy/bin/translatorshell.py

The Flow Model
==============

The `Flow Object Space`_ is described in detail in the `document
describing object spaces`_, but as the data structures produced by the
Flow Object Space are the basic data structures of the translation
process, we quickly summarize them here.

All these types are defined in `pypy.objspace.flow.model`_ (which is the
most imported module in the PyPy source base, to reinforce the point).

The flow graph of a function is represented by the class ``FunctionGraph``.
It contains a reference to a collection of ``Block``\ s connected by ``Link``\ s.

A ``Block`` contains a list of ``SpaceOperation``\ s.  Each ``SpaceOperation``
has an ``opname`` and a list of ``args`` and ``result``, which are either
``Variable``\ s or ``Constant``\ s.

We have an extremely useful PyGame viewer, which allows you to visually
inspect the graphs at various stages of the translation process (very
useful to try to work out why things are breaking).  It looks like this:

   .. image:: image/bpnn_update.png

.. _`document describing object spaces`: objspace.html
.. _`pypy.objspace.flow.model`: http://codespeak.net/pypy/dist/pypy/objspace/flow/model.py

.. _Annotator:

The Annotation Pass
===================

We describe briefly below how a control flow graph can be "annotated" to
discover the types of the objects.  This annotation pass is a form of type
inference.  It operates on the control flow graphs built by the Flow
Object Space.

For a more comprehensive description of the annotation process, see
sections XXX of `Compiling Dynamic Language Implementations`_.

The major goal of the annotator is to "annotate" each variable that
appears in a flow graph.  An "annotation" describes all the possible
Python objects that this variable could contain at run-time, based on a
whole-program analysis of all the flow graphs --- one per function.

An "annotation" is an instance of a subclass of ``SomeObject``.  Each
subclass that represents a specific family of objects.

Here is an overview (see ``pypy.annotation.model``):

* ``SomeObject`` is the base class.  An instance of ``SomeObject()``
  represents any Python object, and as such usually means that the input
  program was not fully RPython.

* ``SomeInteger()`` represents any integer.  ``SomeInteger(nonneg=True)``
  represent a non-negative integer (``>=0``).

* ``SomeString()`` represents any string; ``SomeChar()`` a string of
  length 1.

* ``SomeTuple([s1,s2,..,sn])`` represents a tuple of length ``n``.  The
  elements in this tuple are themselves constrained by the given list of
  annotations.  For example, ``SomeTuple([SomeInteger(), SomeString()])``
  represents a tuple with two items: an integer and a string.

(other ``SomeXxx`` classes are described in the `annotator reference`).

There are more complex subclasses of ``SomeObject`` that we describe in
more details below.

All the ``SomeXxx`` instances are immutable.  If the annotator needs to
revise its belief about what a Variable can contain, it does so creating a
new annotation, not mutating the existing one.

The result of the annotation pass is essentially a large dictionary
mapping ``Variable``\ s to annotations.

.. _`Compiling Dynamic Language Implementations`: dynamic-language-translation.html

.. _`RPython typer`:

The RPython Typer
=================

http://codespeak.net/pypy/dist/pypy/rpython/

The RPython Typer is the bridge between the Annotator_ and the code
generator.  The information computed by the annotator is high-level, in
the sense that it describe RPython types like lists or instances of
user-defined classes.

The RTyper is the first place where the choice of backend makes a
difference; as outlined above we are assuming that ANSI C is the target.

In general, though, to emit code we need to represent these high-level
annotations into the low-level model of the target language; for C, this
means structures and pointers and arrays.  The Typer both determines the
appropriate low-level type for each annotation, and tries to replace *all*
operations in the control flow graphs with one or a few low-level
operations.  Just like low-level types, there is only a fairly restricted
set of low-level operations, along the lines of reading or writing from or
to a field of a structure.

In theory, this step is optional; some code generators might be able to read
directly the high-level types.  However, we expect that case to be the
exception.  "Compiling" high-level types into low-level ones is rather more
messy than one would expect.  This was the motivation for making this step
explicit and isolated in a single place.  After Typing, the graphs can only
contain very few operations, which makes the job of the code generators much
simpler.

For more information, see the `documentation for the RTyper`_.

.. _`documentation for the RTyper`: rtyper.html

Example: Integer operations
---------------------------

Integer operations are the easiest.  Assume a graph containing the following operation::

    v3 = add(v1, v2)

annotated::

    v1 -> SomeInteger()
    v2 -> SomeInteger()
    v3 -> SomeInteger()

then obviously we want to type it and replace it with::

    v3 = int_add(v1, v2)

where -- in C notation -- all three variables v1, v2 and v3 are typed ``int``.
This is done by attaching an attribute ``concretetype`` to v1, v2 and v3
(which might be instances of Variable or possibly Constant).  In our model,
this ``concretetype`` is ``pypy.rpython.lltypesystem.lltype.Signed``.  Of
course, the purpose of replacing the operation called ``add`` with
``int_add`` is that code generators no longer have to worry about what kind
of addition (or concatenation maybe?) it means.

.. _`optional transformations`:

The Optional Transformations
============================

Between RTyping and C source generation there are two optional transforms:
the "backend optimizations" and the "stackless transform".

Backend Optimizations
---------------------

Inlining, malloc removal, ...

The Stackless Transform
-----------------------

XXX write this bit

.. or steal it from Carl...

.. _`preparing the graphs for source generation`:

Preparation for Source Generation
=================================

.. _C:
.. _GenC:
.. _`c backend`:

The C Back-End
==============

http://codespeak.net/pypy/dist/pypy/translator/c/

GenC is not really documented at the moment.  The basic principle of
creating code from flowgraphs is similar to the `Python back-end`_.
See also `Generating C code`_ in another draft.

.. _`Generating C code`: dynamic-language-translation.html#generating-c-code


A Historical Note
=================

As this document has shown, the translation step is divided into more
steps than one might at first expect.  It is certainly divided into more
steps than we expected when the project started; the very first version of
GenC operated on the high-level flow graphs and the output of the
annotator, and even the concept of the RTyper didn't exist yet.  More
recently, the fact that preparing the graphs for source generation
("databasing") and actually generating the source are best considered
separately has become clear.

This process is reflected in the source somewhat; for example, the LLVM
and C backends use different implementations of the graph preparation
code, although there is no real reason for this.


Other backends
==============

.. _LLVM:

The LLVM Back-End
-----------------

http://codespeak.net/pypy/dist/pypy/translator/llvm/

For information on getting started on the LLVM (`low level virtual machine`_)
backend - please see `here`_. 

Similar to the task of GenC, GenLLVM translates a flow graph to low level LLVM
bytecode.  GenLLVM requires annotation and the `RPython Typer`_ pass, to modify
the annotated flow graph to replace operations with lower-level equivalents
which are suitable to be easily translated to LLVM bytecode.

The LLVM backend would not have been possible without all the people
contributing to PyPy. Carl Friedrich did an amazing amount of groundwork during
the first half of 2005. Carl Friedrich and Holger then initiated a revamped
version based on the new `RPython Typer`_ flow graph. Significant progress was
made during the Gothenburg sprint - and then the following 6 weeks Eric and
Richard worked on it, achieving a standalone executable just prior to the
Heidelberg sprint.  During the Heildelberg sprint Eric and Richard mainly
worked on sharing the backend external code with GenC.

.. _`low level virtual machine`: http://llvm.org/
.. _`here`: getting-started.html#translating-the-flow-graph-to-llvm-code


.. _`Python again`:
.. _`Python back-end`:

The Object-Oriented Backends
----------------------------

The Interpreter-Level backend
-----------------------------

http://codespeak.net/pypy/dist/pypy/translator/geninterplevel.py

See `geninterp's documentation <geninterp.html>`__.

.. _extfunccalls:

External Function Calls
=======================

There are some functions that we don't want to implement in Python for various
reasons (e.g. if they need to make calls into the OS). These can be
implemented by writing backend code by hand that either implements the
functionality itself or calls appropriate libraries.

Of course the annotator does not know what types these funtions return so we
need a way to attach fixed annotations to such functions. Additionally for
every such function we need a low level helper function that behaves like the
hand-written backend code so that we can still test a call to such an external
function. 


Annotating external function calls
----------------------------------

All the information about external functions that are important for the
annotation process are written into `pypy/rpython/extfunctable.py`_. There is a
function called ``declare`` that allows to tell the annotator the return type
of these functions and to attach a low level dummy implementation::

    declare(funct, annotation_factory, lowlevel_dummy)

Here ``funct`` is the funtion that is supposed to be implemented in the
backend, ``annotation_factory`` is a function that returns an appropriate
annotation of the return value (an instance of a primitive type is also ok, so
you can do ``declare(func, int...)``), lowlevel_dummy is a string of the form
``module/ll_function`` that specifies where the low level dummy function is
defined. Here ``module`` means a Python file in `pypy/rpython/module/`_ and
``ll_function`` is a low level function defined in that file.

If the annotator discovers a call to ``func`` it does not try to follow that
call further (even though that might be possible if the function is written in
Python) but annotates it with the given type immediately. The `RPython Typer`_
replaces calls to ``func`` with calls to the function
``module.ll_function``. The backend is supposed to replace calls to functions
to ``module.ll_function`` by whatever code it finds appropriate.

Implementating low level replacement functions in Python
---------------------------------------------------------

The dummy low level replacement functions are there to implement the external
function on the low level. In contrast to the original function they should
take arguments that are of `low-level type`_. Most of the times they are
implemented by calling appropriate low level to high level conversion
functions and then calling the original funtion again.

.. _`low-level type`: rtyper.html#low-level-type

If the function is supposed to really be implemented by the backend then the
low level function should have an attribute ``.suggested_primitive = True``
attached. If this is not the case the low level function itself will be
translated and used.


Implementing the external functions in the C backend
----------------------------------------------------

When the C-backend produces C code and finds a function call to one of the
dummy functions it replaces the call to it by a call to a function written in
C. This mapping is done in the file `pypy/translator/c/extfunc.py`_. In there
is a dictionary called ``EXTERNALS`` which contains mappings from dummy
functions to strings::

    EXTERNALS = {
        module.ll_function: "LL_c_name_of_function"
        ...
    }

Here ``LL_c_name_of_function`` is the name of the C function that implements
the functionality of the ``module.ll_function``. These C implementation are
found in the directory `pypy/translator/c/src/`_.

It sometimes neccessary to access a certain function or type that is written
in Python from the C code you write by hand (for example for constructing the
return value in the correct low level type). This can be a problem because the
C backend mangels names to prevent clashes. To get a certain low level type
under a fixed name the function ``predeclare_common_types`` needs to be
changed. This function is a generator that yields tuples of the form
``('c_name', LLTYPE)``. This makes the genc assign the name ``c_name`` to the
type ``LLTYPE``. Similarly all the function defined in
``predeclare_utility_functions`` are automatically made accessible under their
name in C.

Testing
-------

It's not always trivial to properly test that all the information that is
needed for a given external function is correct. Usually for a given function
you test at least two different things: Once the dummy low level function by
calling it directly. This is usually done in `pypy/rpython/module/test`_ by
just calling the low level function with appropriately constructed arguments
directly. In addition there should be test that actually tries to translate
a function calling the external function to backend code, compile and run
it. This makes sure that the annotator gets the annotation right and that the
backend code is correct. For the C backend this is done in
`pypy/translator/c/test/test_extfunc.py`_. 

Example
-------

To make this clearer the following shows all the relevant pieces that are
needed for implementing os.open. It is implemented in the following way at
interp-level in the `mixed posix module`_::

    def open(space, fname, flag, mode=0777):
        try: 
            fd = os.open(fname, flag, mode)
        except OSError, e: 
            raise wrap_oserror(space, e) 
        return space.wrap(fd)
    open.unwrap_spec = [ObjSpace, str, int, int]


If the annotator tries to annotate this function it will use the declaration
it finds in the file `pypy/rpython/extfunctable.py`_::

    declare(os.open, int , 'll_os/open')

This means that the function returns an int and that the dummy low level
function can be found in `pypy/rpython/module/ll_os.py`_::

    def ll_os_open(fname, flag, mode):
        return os.open(from_rstr(fname), flag, mode)
    ll_os_open.suggested_primitive = True

The ``suggested_primitive`` attribute of the ``ll_os_open`` is set to True,
because it is reasonable that this function is written directly in the backend.
If the C backend encounters a call to ``ll_os_open`` somewhere in the code it
checks the ``EXTERNALS`` table in `pypy/translator/c/extfunc.py`_. The
relevant part for ``os.open`` is::

    from pypy.rpython.module import ll_os
    EXTERNALS = {
        ...
        ll_os.ll_os_open:    'LL_os_open',
        ...
    }

The `LL_os_open` function is implemented in the file
`pypy/translator/c/src/ll_os.h`_:: 

    int LL_os_open(RPyString *filename, int flag, int mode)
    {
            int fd = open(RPyString_AsString(filename), flag, mode);
            if (fd < 0)
                    RPYTHON_RAISE_OSERROR(errno);
            return fd;
    }

One test for all this can be found in
`pypy/translator/c/test/test_extfunc.py`_::

    def test_os_open():
        tmpfile = str(udir.join('test_os_open.txt'))
        def does_stuff():
            fd = os.open(tmpfile, os.O_WRONLY | os.O_CREAT, 0777)
            return fd
        f1 = compile(does_stuff, [])
        fd = f1()
        os.close(fd)
        assert os.path.exists(tmpfile)


.. _`mixed posix module`: ../module/posix/


How It Fits Together
====================

.. include:: _ref.txt
