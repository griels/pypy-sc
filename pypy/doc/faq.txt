==========================
Frequently Asked Questions
==========================

.. contents::


General
========================================================================

------------------------------------------------------
Why a new implementation of Python?  What does it add?
------------------------------------------------------

XXX

-------------------------------------------------------------------
What is the status of the project?  Can it be used in practice yet?
-------------------------------------------------------------------

XXX

------------------------------
On what platforms does it run?
------------------------------

PyPy is regularly and extensively tested on Linux machines and on Mac OS X and
mostly works under Windows too (but is tested there less extensively). PyPy
needs a CPython running on the target platform to bootstrap, cross compilation
is not really meant to work, currently. Apart from that restriction, translating
PyPy is supposed to produce nice platform-independent code, so the chances are
not too bad that it works.

Currently (due to time restrictions) we are not trying hard to make PyPy support
64 bit platforms. While this seems to still mostly work out, a few modules won't
work on 64 bit machines, such as ``bz2``.

----------------------------------------------
Which Python version (2.x?) does PyPy support?
----------------------------------------------

PyPy currently targets to be fully compatible with Python 2.4. That means that
it contains the stdandard library of Python 2.4 and that it supports 2.4
features (such as decorators) but not the 2.5 features (with statement, ternary
operators).  The 2.5 features will probably be eventually suported, the most
important reasons why nobody is working on them is that we did not promise this
to the EU and have currently enough other tasks.

-------------------------------------------------
Do threads work?  What are the modules that work?
-------------------------------------------------

Operating-System threads work in a limited way. If you enable the ``thread``
module then PyPy will get support for GIL based threading. One limitation is
that not that many IO operations actually release the GIL, which reduces the
usefulness of threads. On the other hand, PyPy fully supports `stackless-like
microthreads`_ (although both cannot be mixed yet).

As for other modules: The general rule of thumb is that pure-Python modules
work, C extension modules don't. Some of the C extension modules of the standard
library have been re-implemented in pure Python or as a mixed module (for some
there were also older pure-Python versions available). A (probably incomplete)
list:

 * pure Python implementations: binascii, cmath, collections, cPickle,
   cStringIO, datetime, functional, imp, itertools, md5, operator,
   sha, struct

 * mixed module implementations: exceptions, sys, __builtin__, posix
   _codecs, gc, _weakref, array, marshal, errno, math, _sre,  parser, symbol,
   _random, socket, unicodedata, mmap, fcntl, time, select, bz2, crypt, 
   signal


.. _`stackless-like microthreads`: stackless.html

------------------------------------
Can I use CPython extension modules?
------------------------------------

No and there are no current plans to implement so. CPython extension modules
relies heavily on CPython's C API which contains a lot of implementation details
like reference counting, exact C-level objects implementations etc.

Although if your module uses ctypes rather than C-level code, there is a hope.
You can try to write a mixed module (see next question).

------------------------------------------
How do I write extension modules for PyPy?
------------------------------------------

XXX

-----------------
How fast is PyPy?
-----------------

.. _whysoslow:

As of August 2005, PyPy was successfully translated to C.  Compared to
CPython, the version of PyPy that still runs on top of CPython is slower by
a factor of 2000. The first translated version was roughly 300 times slower
than CPython, version 0.8.0 about 10-20 times, version 0.9 about 4-7 times
and the current version (1.0) is about 2.4 - 5 times as slow as CPython.
Note that the speed heavily depends on the enabled options at compile time.




Development
========================================================================

-----------------------------------------------------------
How do I get into PyPy development?  Can I come to sprints?
-----------------------------------------------------------

XXX

----------------------------------
Why so many levels of abstraction?
----------------------------------

XXX see pypy-vm-construction

----------------------------------------------------------------------
I am getting strange errors while playing with PyPy, what should I do?
----------------------------------------------------------------------

It seems that a lot of strange, unexplainable problems can be magically
solved by removing all the \*.pyc files from the PyPy source tree
(script py.cleanup from py/bin will do that for you).
Another thing you can do is removing the pypy/_cache
completely. If the error is persistent and still annoys you after this
treatment please send us a bug report (or even better, a fix :-)

PyPy translation tool chain
========================================================================

------------------------------
What is this RPython language?
------------------------------

RPython is a way of interpreting your python program, running already.
This means that term *RPython* is about some part of your program,
beggining from your entry point (function which you explicitely 
specify) to whatever is called from that point, also across modules.

It's a subset of Python which allows full type inference (ie. you can
deduct at compile time what are arguments of certain function),
which puts it a bit closer to C++ or Java. To read more about RPython
limitations read `RPython description`_

.. _`RPython description`: coding-guide.html#restricted-python

-------------------------------------------------------------------
Couldn't we simply take a Python syntax tree and turn it into Lisp?
-------------------------------------------------------------------

It's not necessarily nonsense, but it's not really The PyPy Way.  It's
pretty hard, without some kind of type inference, to translate, say this
Python::

    a + b

into anything significantly more efficient than this Common Lisp::

    (py:add a b)

And making type inference possible is what RPython is all about.

You could make ``#'py:add`` a generic function and see if a given CLOS
implementation is fast enough to give a useful speed (but I think the
coercion rules would probably drive you insane first).  -- mwh

--------------------------------------------
Do I have to rewrite my programs in RPython?
--------------------------------------------

No.  PyPy always runs your code in its own interpreter, which is a full
and compliant Python 2.4 interpreter.  RPython_ is only the language in
which parts of PyPy itself are written.  XXX

-------------------------
Which backends are there?
-------------------------

Somewhat mature backends:

* Low level backends: C_, LLVM_
* High level backends: CLI_, JVM_, JavaScript_

Partially implemented backends:

* Squeak_, `Common Lisp`_

To learn more about backends take a look at a `translation document`_

.. _CLI: cli-backend.html
.. _JavaScript: js/whatis.html
.. _C: translation.html#the-c-back-end
.. _LLVM: translation.html#the-llvm-back-end
.. _`translation document`: translation.html
.. _JVM: translation.html#genjvm
.. _Squeak: translation.html#gensqueak
.. _`Common Lisp`: translation.html#gencl

-------------------------------------------------------
Are there other projects that need the PyPy tool chain?
-------------------------------------------------------

XXX

----------------------
How do I compile PyPy?
----------------------

See the `getting-started`_ guide.  Note that at the moment this produces
an executable that contains a lot of things that are hard-coded for your
particular system (including paths and other stuff), so it's not
suitable for being installed or redistributed.    XXX

---------------------------------
How do I compile my own programs?
---------------------------------

Start from the example of
`pypy/translator/goal/targetnopstandalone.py`_, which you compile by
typing::

    python translate_pypy.py targetnopstandalone

You can have a look at intermediate C source code, which is (at the
moment) put in ``/tmp/usession-*/testing_1/testing_1.c``.  Of course,
all the function and stuff indirectly used by your ``entry_point()``
function has to be RPython_.     XXX

--------------------------------------------
Why isn't there a simpler way of doing that?
--------------------------------------------

One answer is that "officially speaking" supporting this is not a goal
of the PyPy project.

XXX

A better answer might be that when the target of compilation turns out
not to be RPython, working out *why* can be very difficult, and
working on the annotator to make these messages clearer -- even if
possible -- would take time away from other development tasks.

It's not that writing RPython is difficult, but if there was some kind
of rpythonc compiling tool there would be much more temptation to try
to compile arbitrary, pre-existing Python programs and this is fairly
unlikely to work (to start, there is very little in the way of an
"RPython standard library"). XXX outdated


---------------------------------------------------------------------------
What does the error message "slice start must be proven non-negative" mean?
---------------------------------------------------------------------------

XXX



.. _`RPython`: coding-guide.html#rpython
.. _`getting-started`: getting-started.html

.. include:: _ref.txt
