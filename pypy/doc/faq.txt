==========================
Frequently Asked Questions
==========================

.. contents::


General
========================================================================

-------------
What is PyPy?
-------------

PyPy is both a Python reimplemenation and a framework to implement
interpreters and virtual machines for programming languages,
especially dynamic ones. PyPy tries to find new answers about ease of
creation, flexibility, maintainability and speed trade-offs for
language implementations.  For further details see our `goal and
architecture document`_ .

.. _`goal and architecture document`: architecture.html


.. _`drop in replacement`:

-----------------------------------------
Is PyPy a drop in replacement of CPython?
-----------------------------------------

Not completely yet. There are various areas where PyPy is lacking, such as
threading_ and `extension modules`_. The language features (including built in
types and functions) are very complete and well tested, though. That means that
projects not using many extension modules can probably directly use PyPy. A
project using extension modules might get some problems, though.

------------------------------
On what platforms does it run?
------------------------------

PyPy is regularly and extensively tested on Linux machines and on Mac
OS X and mostly works under Windows too (but is tested there less
extensively). PyPy needs a CPython running on the target platform to
bootstrap, cross compilation is not really meant to work,
currently. At the moment you need CPython 2.4 for the translation
process, 2.5 is not fully supported.

Currently (due to time restrictions) we are not trying hard to make PyPy support
64 bit platforms. While this seems to still mostly work out, a few modules won't
work on 64 bit machines, such as ``bz2``.

----------------------------------------------
Which Python version (2.x?) does PyPy support?
----------------------------------------------

PyPy currently targets to be fully compatible with Python 2.4. That means that
it contains the stdandard library of Python 2.4 and that it supports 2.4
features (such as decorators) but not the 2.5 features (with statement, ternary
operators).  The 2.5 features will probably be eventually suported, the most
important reasons why nobody is working on them is that we did not promise this
to the EU and have currently enough other tasks.

.. _threading:

-------------------------------------------------
Do threads work?  What are the modules that work?
-------------------------------------------------

Operating-System threads work in a limited way. If you enable the ``thread``
module then PyPy will get support for GIL based threading. One limitation is
that not that many IO operations actually release the GIL, which reduces the
usefulness of threads. On the other hand, PyPy fully supports `stackless-like
microthreads`_ (although both cannot be mixed yet).

As for other modules: The general rule of thumb is that pure-Python modules
work, C extension modules don't. Some of the C extension modules of the standard
library have been re-implemented in pure Python or as a mixed module (for some
there were also older pure-Python versions available). A (probably incomplete)
list:

 * pure Python implementations: binascii, cmath, collections, cPickle,
   cStringIO, datetime, functional, imp, itertools, md5, operator,
   sha, struct

 * mixed module implementations: exceptions, sys, __builtin__, posix
   _codecs, gc, _weakref, array, marshal, errno, math, _sre,  parser, symbol,
   _random, socket, unicodedata, mmap, fcntl, time, select, bz2, crypt, 
   signal


.. _`stackless-like microthreads`: stackless.html


.. _`extension modules`:

------------------------------------
Can I use CPython extension modules?
------------------------------------

No and there are no current plans to support this. CPython extension modules
rely heavily on CPython's C API which contains a lot of implementation details
like reference counting, exact C-level objects implementations etc.

Although if your module uses ctypes rather than C-level code, there is a hope.
You can try to write a mixed module (see next question).

------------------------------------------
How do I write extension modules for PyPy?
------------------------------------------

PyPy extension modules are in the form of so called `mixed modules`_,
at the moment they all need to be translated together with the rest of PyPy.

We have a proof concept in what we call the `extension compiler`_ and
our support for a static variant of ctypes interface (`rctypes`_) to
help with their development. At the moment both have quite some rough
edges, also cross compilation to CPython extensions which is possible
doesn't deliver completely satisfying results.  This area is going to
improve over time.

.. _`mixed modules`: coding-guide.html#mixed-module-mechanism
.. _`extension compiler`: extcompiler.html
.. _`rctypes`: rctypes.html

.. _`slower than CPython`:

-----------------
How fast is PyPy?
-----------------

.. _whysoslow:

As of August 2005, PyPy was successfully translated to C.  Compared to
CPython, the version of PyPy that still runs on top of CPython is slower by
a factor of 2000. The first translated version was roughly 300 times slower
than CPython. In later versions, we increased the speed. CPython was about
10-20 times as fast as version 0.8.0, 4-7 times as fast as version 0.9 and
2.4 - 5 times as fast as the current version (0.99).
Note that the speed heavily depends on the enabled options at compile time.


.. _`prolog and javascript`:

-----------------------------------------------------------------------
What is this talk about a JavaScript and a Prolog interpreter in PyPy?
-----------------------------------------------------------------------

Since a Python interpreter is a rather large and intricate thing, our toolsuite
became quite advanced to support it. Therefore people had the idea of using it
to implement interpreters for other dynamic languages than Python and get a lot
of things for free (translation to various languages, stackless features,
garbage collection, implementation of various things like arbitraryly long
integers). Therefore people started to implement a `JavaScript interpreter`_
(Leonardo Santagada as his Summer of PyPy project) and a `Prolog interpreter`_
(Carl Friedrich Bolz as his Masters thesis). Both projects are undocumented and
unfinished, at the moment (the Prolog interpreter being less unfinished).

.. _`JavaScript interpreter`: ../../pypy/lang/js
.. _`Prolog interpreter`: ../../pypy/lang/prolog


Development
========================================================================

-----------------------------------------------------------
How do I get into PyPy development?  Can I come to sprints?
-----------------------------------------------------------

Sure you can come to sprints! We always welcome newcomers and try to help them
get started in the project as much as possible (e.g. by providing tutorials and
pairing them with experienced PyPy developers). Newcomers should have some
Python experience and read some of the PyPy documentation before coming to a
sprint.

Coming to a sprint is usually also the best way to get into PyPy development.
If you want to start on your own, take a look at the list of `project
suggestions`_. If you get stuck or need advice, `contact us`_. Usually IRC is
the most immediate mean to get feedback (at least during some parts of the day,
many PyPy developers are in Europe) and the mailing list is better for long
discussions.

.. _`project suggestions`: project-ideas.html
.. _`contact us`: contact.html

----------------------------------------------------------------------
I am getting strange errors while playing with PyPy, what should I do?
----------------------------------------------------------------------

It seems that a lot of strange, unexplainable problems can be magically
solved by removing all the \*.pyc files from the PyPy source tree
(the script `py.cleanup`_ from py/bin will do that for you).
Another thing you can do is removing the directory pypy/_cache
completely. If the error is persistent and still annoys you after this
treatment please send us a bug report (or even better, a fix :-)

.. _`py.cleanup`: http://codespeak.net/py/current/doc/bin.html


PyPy translation tool chain
========================================================================

------------------------------
What is this RPython language?
------------------------------

RPython is a restricted subset of the Python language. The restrictions are to
ensure that type inference (and eventually translation to other languages) of
the program is possible. These restrictions only apply after the full import
happened, so at import time arbitrary Python code can be executed. Another
important point is that the property of "being RPython" always applies to a full
program, not to single functions or modules (the translation tool chain does a
full program analysis).

The restrictions that apply to programs to be RPython mostly limit the ability
of mixing types in arbitrary ways. RPython does not allow the usage of two
different types in the same variable. In this respect (and in some others) it
feels a bit like Java. Other features not allowed in RPython are the usage of
special methods (``__XXX__``) except ``__init__`` and ``__del__`` and reflection
capabilities (e.g. ``__dict__``).

Most existing standard library modules are not RPython, except for
some functions in ``os``, ``math`` and ``time`` that are natively
supported. In general it is quite unlikely that an existing Python
program is by chance RPython, mostly it has to be rewritten heavily.
To read more about RPython limitations read `RPython description`_

.. _`RPython description`: coding-guide.html#restricted-python


--------------------------------------------------------------------------
What do you mean by "full program"? All the code in all the modules I use?
--------------------------------------------------------------------------

"Full program" in the context of "being RPython" is all the code reachable from
an "entry point" function. The translation toolchain follows all calls
recursively and discovers what belongs to the program and what not.

------------------------------------------------------
What's the ``"NOT_RPYTHON"`` I see in some docstrings?
------------------------------------------------------

If you put "NOT_RPYTHON" into the docstring of a function and that function is
found while trying to translate an RPython program, the translation process
stops and reports this as an error. You can therefore mark functions as
"NOT_RPYTHON" to make sure that they are never analyzed.


-------------------------------------------------------------------
Couldn't we simply take a Python syntax tree and turn it into Lisp?
-------------------------------------------------------------------

It's not necessarily nonsense, but it's not really The PyPy Way.  It's
pretty hard, without some kind of type inference, to translate, say this
Python::

    a + b

into anything significantly more efficient than this Common Lisp::

    (py:add a b)

And making type inference possible is what RPython is all about.

You could make ``#'py:add`` a generic function and see if a given CLOS
implementation is fast enough to give a useful speed (but I think the
coercion rules would probably drive you insane first).  -- mwh

--------------------------------------------
Do I have to rewrite my programs in RPython?
--------------------------------------------

No.  PyPy always runs your code in its own interpreter, which is a
full and compliant Python 2.4 interpreter.  RPython_ is only the
language in which parts of PyPy itself are written and extension
modules for it.  The answer whether something needs to be written as
an extension module, apart from glueing external libraries, will
change over time as speed for normal Python code improves.

-------------------------
Which backends are there?
-------------------------

Backends that can actually translate all of PyPy:

 * C_, LLVM_, CLI_

Somewhat mature backends:

* Low level backends: C_, LLVM_
* High level backends: CLI_, JVM_, JavaScript_

Partially implemented backends:

* Squeak_, `Common Lisp`_


To learn more about backends take a look at the `translation document`_

.. _CLI: cli-backend.html
.. _JavaScript: js/whatis.html
.. _C: translation.html#the-c-back-end
.. _LLVM: translation.html#the-llvm-back-end
.. _`translation document`: translation.html
.. _JVM: translation.html#genjvm
.. _Squeak: translation.html#gensqueak
.. _`Common Lisp`: translation.html#gencl

----------------------
How do I compile PyPy?
----------------------

See the `getting-started`_ guide.

--------------------------------------
How do I compile my own interpreters?
--------------------------------------

Start from the example of
`pypy/translator/goal/targetnopstandalone.py`_, which you compile by
typing::

    python translate.py targetnopstandalone

You can have a look at intermediate C source code, which is (at the
moment) put in ``/tmp/usession-*/testing_1/testing_1.c``.  Of course,
all the function and stuff indirectly used by your ``entry_point()``
function has to be RPython_.


.. _`RPython`: coding-guide.html#rpython
.. _`getting-started`: getting-started.html

.. include:: _ref.txt
