"""This produces a graph in the style that was manually experimented
with in http://codespeak.net/svn/user/arigo/hack/misc/stackless.c
And is meant to replace stackless support in the PyPy backends.

Stackless transformation workplan.
====================================

Currently genc has stackless support mostly spread over two files. (c/stackless.py & c/src/ll_stackless.h)
In addition some files are generated by genc (in the tmp directory):
    - slp_defs.h (frame structures and prototype of functions for initialization)
    - slp_signatures.h (resume function calls, one per function signature id)
    - slp_state_decoding.h (table for finding resume function (including signature id))
    - slp_imp.c (actual frame initializers)

Objective is to get rid of 'hardcoded; stackless support in genc (c/stackless.py)
as well as the handwritten code in c/src/ll_stackless.h

This is done by first creating a transformation (backendopt/stackless.py) that
does basically the same as SlpFunctionCodeGenerator in c/stackless.py . The
four slp_* files would be stored in graph structures and arrays. This process
should leave the old code working and unchanged as much as possible!
This step alone would make stackless work in genllvm.

A second step would be to rewrite c/src/ll_stackless.h in RPython. This would
allow backendopt transformations to be more effective but yields no additional
advantage to PyPy's current backends (genjs has handwritten stackless support),
and other backends are probably too experimental at this stage to benefit
from stackless support.
"""

from pypy.translator.backendopt.support import log, all_operations, annotate
log = log.stackless

def stackless(translator, stacklessdata):
    log('starting')

    for graph in translator.graphs:
        """
        #note: c/stackless.py check_directcall_result() computes savelines and resumeblocks
        if not savelines:
            continue
        generate_savelines()
        generate_resumeblocks()
        graph.operations.insert(0, 'if (slp_frame_stack_top) goto resume;')
        """
        for block in graph.iterblocks():
            for opindex, op in enumerate(block.operations):
                if op.opname not in ('direct_call', 'indirect_call'):
                    continue
                needstackless = False #TODO: extract from SlpFunctionCodeGenerator.check_directcall_result
                if not needstackless:
                    continue
                """
                emit code like:
                    l_v74 = pypy_g_f(l_v73);
                    if (slp_frame_stack_bottom)     # 1.
                        goto save_2;
                    resume_2:
                    #2. check rpythonexception
                1. was generated by SlpFunctionCodeGenerator.check_directcall_result
                2. will be generated by FunctionCodeGenerator.check_directcall_result
                2. should actually still be generated by the backends. The problem is that 
                """

    def generate_savelines():
        """
        for line in self.savelines:  # save-state-away lines
            yield line
        """
        return

    def generate_resumeblocks():
        """
        yield 'resume:'    # resume-state blocks
        yield '{'
        yield '\tslp_frame_t* f = slp_frame_stack_top;'
        yield '\tslp_frame_stack_top = NULL;'
        yield '\tswitch (slp_restart_substate) {'
        for block in self.resumeblocks:
            for line in block:
                yield '\t'+line
        yield '\t}'
        yield '\tassert(!"bad restart_substate");'
        yield '}'
        """

    def compute_function_signatures():
        """
        # record extra data needed to generate the slp_*.h tables:
        # find the signatures of all functions
        slpdata = self.db.stacklessdata
        argtypes = [signature_type(self.lltypemap(v))
        for v in self.graph.getargs()]
        argtypes = [T for T in argtypes if T is not lltype.Void]
        rettype = signature_type(self.lltypemap(self.graph.getreturnvar()))
        FUNC = lltype.FuncType(argtypes, rettype)
        slpdata.registerunwindable(self.functionname, FUNC,
                                   resume_points = len(self.resumeblocks))
        """

    log('finished')
