"""
LLVMRepr is the base class for all LLVM representations of nearly any Python
object. A representation knows the name and type of an object in LLVM. It is
responsible for generating the neccessary global definitions and functions the
objects needs to be represented in LLVM.

Each representation has a set of dependencies. The LLVMGenerator makes sure
that the definitions of an object the represenation depends on are written to
the file first.

All the representation classes define a static ``get`` method. It should return
an appropriate representation of the object if it can be represented by the
class and None if not.

Most representations are generated by calling the LLVMGenerators get_repr
method. Thus the representation classes do not need to know anything about each
other.
"""
import autopath
import sets

from pypy.objspace.flow.model import Variable, Constant
from pypy.objspace.flow.model import last_exception

from pypy.rpython import lltype

from pypy.annotation import model as annmodel
from pypy.translator.llvm.lazyattribute import MetaLazyRepr

LLVM_SIMPLE_TYPES = {annmodel.SomeChar: "sbyte",
                     annmodel.SomeBool: "bool",
                     annmodel.SomeFloat: "double"}

# this is only used as a token for the pointer to the last exception object
last_exc_value = object()


debug = False


class CompileError(Exception):
    pass


class LLVMRepr(object):
    __metaclass__ = MetaLazyRepr

    def get(obj, gen):
        return None
    get = staticmethod(get)

    def __init__(self, obj, gen):
        pass

    def setup(self):
        pass
    
    def get_globals(self):
        return ""

    def get_functions(self):
        return ""

    def collect_init_code(self, lblock, l_func):
        pass

    def llvmname(self):
        return self.name

    def llvmtype(self):
        return self.type.typename()

    def llvmsize(self):
        raise NotImplementedError, "This object has no size!"

    def op(self, opname, l_target, args, lblock, l_func):
        if hasattr(self, "type") and hasattr(self.type, "t_op"):
            return self.type.t_op(opname, l_target, args, lblock, l_func)
        raise CompileError, "op '%s' not supported" % opname

    def typed_name(self):
        return self.llvmtype() + " " + self.llvmname()

    def get_dependencies(self):
        try:
            return self.dependencies
        except AttributeError:
            return sets.Set()

class SignedRepr(LLVMRepr):
    def __init__(self, value, gen):
        if debug:
            print "SignedRepr: %d" % value
        self.value = value
        self.gen = gen
        self.type = self.gen.get_repr(lltype.Signed)

    def llvmname(self):
        return str(self.value)

    def get_dependencies(self):
        return [self.type]

class UnsignedRepr(LLVMRepr):
    def __init__(self, value, gen):
        if debug:
            print "UnsignedRepr: %d" % value
        self.value = value
        self.gen = gen
        self.type = self.gen.get_repr(lltype.Unsigned)

    def llvmname(self):
        return str(self.value)

    def get_dependencies(self):
        return [self.type]

class BoolRepr(LLVMRepr):
    def __init__(self, value, gen):
        if debug:
            print "BoolRepr: %d" % value
        self.value = bool(value)
        self.gen = gen
        self.type = self.gen.get_repr(lltype.Bool)

    def llvmname(self):
        return str(self.value).lower()
        
    def get_dependencies(self):
        return [self.type]

class CharRepr(LLVMRepr):
    def __init__(self, value, gen):
        if debug:
            print "CharRepr: %d" % value
        assert len(value) == 1
        self.value = value
        self.gen = gen
        self.type = self.gen.get_repr(lltype.Char)

    def llvmname(self):
        value = value
        if ' ' <= value < '\x7f':
            return "'%s'" % (value.replace("'", r"\'"),)
        else:
            return '%d' % ord(value)
        
    def get_dependencies(self):
        return [self.type]

       
class SimpleRepr(LLVMRepr):
    """Representation of values that only need simple representation:
bool, char (string of length 1), last_exception, last_exc_value"""

    def get(obj, gen):
        if obj is last_exception or (isinstance(obj, Constant) and
                                     obj.value is last_exception):
            return SimpleRepr("%std.class**",
                              "%std.last_exception.type", gen)
        if obj is last_exc_value or (isinstance(obj, Constant) and
                                     obj.value is last_exc_value):
            return SimpleRepr("%std.exception**",
                              "%std.last_exception.value", gen)
        if isinstance(obj, Constant):
            type_ = gen.annotator.binding(obj)
            if type_.__class__ in LLVM_SIMPLE_TYPES:
                llvmtype = LLVM_SIMPLE_TYPES[type_.__class__]
                return SimpleRepr(llvmtype, repr(obj.value), gen)
        return None
    get = staticmethod(get)
    
    def __init__(self, type_, llvmname, gen):
        if debug:
            print "SimpleRepr: %s, %s" % (type, llvmname)
        self.type = type_
        if llvmname in ("False", "True"):
            llvmname = llvmname.lower()
        self.name = llvmname
        self.gen = gen
        self.dependencies = sets.Set()

    def llvmtype(self):
        return self.type

    def __getattr__(self, name):
        return getattr(self.type, name, None)

class IntRepr(LLVMRepr):
    def get(obj, gen):
        if obj.__class__ is int:
            type_ = gen.annotator.binding(Constant(obj))
            return IntRepr(type_, obj, gen)
        if not isinstance(obj, Constant):
            return None
        try:
            type_ = gen.annotator.binding(obj)
        except AssertionError:
            return None
        if type_.__class__ == annmodel.SomeInteger:
            return IntRepr(type_, obj.value, gen)
    get = staticmethod(get)

    def __init__(self, annotation, value, gen):
        if debug:
            print "IntRepr", annotation, value
        self.value = value
        self.annotation = annotation
        self.type = gen.get_repr(annotation)
        self.gen = gen
        self.dependencies = sets.Set()

    def llvmname(self):
        return repr(self.value)

    def cast_to_unsigned(self, l_val, lblock, l_function):
        if self.type.annotation.unsigned:
            return self
        else:
            return IntRepr(annmodel.SomeInteger(True, True),
                           self.value, self.gen)

    def cast_to_signed(self, l_val, lblock, l_function):
        if not self.type.annotation.unsigned:
            return self
        else:
            return IntRepr(annmodel.SomeInteger(), self.value, self.gen)

class VariableRepr(LLVMRepr):
    def get(obj, gen):
        if isinstance(obj, Variable):
            return VariableRepr(obj, gen)
        return None
    get = staticmethod(get)

    def __init__(self, var, gen):
        if debug:
            print "VariableRepr: %s" % (var.name)
        self.var = var
        try:
            type_ = var.concretetype
        except AttributeError:
            type_ = gen.annotator.binding(var.c)
        self.type = gen.get_repr(type_)
        print "XXXXXXXXXXXXXXXX", self.type
        self.dependencies = sets.Set([self.type])

    def llvmname(self):
        return "%" + self.var.name

    def __getattr__(self, name):
        print "$%%%%%%%%%%%%%%%%%getattr called", name, self.type.typename()
        if name.startswith("op_"):
            return getattr(self.type, "t_" + name, None)
        elif name.startswith("cast_"):
            return getattr(self.type, name, None)
        else:
            raise AttributeError, ("VariableRepr instance has no attribute %s"
                                   % repr(name))

class TmpVariableRepr(LLVMRepr):
    def __init__(self, name, type_, gen):
        if debug:
            print "TmpVariableRepr: %s %s" % (type_, name)
        self.name = name
        self.type = type_
        self.dependencies = sets.Set()

    def llvmname(self):
        return "%" + self.name

class NoneRepr(LLVMRepr):
    def get(obj, gen):
        if isinstance(obj, Constant) and obj.value is None:
            return NoneRepr(gen)
    get = staticmethod(get)

    def __init__(self, gen):
        self.gen = gen
        self.type = gen.get_repr(type(None))
        self.dependencies = sets.Set([self.type])
        if debug:
            print "NoneRepr, llvmname: %s, llvmtype: %s" % (self.llvmname(),
                                                            self.llvmtype())
    def llvmname(self):
        return "null"

class StringRepr(LLVMRepr):
    def get(obj, gen):
        if isinstance(obj, Constant):
            type_ = gen.annotator.binding(obj)
            if isinstance(type_, annmodel.SomeString):
                return StringRepr(obj.value, gen)
        elif isinstance(obj, str):
            return StringRepr(obj, gen)
        return None
    get = staticmethod(get)

    def __init__(self, obj, gen):
        if debug:
            print "StringRepr: %s, %s length: %i" % (obj, repr(obj), len(obj))
        self.s = obj
        self.gen = gen
        self.glvar1 = gen.get_global_tmp("StringRepr")
        self.glvar2 = gen.get_global_tmp("StringRepr")
        self.type = gen.get_repr(annmodel.SomeString())
        self.dependencies = sets.Set([self.type])

    def llvmname(self):
        return self.glvar2

    def get_globals(self):
        d = {"len": len(self.s), "gv1": self.glvar1, "gv2": self.glvar2,
             "type": self.type.typename_wo_pointer(),
             "string": str(repr(self.s)[1:-1].replace("\\x", "\\"))}
        s = """%(gv1)s = internal global [%(len)i x sbyte] c"%(string)s"
%(gv2)s = internal global %(type)s {uint %(len)i,\
sbyte* getelementptr ([%(len)i x sbyte]* %(gv1)s, uint 0, uint 0)}"""
        return s % d

    def __getattr__(self, name):
        if name.startswith("op_"):
            return getattr(self.type, "t_" + name, None)
        else:
            raise AttributeError, ("VariableRepr instance has no attribute %s"
                                   % repr(name))

