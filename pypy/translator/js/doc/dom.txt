pypy/translator/js/modules/dom.py
=================================

This document describes the module 'dom' that can be imported in CPython to
allow testing code that should be translated to JavaScript and run in a
browser. The dom library contains a subset of the DOM implementation in
the Mozilla browser (and other standard-compliant browsers), in such a way
that the results of DOM manipulations and (some of the more common) browser
API calls can be tested.

What is supported?
------------------

Currently supported are:

  * DOM level 2
  
    This is provided by wrapping the 'xml.dom.minidom' library as found in 
    core Python. Some functionality was changed a bit to behave more like the
    browser's DOM, for instance 'getElementById()' explicitly checks for
    attributes called 'id' and 'getElementsByTagName()' ignores the nodeName
    argument's case.

    Example::

      >>> from pypy.translator.js.modules.dom import get_window
      >>> window = get_window()
      >>> document = window.document
      >>> div = document.createElement('div')
      >>> div.appendChild(document.createTextNode('foo'))
      <Text #text>
      >>> body = document.getElementsByTagName('body')[0]
      >>> body.appendChild(div)
      <Element DIV>
      >>> len(body.childNodes)
      1

  * EventTarget

    This is implemented in Python, and is a simplified version of what is 
    provided by Mozilla. There is an EventTarget interface that is implemented
    by all Node types and the Window object, that provides the standard
    addEventListener, removeEventListener and dispatchEvents methods, and
    the API allows instantiating an event with standard arguments. Groups are
    ignored (as they mostly are in browsers), and additional information on
    MouseEvent and KeyEvent are not supported (so there is no information about
    the physical location of the event and such).

    Currently events aren't fired automatically, to test event handling an
    event must be explicitly instantiated and dispatched::

      >>> def handler(e):
      ...   e.foo = 'bar'
      >>> body.addEventListener('click', handler, False)
      >>> e = document.createEvent('group is ignored')
      >>> e.initEvent('click', True, True)
      >>> document.getElementsByTagName('body')[0].dispatchEvent(e)
      >>> e.foo
      'bar'

    (This would result in all handlers for the 'click' event registered on
    body (and if not cancelled, bubbling up to the document node) getting
    called, with the event as argument.)

  * Window

    There is a function 'get_window()' that returns a reference to a global
    Window object. This provides (again a subset of) the functionality that
    is available on the 'window' object in browsers (the default namespace).

    Example::

      >>> window.location
      'about:blank'
      >>> window.self is window
      True
    
  * Additional HTML functionality on Element and Document

    There is some additional functionality available that is browser-specific,
    such as the .innerHTML property (note that setting .innerHTML to a string
    that is not well-formed will result in a failure!) and .className and .id
    properties.

    Example::

      >>> body = document.getElementsByTagName('body')[0]
      >>> body.nodeName
      u'BODY'

  * CSS support

    There is support for inline style tags, not for stylesheets. Style 
    attributes are read on accessing the style property, and the style property
    is used on HTML serialization (using .innerHTML).

    Example::

      >>> body.innerHTML = '<div style="background-color: green">foo</div>'
      >>> body.firstChild.style.backgroundColor
      u'green'
      >>> body.firstChild.style.backgroundColor = 'black'
      >>> body.innerHTML
      u'<div style="background-color: black;">foo</div>'

